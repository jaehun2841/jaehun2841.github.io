<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다. | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../melody-favicon.ico"><link rel="stylesheet" href="../../css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href=".."><span class="pull-left">Articles</span><span class="pull-right">112</span></a><a class="author-info-articles__tags article-meta" href="../../tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Carrey`s 기술블로그</div><div id="site-sub-title">공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="../../2020/05/30/object-chapter7/">Objects Study - Chapter7. 객체 분해</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-30</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="추상화와-분해"><a href="#추상화와-분해" class="headerlink" title="추상화와 분해"></a>추상화와 분해</h1><p>불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만을 남기는 작업을 <strong>추상화</strong> 라고 부른다.<br>가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 크기를 줄이는 것이다. </p>
<p>이처럼 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 <strong>분해(decomposition)</strong> 이라고 부른다.<br>분해의 목적은 큰 문제를 한번에 처리할 수 있는 규모의 문제로 나누는 것이다.<br>한 가지 주목할 점은 정보의 가장 작은 단위로서의 개별 항목을 의미하는 것이 아니라 하나의 단위로 취급될 수 있는 논리적인 chunk를 의미한다.</p>
<p>추상화와 분해는 인간이 세계를 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구이다.<br>복잡성이 존재하는 곳에 추상화와 분해 역시 함께 존재한다.<br>소프트웨어 개발 영역에서는 복잡한 문제를 해결하기 위해 추상화와 분해를 사용한다.</p>
<h1 id="프로시저-추상화와-데이터-추상화"><a href="#프로시저-추상화와-데이터-추상화" class="headerlink" title="프로시저 추상화와 데이터 추상화"></a>프로시저 추상화와 데이터 추상화</h1><p>프로그래밍 언어의 발전은 좀 더 효과적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력에서 출발했다.<br>프로그래밍 언어를 통해 표현되는 추상화의 발전은 다양한 프로그래밍 패러다임의 탄생으로 이어졌다.<br>프로그래밍 패러다임은 프로그래밍을 구성하기 위해 사용하는 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해나는 방법의 두 가지 요소로 결정된다.<br>따라서 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.</p>
<p>현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘은 <strong>프로시저 추상화</strong>와 <strong>데이터 추상화</strong> 이다.</p>
<h2 id="프로시저-추상화"><a href="#프로시저-추상화" class="headerlink" title="프로시저 추상화"></a>프로시저 추상화</h2><ul>
<li>프로시저 추상화를 중심으로 시스템을 분해하는 것은 기능 분해(functional decomposition)을 통해 추상화 하는 기법이다.  </li>
<li>기능 분해는 알고리즘 분해(algorithmic decomposition)이라고 부르기도 한다.</li>
</ul>
<h2 id="데이터-중심-추상화"><a href="#데이터-중심-추상화" class="headerlink" title="데이터 중심 추상화"></a>데이터 중심 추상화</h2><p>데이터 중심으로 추상화 하는 방법은 타입 추상화와 프로시저 추상화 두 가지가 있다. </p>
<ul>
<li><strong>타입 추상화(type abstraction)</strong><ul>
<li>추상 데이터 타입이라 부른다.</li>
</ul>
</li>
<li><strong>프로시저 추상화(procedure abstraction)</strong><ul>
<li>객체지향이라 부른다.</li>
<li>역할과 책임을 수행하는 객체</li>
</ul>
</li>
</ul>
<h1 id="프로시저-추상화와-기능-분해"><a href="#프로시저-추상화와-기능-분해" class="headerlink" title="프로시저 추상화와 기능 분해"></a>프로시저 추상화와 기능 분해</h1><p>기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됐다.<br>이 같은 시스템 분해 방식을 <strong>알고리즘 분해</strong> 또는 <strong>기능 분해</strong>라고 부른다.<br>기능 분해의 관점에서 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해된다.</p>
<p><strong>프로시저(procedure)</strong> 란</p>
<ul>
<li>반복적으로 실행되거나 거의 유사하게 실행되는 작업들의 모임</li>
<li>로직을 재상용하고 중복을 방지할 수 있는 추상화 방법</li>
<li>내부의 상세구현을 모르더라도 외부에 공개된 인터페이스만 알면 프로시저를 사용할 수 있다.</li>
<li>프로시저는 잠재적으로 정보 은닉의 가능성을 제시<ul>
<li>하지만 효과적인 정보은닉 체계를 구축하는데는 한계가 있다.</li>
</ul>
</li>
</ul>
<h1 id="하향식-접근법-Top-Down-Approach"><a href="#하향식-접근법-Top-Down-Approach" class="headerlink" title="하향식 접근법(Top-Down Approach)"></a>하향식 접근법(Top-Down Approach)</h1><p>전통적인 분해 방법은 <strong>하향식 접근법</strong>을 따른다.<br>하향식 접근법이란 시스템을 구성하는 최상위 기능을 정의하고 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법<br>분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다.<br>각 세분화 단계는 바로 위 단계보다 구체적이어야 한다. (상위 기능보다 덜 추상적이어야 한다.)</p>
<h2 id="하향식-접근법의-문제점"><a href="#하향식-접근법의-문제점" class="headerlink" title="하향식 접근법의 문제점"></a>하향식 접근법의 문제점</h2><p>하향식 기능 분해 방법은 겉으로는 이상적일 수 있지만, 실제로 설계에 적용하다 보면 다음과 같은 다양한 문제에 직면한다.</p>
<ul>
<li>시스템은 하나의 메인 함수로 구성돼 있지 않다.</li>
<li>기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.</li>
<li>비지니스 로직이 사용자 인터페이스와 강하게 결합된다.</li>
<li>하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.</li>
<li>데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.</li>
</ul>
<p>위와 같은 문제로 인해 하향식 접근법과 기능 분해가 가지는 근본적인 문제점은 변경에 취약한 설계를 낳는다는 것이다.</p>
<h2 id="시스템은-하나의-메인-함수로-구성되지-않는다"><a href="#시스템은-하나의-메인-함수로-구성되지-않는다" class="headerlink" title="시스템은 하나의 메인 함수로 구성되지 않는다."></a>시스템은 하나의 메인 함수로 구성되지 않는다.</h2><ul>
<li><p>어떤 시스템도 최초에 릴리즈됐던 당시의 모습을 그대로 유지하지는 않는다.  </p>
</li>
<li><p>시간이 지나고 사용자를 만족시키기 위한 새로운 요구사항을 도출해나가면서 지속적으로 새로운 기능을 추가하게 된다.<br>이것은 시스템이 오직 하나의 메인 함수만으로 구현된다는 개념과는 완전히 모순된다.  </p>
</li>
<li><p>하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다.</p>
</li>
</ul>
<h2 id="기능-추가나-요구사항-변경으로-인해-메인-함수는-빈번하게-수정된다"><a href="#기능-추가나-요구사항-변경으로-인해-메인-함수는-빈번하게-수정된다" class="headerlink" title="기능 추가나 요구사항 변경으로 인해 메인 함수는 빈번하게 수정된다."></a>기능 추가나 요구사항 변경으로 인해 메인 함수는 빈번하게 수정된다.</h2><ul>
<li>시스템 안에는 여러 개의 정상급 함수가 존재하기 때문에 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하기 어렵다.  </li>
<li>하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.  </li>
<li><strong>기존 로직과는 아무런 상관이 없는 새로운 함수의 적절한 위치를 확보해야 하기 때문</strong>에 메인 함수의 구조를 급격하게 변경하거나 새로 짤 수 밖에 없다.</li>
<li>코드의 빈번한 수정으로 인한 버그 발생 확률이 높아지고 시스템은 변경에 취약해질 수 밖에 없다.</li>
</ul>
<h2 id="비지니스-로직이-사용자-인터페이스와-강하게-결합된다"><a href="#비지니스-로직이-사용자-인터페이스와-강하게-결합된다" class="headerlink" title="비지니스 로직이 사용자 인터페이스와 강하게 결합된다."></a>비지니스 로직이 사용자 인터페이스와 강하게 결합된다.</h2><ul>
<li>하향식 접근법은 비지니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다.  </li>
<li>결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.</li>
<li>사용자 인터페이스 로직과 비즈니스 로직을 한데 섞기 때문에 사용자 인터페이스를 변경하면 비즈니스 로직까지 영향을 받게 된다.</li>
<li>하향식 접근법은 기본적으로 변경에 불안정한 아키텍처 구조를 갖게 된다.</li>
</ul>
<h2 id="너무-이른-시기에-함수들의-실행-순서를-고정시키기-때문에-유연성과-재사용성이-저하된다"><a href="#너무-이른-시기에-함수들의-실행-순서를-고정시키기-때문에-유연성과-재사용성이-저하된다" class="headerlink" title="너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다."></a>너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.</h2><ul>
<li>하향식으로 기능을 분해하는 과정에서 함수는 더 작은 함수들로 분해되고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약된다.</li>
<li>설계를 시작하는 시점부터 시스템이 무엇을 해야하는지가 아니라 어떻게 동작해야 하는지에 집중하게 한다</li>
<li>처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 시간적 실행 순서를 강조한다.</li>
<li>결과적으로 모든 중요한 제어 흐름의 결정이 상위 함수에서 이뤄지고 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출된다.</li>
<li>결과적으로 기능을 추가하서나 변경하는 작업은 기존의 함수 제어 구조를 변경하게 만든다.</li>
<li>분해된 함수를 재사용하기 어렵다.<ul>
<li>재사용이라는 개념은 <strong>일반성</strong>이라는 의미를 내포한다. (상위 함수보다 일반적이다)</li>
<li>하향식 접근법에서는 하위 함수는 상위 함수에 비해 일반적일 수 없다. (재사용이 어렵다.)</li>
</ul>
</li>
</ul>
<h2 id="데이터-형식이-변경될-경우-파급효과를-예측할-수-없다"><a href="#데이터-형식이-변경될-경우-파급효과를-예측할-수-없다" class="headerlink" title="데이터 형식이 변경될 경우 파급효과를 예측할 수 없다."></a>데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.</h2><p>하향식 기능분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다.<br>따라서 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.<br>이것은 의존성과 결합도의 문제이다. 그리고 테스트의 문제이기도 하다</p>
<p>데이터의 변경으로 인한 영향은 데이터를 직접 참조하는 모든 함수로 퍼져나간다.<br>따라서 데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것은 예측할 수 없다. </p>
<p>데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다.<br>데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제한다</p>
<p>변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 받지않는 부분을 명확하게 분리하고<br>잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제해야 한다.</p>
<h2 id="언제-하향식-분해가-유용한가"><a href="#언제-하향식-분해가-유용한가" class="headerlink" title="언제 하향식 분해가 유용한가?"></a>언제 하향식 분해가 유용한가?</h2><ul>
<li><p>하향식 접근법은 이미 완전히 이해된 사실을 서술하기에 적합하다</p>
<ul>
<li>시스템이나 프로그램 개발자가 이미 완료한 결과에 대한 명확한 아이디어를 서술하기 위해 하향식을 사용하기 좋다.</li>
<li>작은 프로그램과 개별 알고리즘을 위해서는 하향식 접근법은 유용하다</li>
<li>프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는 데에는 훌륭한 기법이다.</li>
</ul>
</li>
<li><p>새로운 것을 개발하고 설계하고 발전하는 데는 적합하지 않다.</p>
</li>
</ul>
<h1 id="정보-은닉과-모듈"><a href="#정보-은닉과-모듈" class="headerlink" title="정보 은닉과 모듈"></a>정보 은닉과 모듈</h1><p>시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다.<br>기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것이다.</p>
<p>정보 은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리로<br>시스템에서 <strong>자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것</strong>이 핵심이다.</p>
<p>정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리다.<br>모듈은 변경될 가능성이 있는 비밀을 내부로 감추고 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서<br>내부의 비밀에 함부로 접근하지 못하게 한다.</p>
<p>비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.  </p>
<blockquote>
<p>시스템을 모듈 단위로 어떻게 분해할 것인가?<br>정답은 시스템이 감춰야하는 비밀을 찾는 것이다.<br>외부에서 내부의 비밀에 접근하지 못하도록 커다란 방어막을 쳐서 에워싸라.<br>그렇게 하면 이 방어막이 바로 퍼블릭 인터페이스가 된다.</p>
</blockquote>
<p>모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.</p>
<ul>
<li>복잡성 <ul>
<li>모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다.</li>
<li>외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.</li>
</ul>
</li>
<li>변경 가능성<ul>
<li>변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다.</li>
<li>변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감춘다.</li>
<li>외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.</li>
</ul>
</li>
</ul>
<p>시스템의 가장 일반적인 비밀은 <strong>데이터</strong>다<br>비밀이 반드시 데이터일 필요는 없으며 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수도 있다.<br>그럼에도 변경 시 시스템을 굴복시키는 대부분의 경우는 데이터가 변경되는 경우다.</p>
<h1 id="모듈의-장점과-한계"><a href="#모듈의-장점과-한계" class="headerlink" title="모듈의 장점과 한계"></a>모듈의 장점과 한계</h1><p><strong>모듈의 장점</strong></p>
<ul>
<li><p>모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.</p>
<ul>
<li>모듈을 사용하면 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.  </li>
<li>어떤 데이터가 변경됐을 때 영향을 받는 함수를 찾기 위해 해당 데이터를 정의한 모듈만 검색하면 된다. </li>
<li>모듈은 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기 용이하다</li>
</ul>
</li>
<li><p>비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다</p>
</li>
<li><p>전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다.</p>
<ul>
<li>모듈의 한 가지 용도는 네임스페이스를 제공하는 것이다.</li>
<li>변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있다.</li>
<li>모듈은 전역 네임스페이스의 오염을 방지하는 동시에 이름 충돌의 위험을 완화한다.</li>
</ul>
</li>
<li><p>모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.</p>
<ul>
<li>모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이다.<ul>
<li>모듈에 있어 외부에 감춰야 하는 비밀은 데이터다.</li>
</ul>
</li>
<li>모듈 내부는 높은 응집도를 유지한다</li>
<li>모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신한다</li>
<li>모듈과 모듈 사이에는 낮은 결합도를 유지한다.</li>
<li>모듈은 데이터와 함수가 통함된 한 차원 높은 추상화를 제공하는 설계 단위이다.</li>
</ul>
</li>
</ul>
<p><strong>모듈의 단점</strong></p>
<ul>
<li>모듈이 프로시저 추상화 보다는 높은 추상화를 제공한다.</li>
<li>모듈은 인스턴스의 개념을 제공하지 않는다는 단점이 있다.</li>
</ul>
<h1 id="데이터-추상화와-추상-데이터-타입"><a href="#데이터-추상화와-추상-데이터-타입" class="headerlink" title="데이터 추상화와 추상 데이터 타입"></a>데이터 추상화와 추상 데이터 타입</h1><h2 id="추상-데이터-타입"><a href="#추상-데이터-타입" class="headerlink" title="추상 데이터 타입"></a>추상 데이터 타입</h2><ul>
<li><p>프로그래밍 언어에서 <strong>타입(Type)</strong> 이란 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.</p>
</li>
<li><p>프로그래밍 언어는 다양한 형태의 내장 타입(built-in type)을 제공한다.</p>
<ul>
<li>기능 분해 시대에 사용되던 절차형 언어들은 적은 수의 내장 타입만을 제공</li>
<li>새로운 타입을 추가하는 것이 불가능하거나 제한적이었다.</li>
</ul>
</li>
</ul>
<p>추상 데이터 타입은 프로시저 추상화 대신 데이터 추상화를 시반으로 소프트웨어를 개발하게 된 최초의 한걸음이다.<br>추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 지원이 필요하다. </p>
<ul>
<li>타입 정의를 선언할 수 있어야 한다.</li>
<li>타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.</li>
<li>제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.</li>
<li>타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.</li>
</ul>
<blockquote>
<p>리스코프는 추상 데이터 타입을 정의하기 위해 제시한 언어적인 메커니즘을 <strong>오퍼레이션 클러스터(operation cluster)</strong> 라고 불렀다.</p>
</blockquote>
<h1 id="클래스는-추상-데이터-타입인가"><a href="#클래스는-추상-데이터-타입인가" class="headerlink" title="클래스는 추상 데이터 타입인가?"></a>클래스는 추상 데이터 타입인가?</h1><p>대부분의 프로그래밍 서적에서는 클래스를 추상 데이터 타입으로 설명한다.<br>그러나 명확한 의미에서 추상 데이터 타입과 클래스는 동일하지 않다.</p>
<ul>
<li>클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다.</li>
<li>상속과 다형성을 지원하는 프로그래밍 기법을 객체지향 프로그래밍 (Object-Oriented Programming)이라 한다.</li>
<li>상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 기법을 객체기반 프로그래밍(Object-Based Programming)이라 한다.</li>
<li>추상 데이터 타입은 Type을 추상화한 것</li>
<li>클래스는 절차를 추상화한 것</li>
</ul>
<p>윌리엄 쿡은 하나의 대표적인 타입이 다수의 세부적인 타입을 감출 수 있기 때문에 이를 타입 추상화라 불렀다.  </p>
<p><strong>타입 추상화</strong></p>
<p><img src="./type-abstraction.jpg" alt="type-abstraction"></p>
<ul>
<li>개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄 하도록 함으로써 하나의 물리적인 타입 안에 전체 타임을 감춘다.  </li>
<li>타입 추상화는 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법이다.</li>
</ul>
<p><strong>객체지향</strong></p>
<p><img src="./procedural-abstraction.jpg" alt="procedural-abstraction"></p>
<ul>
<li>타입을 기준으로 오퍼레이션을 묶는다.</li>
<li>두 가지 이상의 클래스로 분리할 경우 공통로직을 어디에 둘 것인지가 이슈<ul>
<li>공통 로직을 제공하기 위한 간단한 방법은 공통 로직을 포함할 부모 클래스를 정의하고 상속 시킨다.</li>
</ul>
</li>
<li>클라이언트는 부모 클래스 참조자에 대해 메세지를 전송하면 실제 클래스가 무엇인지에 따라 다른 메소드가 실행된다.</li>
<li>실제로 내부에서 수행되는 절차는 다르지만 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.<ul>
<li>따라서 객체지향은 절차 추상화(procedural abstraction)이다</li>
</ul>
</li>
</ul>
<h1 id="변경을-기준으로-선택하라"><a href="#변경을-기준으로-선택하라" class="headerlink" title="변경을 기준으로 선택하라"></a>변경을 기준으로 선택하라</h1><p>단순히 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지 않는다.<br>비록 클래스를 사용하고 있더라도 타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다.  </p>
<p><strong>추상 데이터 타입 위반 사항 check list</strong></p>
<ul>
<li>클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는가?<ul>
<li>인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체 지향을 위반하는 것으로 간주된다.</li>
</ul>
</li>
</ul>
<p><strong>객체 지향 위반 사항 check list</strong></p>
<p><img src="./Polymorphism.jpg" alt="Polymorphism"></p>
<ul>
<li><p>타입 변수를 이용한 조건문으로 구분하는가?</p>
<ul>
<li>클라이언트가 객체의 타입을 확인하고 메서드를 호출하게 해선 안된다.</li>
<li>객체가 메세지를 처리할 적절한 메서드를 처리하게 해야한다.</li>
</ul>
</li>
<li><p>OCP (Open-Closed Principle) 개방-폐쇄 원칙을 위반하는가?</p>
<ul>
<li>OCP란 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성이다.</li>
<li>기존코드에서 특성 변수에 대한 분기 로직이 있었다면, 새로운 요구사항이 있는 경우 코드를 수정해야 한다.</li>
<li>하지만 객체지향을 이용하면 코드 수정없이도 새로운 유형과 행위를 추가할 수 있다.</li>
</ul>
</li>
</ul>
<h1 id="추상-데이터-타입-vs-객체지향-당신의-선택은"><a href="#추상-데이터-타입-vs-객체지향-당신의-선택은" class="headerlink" title="추상 데이터 타입 vs 객체지향 당신의 선택은?"></a>추상 데이터 타입 vs 객체지향 당신의 선택은?</h1><ul>
<li>타입 추가가 빈번한가?  &#x3D;&gt; <strong>객체지향</strong><ul>
<li>추상데이터 타입의 경우 일일이 새로운 타입에 대해 체크하는 클라이언트 코드를 수정해야 한다.</li>
<li>객체지향의 경우 코드 수정없이 새로운 클래스를 상속 계층에 추가하면 된다.</li>
</ul>
</li>
<li>오퍼레이션 추가가 빈번한가?  &#x3D;&gt; <strong>추상 데이터 타입</strong><ul>
<li>객체지향의 경우 새로운 오퍼레이션을 추가하기 위해서는 상속 계층에 속하는 모든 클래스를 한번에 수정해야 한다.</li>
<li>추상 데이터 타입의 경우에는 전체 타입에 대한 구현 코드가 하나의 구현체에 포함되어 있다.</li>
<li>따라서 새로운 오퍼레이션을 추가하는 작업이 상대적으로 간단하다</li>
</ul>
</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter7. 객체 분해</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2020/05/24/object-chapter6/">Objects Study - Chapter6. 메세지와 인터페이스</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-24</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="협력과-메세지"><a href="#협력과-메세지" class="headerlink" title="협력과 메세지"></a>협력과 메세지</h1><ul>
<li>협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.</li>
<li>메세지는 객체 사이의 협력을 가능하게 하는 매개체다</li>
<li>객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메세지를 전송하는 것뿐이다.</li>
<li>메세지는 매개로 하는 요청과 응답의 조합이 두 객체 사이의 협력을 구성한다.</li>
</ul>
<h2 id="클라이언트-서버-모델"><a href="#클라이언트-서버-모델" class="headerlink" title="클라이언트 서버 모델"></a>클라이언트 서버 모델</h2><p>두 객체 사이의 협력관계를 설명하기 위해 사용하는 전통적인 메타포는 <strong>클라이언트-서버(Client-Server)모델</strong>이다.</p>
<ul>
<li>클라이언트 : 협력 안에서 메세지를 전송하는 객체</li>
<li>서버: 협력 안에서 메세지를 수신하는 객체</li>
</ul>
<p><img src="./client-server.jpg" alt="client-server"></p>
<p>객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 <strong>동시에 수행하는 것이 일반적</strong>이다.<br>협력의 관점에서 객체는 두 가지 종류의 메세지 집합으로 구성된다.</p>
<ol>
<li>객체가 수신하는 메세지의 집합</li>
<li>외부의 객체에게 전송하는 메세지의 집합</li>
</ol>
<p><img src="./client-server2.jpg" alt="client-server2"></p>
<h2 id="메세지와-메세지-전송"><a href="#메세지와-메세지-전송" class="headerlink" title="메세지와 메세지 전송"></a>메세지와 메세지 전송</h2><p><strong>메세지(Message)</strong> 는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.  </p>
<ul>
<li>한 객체가 다른 객체에게 도움을 요청하는 것을 <strong>메세지 전송(message sending)</strong> 또는 <strong>메세지 패싱(message passing)</strong> 이라 부른다.</li>
<li>메세지를 전송하는 객체를 <strong>메세지 전송자(message sender)</strong> 혹은 <strong>클라이언트</strong>라고 부른다.</li>
<li>메세지를 수신하는 객체를 <strong>메세지 수신자(message receiver)</strong> 혹은 <strong>서버</strong>라고 부른다.</li>
</ul>
<p><img src="./message.jpg" alt="message"></p>
<ul>
<li>메세지는 오퍼레이션 + 인자로 구성</li>
<li>메세지 전송은 수신자 + 오퍼레이션 + 인자로 구성</li>
</ul>
<h2 id="메세지와-메서드"><a href="#메세지와-메서드" class="headerlink" title="메세지와 메서드"></a>메세지와 메서드</h2><p>메세지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 <strong>메서드</strong>라 부른다.<br>중요한 점은 코드 상에서 동일한 이름의 변수(condition)에게 동일한 메세지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수가 있다는 것이다.</p>
<ul>
<li>전통적인 방식 - 컴파일 레벨에서 어떤 코드가 실행될지 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 호출 구문을 작성한다.</li>
<li>객체지향 방식 - 메세지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다. <ul>
<li>메세지와 메서드의 구분은 메세지 전송자와 메세지 수신자가 느슨하게 결합되도록 한다.</li>
<li>메세지 전송자는 자신이 어떤 메세지를 객체에 전송할 지만 알면된다.</li>
<li>메세지 수신자는 누가 전송하는지는 알 필요가 없고 전송받은 메세지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.</li>
</ul>
</li>
</ul>
<p><strong>실행 시점에 메세지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.</strong></p>
<h2 id="Public-인터페이스와-오퍼레이션"><a href="#Public-인터페이스와-오퍼레이션" class="headerlink" title="Public 인터페이스와 오퍼레이션"></a>Public 인터페이스와 오퍼레이션</h2><ul>
<li><p>객체가 의사소통을 위해 외부에 공개하는 메세지의 집합을 <strong>퍼블릭 인터페이스(public interface)</strong> 라고 한다.</p>
</li>
<li><p>퍼블릭 인터페이스에 포함된 메세지를 <strong>오퍼레이션(operation)</strong> 이라고 부른다.</p>
</li>
<li><p>오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다</p>
</li>
</ul>
<p>프로그래밍 언어의 관점에서 객체가 다른 객체에게 메세지를 전송하면 런타임 시스템은 메세지 전송을 <strong>오퍼레이션 호출</strong>로 해석한다.<br>메세지를 수신한 객체의 실제 타입을 기반으로 적잘한 메서드를 찾아 실행한다.<br>따라서 퍼블릭 인터페이스와 메세지의 관점에서 보면 <strong>메서드 호출</strong>보다는 <strong>오퍼레이션 호출</strong>이라는 용어를 사용하는 것이 더 적절하다.</p>
<p><img src="./message-operation.jpg" alt="message-operation"></p>
<h2 id="메서드-시그니처"><a href="#메서드-시그니처" class="headerlink" title="메서드 시그니처"></a>메서드 시그니처</h2><p>오퍼레이션(또는 메서드)와 파라미터 목록을 합쳐 메서드 시그니처 (method signature)라고 부른다.<br>오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다.<br>메서드는 이 시그니처에 구현을 더한 것이다.<br>이반적으로 메세지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행된다.</p>
<p>오퍼레이션의 관점에서 <strong>다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것</strong>이라고 정의할 수 있다.</p>
<h1 id="인터페이스와-설계-품질"><a href="#인터페이스와-설계-품질" class="headerlink" title="인터페이스와 설계 품질"></a>인터페이스와 설계 품질</h1><p>좋은 인터페이스는 <strong>최소한의 인터페이스</strong>와 <strong>추상적인 인터페이스</strong>라는 조건을 만족해야 한다.  </p>
<ul>
<li>최소한의 인터페이스는 오퍼레이션만을 인터페이스에 포함한다.</li>
<li>추상적인 인터페이스는 어떻게 수행하는지가 아닌 무엇을 하는지를 표현한다.</li>
</ul>
<p><strong>책임 주도 설계 방법</strong>은 메세지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다.<br>따라서 인터페이스는 최소의 오퍼레이션만 포함하게 된다.</p>
<h2 id="디미터-법칙"><a href="#디미터-법칙" class="headerlink" title="디미터 법칙"></a>디미터 법칙</h2><p><strong>디미터 법칙(Law of Demeter)</strong> 는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다.<br>요약하자면, 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.  </p>
<ul>
<li>낯선 자에게 말하지 말라 (don&#96;t talk to strangers)</li>
<li>오직 인접한 이웃하고만 말하라 (only talk to your immediate neighbors)</li>
<li>자바와 같이 도트(.)를 이용해 메세지를 전송을 표현하는 언어에서는 “오직 하나의 도트만 사용하라(use only one dot)”</li>
</ul>
<p>디미터 프로젝트를 진행하던 사람들은 디미터 법칙을 이용하여 <strong>객체들간의 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다</strong>는 사실을 발견하였다.</p>
<p>디미터 법칙을 따르면 <strong>부끄럼타는 코드 (shy code)</strong> 를 작성할 수 있다.<br>부끄럽타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.<br>디미터 법칙을 따르는 코드는 메세지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메세지 전송자는 수신자의 내부 구현에 결합되지 않는다.<br>따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.</p>
<h3 id="디미터-법칙을-어기는-코드"><a href="#디미터-법칙을-어기는-코드" class="headerlink" title="디미터 법칙을 어기는 코드"></a>디미터 법칙을 어기는 코드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screening.getMovie().getDiscountConditions();</span><br></pre></td></tr></table></figure>

<p>메세지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메세지를 전송한다.<br>흔히 이와 같은 코드를 <strong>기차 충돌(train wreck)</strong> 이라고 부른다.</p>
<p>이와 같은 코드는 Movie의 내부 구현을 외부로 노출 시키게 되므로 메세지 수신자의 캡슐화는 무너지고<br>메세지 전송자가 메세지 수신자의 내부 구현에 강하게 결합된다.</p>
<p>디미터 법칙은 객체의 내부 구조를 묻는 메세지가 아니라 수신자에게 무언가를 시키는 메세지가 더 좋다고 얘기한다.</p>
<h2 id="묻지-말고-시켜라"><a href="#묻지-말고-시켜라" class="headerlink" title="묻지 말고 시켜라"></a>묻지 말고 시켜라</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screening.getMovie().getDiscountConditions();</span><br></pre></td></tr></table></figure>
<p>위와 같은 코드는 screening에게 직접 요금을 계산할 책임을 할당한 것이다.<br>디미터 법칙은 훌륭한 메세지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.<br>메세지 전송자는 메세지 수신자의 상태를 기반으로 결정을 내린 후 메세지 수신자의 상태를 바꿔서는 안된다.<br>객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.</p>
<p>묻지말고 시켜라 원칙으로 얻는 이점</p>
<ul>
<li>밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.<ul>
<li>객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.</li>
</ul>
</li>
<li>객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.</li>
<li>자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.</li>
</ul>
<h2 id="의도를-드러내는-인터페이스"><a href="#의도를-드러내는-인터페이스" class="headerlink" title="의도를 드러내는 인터페이스"></a>의도를 드러내는 인터페이스</h2><p>켄트 백(Kent Beck)은 Smalltalk Best Practice Patterns에서 메서드를 명명하는 두 가지 방법을 설명했다.  </p>
<ol>
<li>메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다.</li>
<li>“어떻게”가 아니라 “무엇”을 하는지 드러낸다.</li>
</ol>
<h3 id="메서드가-작업을-어떻게-수행하는지를-나타내도록-이름-짓는다"><a href="#메서드가-작업을-어떻게-수행하는지를-나타내도록-이름-짓는다" class="headerlink" title="메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다."></a>메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는다.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeriodCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedByPeriod</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBySequence</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같은 스타일은 좋지 않다.</p>
<ul>
<li>메서드에 대해 제대로 커뮤니케이션 하지 못한다.  두 메서드 모두 할인 조건을 판단하는 메서드이다.</li>
<li>하지만 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행하는 사실을 알아채기 어렵다.</li>
<li>메서드 수준에서 캡슐화를 위반한다.</li>
<li>위의 메서드들은 클라이언트로 하여금 객체의 종류를 알도록 강요한다.</li>
<li>만약에 할인여부가 변경된다면 메세지를 전송하는 클라이언트 코드의  메서드의 이름또한 변경되어야 한다.</li>
<li>따라서 책임을 수행하는 방법을 드러내는 메서드를 사용한 설계는 변경에 취약할 수밖에 없다.</li>
</ul>
<h3 id="“어떻게”가-아니라-“무엇”을-하는지-드러낸다"><a href="#“어떻게”가-아니라-“무엇”을-하는지-드러낸다" class="headerlink" title="“어떻게”가 아니라 “무엇”을 하는지 드러낸다."></a>“어떻게”가 아니라 “무엇”을 하는지 드러낸다.</h3><p>어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름이다.<br>협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수 밖에 없다.<br>반면 무엇을 하는지 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.<br>이것은 외부의 객체가 메세지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeriodCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceCondition</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>클라이언트 관점에서 두 메서드 모두 다 할인 여부를 판단하기 위한 작업을 수행한다.<br>따라서 두 메서드 모두 클라이언트들의 의도를 담을 수 있도록 <code>isSatisfiedBy</code>로 변경하는 것이 적절하다</p>
<p>자바와 같은 정적 타이핑 언어에서는 단순히 메서드 이름이 같다고 해서 동일한 메세지를 처리할 수 있는 것은 아니다.<br>클라이언트가 동인할 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountCondition</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Screening screening)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>가장 간단한 방법은 DiscountCondition이라는 인터페이스를 정의하고 이 인터페이스에 isSatisfiedBy 오퍼레이션을 정의하는 것이다.</p>
<h3 id="의도를-드러내는-선택자-Intention-Revealing-Selector"><a href="#의도를-드러내는-선택자-Intention-Revealing-Selector" class="headerlink" title="의도를 드러내는 선택자 (Intention Revealing Selector)"></a>의도를 드러내는 선택자 (Intention Revealing Selector)</h3><p>메서드가 어떻게 수행하느냐가 아니라 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드를 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.<br>그 결과, 다양한 타입의 개규체가 참여할 수 있는 유연한 협력을 얻게 된다.</p>
<p>이처럼 어떻게 수행하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 <strong>의도를 드러내는 선택자 (Intention Revealing Selector)</strong> 라고 부른다.</p>
<blockquote>
<p>하나의 구현을 가진 메세지 이름을 일반화 하도록 도와주는 간단한 방법</p>
<p>매우 다른 두 번째 구현을 상상하라. 그러고는 메서드에 동일한 이름을 붙인다고 생각해보라<br>그렇게 하면 아마도 그 순간 가장 추상적인 이름을 메서드에 붙일 수 있을 것이다.</p>
</blockquote>
<h3 id="의도를-드러내는-인터페이스-Intention-Revealing-Interface"><a href="#의도를-드러내는-인터페이스-Intention-Revealing-Interface" class="headerlink" title="의도를 드러내는 인터페이스 (Intention Revealing Interface)"></a>의도를 드러내는 인터페이스 (Intention Revealing Interface)</h3><p>&lt;도메인 주도 설계&gt;에서 에릭에반스는 <strong>의도를 드러내는 선택자</strong>를 인터페이스 레벨로 확장한 <strong>의도를 드러내는 인터페이스</strong>를 제시했다.<br>의도를 드러내는 인터페이스란, <strong>구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것</strong>이다.  </p>
<ul>
<li><p>수행 방법에 관해서는 언급하지 말고 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여하라<br>이렇게 하면 클라이언트 개발자가 내부를 이해해야 할 필요성이 줄어들게 된다.</p>
</li>
<li><p>방법이 아닌 의도를 표현하는 추상적인 인터페이스 뒤로 모든 까다로운 메커니즘을 캡슐화해야 한다.<br>도메인의 퍼블릭 인터페이스에서는 관계와 규칙을 시행하는 방법이 아닌 이벤트와 규칙 그 자체만 명시한다.</p>
</li>
</ul>
<h1 id="원칙의-함정"><a href="#원칙의-함정" class="headerlink" title="원칙의 함정"></a>원칙의 함정</h1><h2 id="디미터-법칙은-하나의-도트-를-강제하는-규칙이-아니다"><a href="#디미터-법칙은-하나의-도트-를-강제하는-규칙이-아니다" class="headerlink" title="디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다."></a>디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.</h2><p>디미터 법칙은 “오직 하나의 도트만을 사용하라”라는 말로 요약되기도 한다.<br>그렇다면 builder패턴이나 lambda 식에서 주로 볼 수 있는 method chaining은 디미터 법칙을 위반하는 것일까?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line">         .filter(x -&gt; x &gt; <span class="number">10</span>)</span><br><span class="line">         .distinct()</span><br><span class="line">         .count();</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 <code>of</code>, <code>filter</code>, <code>distinct</code> 메서드는 모두 IntStream이라는 동일한 클래스의 인스턴스를 반환한다.  </p>
<p>따라서 이 코드는 디미터 법칙을 위반하지 않는다.<br>디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.<br>위의 코드에서는 IntStream의 내부 구조가 외부로 노출되지 않았다.<br>단지 IntStream을 다른 IntStream으로 변환할 뿐, 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.</p>
<p>따라서 하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다.<br>기차 충돌처럼 보이는 코드라도 객체 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.  </p>
<p>또한 이 메서드들은 객체의 내부에 대한 어떤 내용도 묻지 않는다.<br>그저 객체를 다른 객체로 변환하는 작업을 수행하라고 시킬 뿐이다. 따라서 묻지말고 시켜라 원칙을 위반하지 않는다.</p>
<blockquote>
<p>로버트 마틴은 &lt;클린코드&gt;에서 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료구조 인지에 따라 다르다고 한다.<br>객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는게 좋다.<br>자료 구조는 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.</p>
</blockquote>
<h1 id="명령-쿼리-분리-원칙-CQRS"><a href="#명령-쿼리-분리-원칙-CQRS" class="headerlink" title="명령-쿼리 분리 원칙 (CQRS)"></a>명령-쿼리 분리 원칙 (CQRS)</h1><p>명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.</p>
<ul>
<li>Routine: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈. 루틴은 프로시져와 함수로 나뉜다.<ul>
<li>Procedure: 정해진 절차에 따라 내부의 상태를 변경. 부수효과(side effect)를 발생시킬 수 있지만 값을 반환할 수 없다.</li>
<li>Function: 함수는 값을 반환할 수 있지만, 부수효과(side effect)를 발생시킬 수 없다.</li>
</ul>
</li>
</ul>
<p>명령(Command)와 쿼리(Query)는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.  </p>
<ul>
<li>Command &#x3D; Procedure : 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.</li>
<li>Query &#x3D; Function : 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.</li>
</ul>
<h2 id="기계로서의-객체-메타포"><a href="#기계로서의-객체-메타포" class="headerlink" title="기계로서의 객체 메타포"></a>기계로서의 객체 메타포</h2><p><img src="./metaphor_machine.jpg" alt="metaphor_machine"></p>
<p>버트란드 마이어(Bertrand Meyer)는 <Object-Oriented Software Construction>에서 명령-쿼리 분리 원칙을 설명할 때 기계 메타포를 이용한다.<br>이 관점에서 객체는 블랙박스이며 객체의 인터페이스는 객체의 관찰 가능한 상태를 보기 위한 일련의 디스플레이와 객체의 상태를 변경하기 위해 누를 수 있는 버튼의 집합이다.  </p>
<p>이런 스타일의 인터페이스를 사용함으로써 객체의 캡슐화와 다양한 문맥에서의 재사용성을 보장할 수 있다.<br>마틴 파울러는 명령-쿼리 분리 원칙에 따라 작성된 인터페이스를 <strong>명령-쿼리 인터페이스(Command-Query Interface)</strong> 라고 부른다.</p>
<ul>
<li>insert, delete, merge, search는 명령(Command) 버튼으로써 기계의 상태가 변경된다.</li>
<li>명령(Command) 버튼은 실행 결과를 제공하지 않기 때문에 명령 버튼을 누른 직후에는 기계 내부의 상태를 직접 확인할 수 없다.</li>
<li>empty, current, first, last는 쿼리(Query) 버튼으로서 기계의 상태를 확인할 수 있다.</li>
<li>명령(Command) 버튼을 누르지 않고 쿼리(Query) 버튼을 계속 누르게 되면 항상 똑같은 값이 패널에 표시될 것이다.</li>
</ul>
<h2 id="명령-쿼리-분리와-참조-투명성"><a href="#명령-쿼리-분리와-참조-투명성" class="headerlink" title="명령-쿼리 분리와 참조 투명성"></a>명령-쿼리 분리와 참조 투명성</h2><ul>
<li>명령과 쿼리를 엄격하게 분류하면 객체의 부수효과(side effect)를 제어하기 수월해진다.  </li>
<li>쿼리는 <strong>객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출하더라도 상관이 없다.</strong> (항상 같은 값을 리턴한다.) </li>
<li>명령이 개입하지 않는 한 쿼리의 값은 변경되지 않기 때문에 쿼리의 결과를 예측하기 쉬워진다.  </li>
<li>또한 쿼리의 순서를 자유롭게 변경할 수도 있다.</li>
</ul>
<p>명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 <strong>참조 투명성(referential transparency)</strong> 의 장점을 제한적이나마 누릴 수 있게 된다.<br>참조 투명성을 잘 활용하면 버그가 적고, 디버깅이 용이하고, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.</p>
<p>하지만 명령-쿼리 분리를 하지 않은 함수에서는 내부에 부수효과를 포함할 경우 동일한 인자를 전달하더라도 부수효과에 의해 그 결괏값이 매번 달라질 수 있다.</p>
<h2 id="수학으로-보는-참조-투명성"><a href="#수학으로-보는-참조-투명성" class="headerlink" title="수학으로 보는 참조 투명성"></a>수학으로 보는 참조 투명성</h2><p>참조 투명성이란 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라고 결과가 달라지지 않는 특성을 의미한다.</p>
<p>어떤 함수 f(n)이 존재 할 때 n의 값으로 1을 대입하면 그 결과가 3이라고 가정하자 (f(1) &#x3D; 3)</p>
<ul>
<li>f(1) + f(1) &#x3D; 6</li>
<li>f(1) * 2 &#x3D; 6</li>
<li>f(1)  - 1 &#x3D; 2</li>
</ul>
<p>위에서 f(1) &#x3D; 3 이라고 했기 때문에 대입하여 결과를 얻어내기 쉬웠다.<br>f(1) 자리에 3으로 바꿔보자</p>
<ul>
<li>3 + 3 &#x3D; 6</li>
<li>3 * 2 &#x3D; 6</li>
<li>3  - 1 &#x3D; 2</li>
</ul>
<p>이것이 바로 참조 투명성이다.<br>수학에서의 함수는 항상 동일한 입력에 대해 동일한 값을 반환하기 때문에 수학의 함수는 참조 투명성을 만족 시키는 이상적인 예이다.  </p>
<p>따라서 참조 투명성은 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산할 수 있게 해준다.<br>여기서 f(1)의 값을 항상 3이라고 말할 수 있는 이유는 f(1)의 값이 변하지 않기 때문이다.<br>이처럼 어떤 값이 변하지 않는 성질을 불변성(immutability)이라고 부른다.<br>어떤 값이 불변한다는 말은 부수효과(side effect)가 발생하지 않았다는 말과 동일하다.</p>
<p>참조 투명성을 만족하는 식은 두 가지 장점을 제공한다.</p>
<ul>
<li>모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.</li>
<li>모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.</li>
</ul>
<p>객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다.<br>하지만 명령-쿼리 분리 원칙을 사용하면 조금이나마 예외를 줄일 수 있다.<br>명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있다.</p>
<h2 id="명령형-프로그래밍과-함수형-프로그래밍"><a href="#명령형-프로그래밍과-함수형-프로그래밍" class="headerlink" title="명령형 프로그래밍과 함수형 프로그래밍"></a>명령형 프로그래밍과 함수형 프로그래밍</h2><ul>
<li>명령형 프로그래밍 : 부수효과를 기반으로 하는 프로그래밍 방식<ul>
<li>상태를 변경시키는 연산들을 적절한 순서대로 나열하여 프로그램을 작성한다.</li>
<li>대부분의 객체지향 프로그래밍 언어는 메세지에 의한 객체의 상태 변경에 집중하기 때문에 명령형 프로그래밍 언어로 본다.</li>
</ul>
</li>
<li>함수형 프로그래밍 : 부수효과가 존재하지 않는 수학적인 함수에 기반한다.<ul>
<li>참조 투명성의 장점을 극대화할 수 있다.</li>
<li>명령형 프로그래밍에 비해 프로그램의 실행 결과를 이해하고 예측하기가 쉽다.</li>
</ul>
</li>
</ul>
<h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul>
<li>디미터 법칙: 협력이라는 컨텍스트 안에서 객체보다 메세지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다.<br>수신할 객체를 알지 못한 상태에서 메세지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다.<br>따라서 메세지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.</li>
<li>묻지 말고 시켜라: 메세지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.<br>클라이언트의 관점에서 메세지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메세지를 전송하면 된다. </li>
<li>의도를 드러내는 인터페이스: 메세지를 먼저 선택한다는 것은 메세지를 전송하는 클라이엍느의 관점에서 메세지의 이름을 정한다는 것이다.<br>당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날 수 밖에 없다.</li>
<li>명령-쿼리 분리 원칙: 메세지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다.<br>객체가 단순히 어떤 일을 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다. 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter6. 메세지와 인터페이스</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2020/05/17/object-chapter5/">Objects Study - Chapter5. 책임 할당하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-17</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="책임-주도-설계를-향해"><a href="#책임-주도-설계를-향해" class="headerlink" title="책임 주도 설계를 향해"></a>책임 주도 설계를 향해</h1><p>책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 <strong>어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것</strong>이다.<br>책임 할당 과정은 일종의 트레이드오프 활동이다.<br>동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다.<br>따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 한다.<br>chapter 5에서는 GRASP 패턴을 이용하여 책임 할당의 어려움을 해결하는 방법을 제시하였다.</p>
<h1 id="데이터-중심-설계-gt-책임-주도-설계"><a href="#데이터-중심-설계-gt-책임-주도-설계" class="headerlink" title="데이터 중심 설계 -&gt; 책임 주도 설계"></a>데이터 중심 설계 -&gt; 책임 주도 설계</h1><p>데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 다음의 두 가지 원칙을 따라야 한다.</p>
<ul>
<li>데이터보다 행동을 먼저 결정하라</li>
<li>협력이라는 문맥 안에서 책임을 결정하라</li>
</ul>
<h1 id="데이터보다-행동을-먼저-결정하라"><a href="#데이터보다-행동을-먼저-결정하라" class="headerlink" title="데이터보다 행동을 먼저 결정하라"></a>데이터보다 행동을 먼저 결정하라</h1><p>객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동이다.<br>클라이언트의 관점에서 객체가 수행하는 행동이란 곧 객체의 책임을 의미한다.<br>객체는 협력에 참여하기 위해 존재하며 협력안에서 수행하는 책임이 객체의 존재가치를 증명한다.</p>
<p>따라서 <strong>이 객체가 수행해야 하는 일은 무엇인가?</strong> -&gt; <strong>이 객체가 이 일을 수행하기 위해 필요한 데이터는 무엇인가?</strong>  의 순서로 접근해야 한다.</p>
<h1 id="협력이라는-문맥-안에서-책임을-결정하라"><a href="#협력이라는-문맥-안에서-책임을-결정하라" class="headerlink" title="협력이라는 문맥 안에서 책임을 결정하라"></a>협력이라는 문맥 안에서 책임을 결정하라</h1><p>객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다.  </p>
<ul>
<li>객체에 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 책임이다.</li>
<li>책임이 조금 어색해도 협력에 적합하다면 그 책임은 좋은 것이다.</li>
<li>책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.</li>
<li>협력에 적합한 책임이란 메세지 수신자가 아닌 메세지 전송자에게 적합한 책임이다.<ul>
<li>메세지를 실제로 요청하는 입장에서 메서드를 작성한다.</li>
</ul>
</li>
<li>협력에 적합한 책임을 수확하기 위해서는 메세지를 결정한 후에 객체를 선택해야 한다.<ul>
<li>~한 일을 해야 하는데 ~객체를 사용해야 한다.</li>
<li>메세지를 전송해야하는데 누구한테 전송하지?</li>
</ul>
</li>
<li>클라이언트는 단지 임의의 객체가 메세지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메세지를 전송할 뿐이다<ul>
<li>실제 메세지를 수신하는 객체가 메세지를 처리할 <code>책임</code>을 할당 받게 된다.</li>
</ul>
</li>
</ul>
<h1 id="책임-주도-설계의-흐름"><a href="#책임-주도-설계의-흐름" class="headerlink" title="책임 주도 설계의 흐름"></a>책임 주도 설계의 흐름</h1><ol>
<li>시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.</li>
<li>시스템 책임을 더 작은 책임으로 분할한다.</li>
<li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.</li>
<li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다</li>
<li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.</li>
</ol>
<p>책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것이다.<br>협력에 참여하는 객체들의 책임이 어느정도 정리될 때 까지는 객체의 내부 상태에 대해 관심을 가지지 않는 것이다.</p>
<h1 id="GRASP-패턴"><a href="#GRASP-패턴" class="headerlink" title="GRASP 패턴"></a>GRASP 패턴</h1><p>GRASP (General Responsibility Assignment Software Pattern)의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.</p>
<h2 id="도메인-개념에서-출발하기"><a href="#도메인-개념에서-출발하기" class="headerlink" title="도메인 개념에서 출발하기"></a>도메인 개념에서 출발하기</h2><p>설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다<br>따라서 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.</p>
<p><img src="./domain.jpeg" alt="domain"></p>
<p>설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요는 없다.<br>중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아니다.<br>도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현으로 넘어가는 것이 좋다.</p>
<h2 id="정보-전문가에게-책임을-할당하라"><a href="#정보-전문가에게-책임을-할당하라" class="headerlink" title="정보 전문가에게 책임을 할당하라"></a>정보 전문가에게 책임을 할당하라</h2><p>책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다.<br>책임의 관점에서 질문을 해본다.</p>
<ol>
<li>메세지를 전송할 객체는 무엇을 원하는가?</li>
<li>메세지를 수신할 적합한 객체는 누구인가?</li>
</ol>
<p>이 질문에 답하기 위해서는 객체가 <strong>상태와 행동을 통합한 캡슐화의 단위</strong>라는 사실에 집중해야 한다.<br>객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 한다.<br>따라서 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.<br>이를 <strong>INFORMATION EXPERT(정보 전문가) 패턴</strong>이라고 부른다.</p>
<blockquote>
<p>INFORMATION EXPERT(정보 전문가) 패턴<br>책임을 정보 전문가. 즉 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라<br>INFORMATION EXPERT(정보 전문가) 패턴은 객체가 자율적인 존재여야 한다는 사실을 한번 더 상기시킨다.<br>정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있기 때문이다.  </p>
<p>INFORMATION EXPERT(정보 전문가) 패턴을 따르면 정보와 행동을 최대한 가까운 곳(&#x3D;같은 클래스 내)에 위치 시키기 때문에 캡슐화를 유지할 수 있다.<br>필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력 있고, 이해하기 쉬워진다.<br>따라서 높은 응집도, 낮은 결합도를 가진 시스템을 구축할 수 있다.  </p>
</blockquote>
<p><strong>책임을 수행하는 객체가 정보를 <code>알고</code> 있다고 해서 반드시 그 정보를 저장하는 변수를 만들 필요는 없다.</strong><br>다른 객체의 도움을 받아 전달받을 수도 있기 때문이다.</p>
<h1 id="LOW-COPLING-낮은-결합도-패턴"><a href="#LOW-COPLING-낮은-결합도-패턴" class="headerlink" title="LOW COPLING(낮은 결합도) 패턴"></a>LOW COPLING(낮은 결합도) 패턴</h1><p>어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?<br>설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.</p>
<p>낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다. 다시 말해 설계 결정을 평가할 때 적용할 수 있는 평가원리다.<br>현재의 책임 할당을 검토하거나 여러 설계 대안들이 있을 때 낮은 결합도를 유지할 수 있는 설계를 선택해야한다.</p>
<h1 id="HIGH-COHESION-높은-응집도-패턴"><a href="#HIGH-COHESION-높은-응집도-패턴" class="headerlink" title="HIGH COHESION(높은 응집도) 패턴"></a>HIGH COHESION(높은 응집도) 패턴</h1><p>어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가? 높은 응집도를 유지할 수 있게 책임을 할당하라 </p>
<p>낮은 결합도처럼 높은 응집도 역시 모든 설계 결정에서 염두에 둬야 할 원리다.<br>다시 말해 설계 결정을 평가할 때 적용할 수 있는 평가 원리다.<br>현재의 책임 할당을 검토하고 있거나 여러 설계 대안 중 하나를 선택해야 한다면 높은 응집도를 유지할 수 있는 설계를 선택해야 한다.</p>
<h2 id="클래스-응집도-판단하기"><a href="#클래스-응집도-판단하기" class="headerlink" title="클래스 응집도 판단하기"></a>클래스 응집도 판단하기</h2><ul>
<li>클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라<ul>
<li>다양한 기능이 짬뽕된 클래스이다</li>
</ul>
</li>
<li>클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다.<br>초기화되는 속성의 그룹을 기준으로 클래스를 분리하라<ul>
<li>인스턴스 생성 시, 모든 변수가 다 초기화 되어야 한다.</li>
<li>어떤 변수는 초기화 되고 어떤 변수는 초기화가 되지않으면 초기화가 되는 변수들 끼리 묶어서 클래스를 분리한다</li>
</ul>
</li>
<li>메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다.<br>이들 그룹을 기준으로 클래스를 분리하라<ul>
<li>메서드 내에서 클래스내의 변수를 사용해야 한다. </li>
<li>메서드 2개에서 사용하는 변수들이 틀리다면 변수들을 기준으로 클래스를 분리 해야한다.</li>
</ul>
</li>
<li>메서드가 너무 긴 경우 private 메서드로 잘게 쪼개면 숨겨진 문제점이 드러나는 경우가 많다</li>
</ul>
<h1 id="CREATOR-패턴"><a href="#CREATOR-패턴" class="headerlink" title="CREATOR 패턴"></a>CREATOR 패턴</h1><p>객체 A를 생성해야 할 떄 어떤 객체에게 객체 생성 책임을 할당해야 하는가? 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라. </p>
<ul>
<li>B가 A 객체를 포함하거나 참조한다.</li>
<li>B가 A 객체를 기록한다</li>
<li>B가 A 객체를 긴밀하게 사용한다</li>
<li>B가 A 객체를 초기화 하는데 필요한 데이터를 가지고 있다 (이 경우 B는 A에 대한 정보 전문가다)</li>
</ul>
<p>CREATOR 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.<br>생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다.<br>다시 말해 두 객체는 서로 결합된다.</p>
<p>이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.<br>결과적으로 CREATOR 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 해준다.</p>
<h1 id="POLYMORPHISM-패턴"><a href="#POLYMORPHISM-패턴" class="headerlink" title="POLYMORPHISM 패턴"></a>POLYMORPHISM 패턴</h1><p>객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 하는가?<br>타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라</p>
<p>조건에 따른 변화는 프로그램의 기본 논리다. <strong>프로그램을 if-else 또는 switch case 등의 조건 논리를 사용해서 설계</strong>한다면<br>새로운 변화가 일어난 경우 조건 논리를 수정해야 한다.<br><strong>이것은 프로그램을 수정하기 어렵고 변경에 취약하게 만든다.</strong></p>
<p>POLYMORPHISM 패턴은 객체의 타입을 검사해서 타입에 따라 여러 대안들을 수행하는 조건적인 논리를 사용하지 말라고 경고 한다.<br>대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고한다.</p>
<h1 id="PROTECTED-VARIATIONS-패턴"><a href="#PROTECTED-VARIATIONS-패턴" class="headerlink" title="PROTECTED VARIATIONS 패턴"></a>PROTECTED VARIATIONS 패턴</h1><p>객체, 서브시스템 그리고 시스템을 어떻게 설계해야 변화와 불안정성이 다른 요소에 나쁜 영향을 미치지 않도록 방지할 수 있을까?<br>변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라</p>
<p>PROTECTED VARIATIONS 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것이다. <strong>“설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라”</strong> 라는 객체지향의 오랜격언은 PROTECTED VARIATIONS 패턴의 본질을 잘 설명해준다.</p>
<p>우리가 캡슐화해야 하는 것은 변경이다. </p>
<p><strong>변경될 가능성이 높은가? 그렇다면 캡슐화를 해야한다.</strong></p>
<h1 id="리팩터링"><a href="#리팩터링" class="headerlink" title="리팩터링"></a>리팩터링</h1><p>책임 주도 설계에 익숙해지기 위해서는 부단한 노력과 시간이 필요하다.<br>한번에 하기 힘들기에 일단은 <strong>절차지향적 방식</strong>으로 프로그램을 구성한 다음에 리팩터링을 통해 <strong>책임 주도 설계로 전환</strong>하는 방법을 사용해보자</p>
<h2 id="긴-메서드의-단점"><a href="#긴-메서드의-단점" class="headerlink" title="긴 메서드의 단점"></a>긴 메서드의 단점</h2><ul>
<li>어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 이해하는데 많은 시간이 걸린다.</li>
<li>하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.</li>
<li>메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다</li>
<li>로직의 일부만 재사용하는 것이 불가능하다</li>
<li>코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.</li>
</ul>
<h2 id="이해하기-쉬운-메서드"><a href="#이해하기-쉬운-메서드" class="headerlink" title="이해하기 쉬운 메서드"></a>이해하기 쉬운 메서드</h2><ul>
<li>메서드가 잘게 나눠진 메서드 (재사용성이 높아진다.)</li>
<li>고수준의 메서드를 볼때 간략한 코드만으로 어떤 기능을 수행하는지 알 수 있다.</li>
<li>메서드 이름만으로도 무슨 기능을 수행하는지 파악할 수 있다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - chapter5. 책임 할당하기</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2020/05/16/object-chapter4/">Objects Study - Chapter4. 설계 품질과 트레이드오프</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-16</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="데이터-중심의-설계"><a href="#데이터-중심의-설계" class="headerlink" title="데이터 중심의 설계"></a>데이터 중심의 설계</h1><p>객체지향 설계에는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.  </p>
<ul>
<li>데이터를 분할의 중심축으로 삼는 방법 (Entity를 먼저 정의하고 비지니스 로직 구현)<ul>
<li>데이터 중심의 관점에서는 객체는 <strong>자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의</strong></li>
<li>객체는 독립된 데이터 덩어리처럼 바라본다</li>
</ul>
</li>
<li>책임을 분할의 중심축으로 삼는 방법 (Interface 기반의 비지니스 로직을 구현하고 필요한 속성을 정의)<ul>
<li>객체는 다른 객체가 요청할 수 있는 <strong>오퍼레이션을 위해 필요한 데이터만 생성</strong>하는 정도</li>
<li>객체랑 협력하는 공동체의 일환으로 바라본다</li>
</ul>
</li>
</ul>
<h1 id="데이터-중심-설계가-안-좋은-이유"><a href="#데이터-중심-설계가-안-좋은-이유" class="headerlink" title="데이터 중심 설계가 안 좋은 이유"></a>데이터 중심 설계가 안 좋은 이유</h1><p>객체지향 설계는 데이터가 아닌 책임에 초점을 맞춰야한다.  </p>
<ul>
<li><p>객체의 상태는 구현에 속한다</p>
</li>
<li><p>구현은 불안정하기 때문에 변화하기 쉽다</p>
</li>
<li><p>상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들어 캡슐화가 무너진다. </p>
</li>
<li><p>상태 변경 -&gt; 인터페이스의 변경 -&gt; 의존성을 갖는 객체에게 변경 영향이 퍼짐</p>
</li>
<li><p>데이터에 초점을 맞추는 설계는 변경에 취약하다</p>
</li>
<li><p>객체의 내부 구현을 인터페이스의 일부로 만든다. <strong>(캡슐화 위반)</strong></p>
<ul>
<li>getter&#x2F;setter와 같은 메서드가 퍼블릭으로 생성되어 어디서든 접근이 가능하다</li>
</ul>
</li>
</ul>
<h1 id="데이터-중심-설계의-문제점"><a href="#데이터-중심-설계의-문제점" class="headerlink" title="데이터 중심 설계의 문제점"></a>데이터 중심 설계의 문제점</h1><p>데이터 중심 설계가 변경에 취약한 이유는 두 가지이다.</p>
<ul>
<li>데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 한다.<ul>
<li>데이터 중심으로 클래스를 구성하다 보면 책임에 대해 무감각해져 캡슐화를 위반하기 쉽다.</li>
<li>데이터 중심 관점에서는 객체란 그냥 데이터 덩어리이기 때문에 별도로 분리된 객체에서 로직을 구현하게 된다.<ul>
<li>이는 getter&#x2F;setter의 남용을 불러온다.</li>
<li>이로 인해 캡슐화가 무너진다.</li>
</ul>
</li>
<li>데이터를 먼저 잡고 오퍼레이션을 잡기 때문에 데이터에 대한 정보가 인터페이스로 외부에 표현된다.</li>
<li>따라서 객체 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 준다. (변경에 취약)</li>
</ul>
</li>
<li>데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.<ul>
<li>올바른 객체지향 설계의 무게중심은 항상 객체 내부가 아니라 외부에 포커스가 가야한다.</li>
<li>내부에서 어떤 상태를 가지고 뭘하는지는 부가적인 문제이다.</li>
<li>항상 다른 객체와 어떻게 협력하는지 부터 생각해야 한다.</li>
<li>데이터 중심 설계에서는 이미 구현(&#x3D;데이터)가 결정된 상태에서 다른 객체와의 협력을 고려하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워 맞출 수 밖에 없다.</li>
<li>따라서 내부가 변경되면 협력하는 객체 모두가 영향을 받게 된다.</li>
</ul>
</li>
</ul>
<h1 id="데이터-중심-설계에서-빠지는-착각"><a href="#데이터-중심-설계에서-빠지는-착각" class="headerlink" title="데이터 중심 설계에서 빠지는 착각"></a>데이터 중심 설계에서 빠지는 착각</h1><p>데이터 중심으로 객체를 설계하다보면 객체가 필요한 데이터에 집중하게 된다.<br>이는 예전 DB 기반의 설계를 하던 것과 유사하다</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> Duration runningTime;</span><br><span class="line">  <span class="keyword">private</span> Money fee;</span><br><span class="line">  <span class="keyword">private</span> List&lt;DiscountCondition&gt; discountConditions;</span><br><span class="line">  <span class="keyword">private</span> MovieType movieType;</span><br><span class="line">  <span class="keyword">private</span> Money discountAmount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> discountPercent;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.title;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Duration <span class="title function_">getRunningTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.runningTime;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Money <span class="title function_">getFee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.fee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunningTime</span><span class="params">(Duration runningTime)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.runningTime = runningTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFee</span><span class="params">(Money fee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fee = fee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>객체지향의 가장 중요한 원칙은 캡슐화가 맞다.<br>내부 데이터가 객체를 빠져나가 외부의 다른 객체들을 오염시키는 것을 막아야 한다.<br>이를 위한 가장 간단한 방법은 위의 코드와 같이 접근자(getter) &#x2F; 수정자(setter)를 추가하는 것이다.  </p>
<p>위와 같은 코드는 직접 객체의 내부에 접근할 수 없기 때문에 캡슐화의 원칙을 지키고 있는 것 처럼 보인다.<br>하지만 위의 예시는 객체 내부 상태에 대한 어떤 정보도 캡슐화하지 못한다.<br>getter&#x2F;setter는 <strong>객체 내부에 Title, RunningTime, Fee라는 인스턴스 변수가 존재한다는 사실을  public 인터페이스에 노골적으로 드러낸다.</strong></p>
<p>캡슐화를 한다고 코드를 위와같이 짰지만 캡슐화를 위반하는 코드가 되는 셈이다.</p>
<h1 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h1><p>객체지향에서 가장 중요한 원리는 캡슐화다.  </p>
<ul>
<li><p>외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다 </p>
</li>
<li><p>불안정한 구현의 세부 사항을 안정적인 인터페이스 뒤로 숨기는 것이다.</p>
</li>
<li><p>캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.</p>
</li>
<li><p>즉, 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.</p>
</li>
</ul>
<h2 id="구현과-인터페이스"><a href="#구현과-인터페이스" class="headerlink" title="구현과 인터페이스"></a>구현과 인터페이스</h2><ul>
<li>구현이란 변경될 가능성이 높은 부분을 의미한다<ul>
<li>변경될 가능성이 높은 부분은 객체 내부로 숨겨야 한다.</li>
<li>한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 조절하기 위해서다</li>
</ul>
</li>
<li>인터페이스란 상대적으로 안정적인 부분이다.</li>
</ul>
<h1 id="응집도와-결합도"><a href="#응집도와-결합도" class="headerlink" title="응집도와 결합도"></a>응집도와 결합도</h1><p>객체 지향에서의 좋은 설계란, 높은 응집도와 낮은 결합도로 가진 모듈로 구성된 설계를 의미한다.</p>
<ul>
<li>응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.<ul>
<li>모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면, 그 모듈은 높은 응집도를 가진다.</li>
<li>모듈 내의 요소들이 서로 다른 목적을 추구 한다면 그 모듈은 낮은 응집도를 가진다.</li>
<li>객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 높은 책임들을 할당했는지 나타낸다.</li>
<li>쉽게 말하면 객체 하나가 이 일 저 일 다하면 응집도가 낮은것이다.</li>
</ul>
</li>
<li>결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많이 알고 있는지를 나타낸다.<ul>
<li>A 모듈이 B 모듈에 대해 너무 자세한 구현부까지 알고 있다면 두 모듈은 높은 결합도를 가진다.</li>
<li>A 모듈이 B 모듈에 대해 간단한 인터페이스정도만 알고 있다면 두 모듈은 낮은 결합도를 가진다.</li>
<li>결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있다.</li>
</ul>
</li>
</ul>
<h2 id="높은-응집도와-낮은-결합도를-추구-해야하는-이유"><a href="#높은-응집도와-낮은-결합도를-추구-해야하는-이유" class="headerlink" title="높은 응집도와 낮은 결합도를 추구 해야하는 이유"></a>높은 응집도와 낮은 결합도를 추구 해야하는 이유</h2><p><strong>변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.</strong>  </p>
<ul>
<li>하나의 변경에 의해 여러개의 모듈이 변경되면 <strong>응집도가 낮다</strong>, <strong>결합도가 높다</strong></li>
<li>하나의 변경에 의해 하나의 모듈이 변경되면 <strong>응집도가 높다</strong>, <strong>결합도가 낮다</strong></li>
</ul>
<p>클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.</p>
<h2 id="결합도가-높아도-상관-없는-경우도-있다"><a href="#결합도가-높아도-상관-없는-경우도-있다" class="headerlink" title="결합도가 높아도 상관 없는 경우도 있다"></a>결합도가 높아도 상관 없는 경우도 있다</h2><p>일반적으로 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 아무런 문제가 되지 않는다.<br>표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임 워크에 의존하는 경우가 여기에 속한다.<br>ex) String, ArrayList와 같은 클래스는 변경될 확률이 매우 낮기 때문에 결합도에 대해 고민할 필요가 없다   </p>
<p>하지만 직접 작성한 코드는 항상 불안정하며 언제라도 변경될 가능성이 높기 때문에 주의해야 한다.<br><strong>이런 높은 응집도와 낮은 응집도를 실현하기 위해서는 캡슐화를 향상 시키면 된다.</strong></p>
<h1 id="캡슐화를-항상-생각하자"><a href="#캡슐화를-항상-생각하자" class="headerlink" title="캡슐화를 항상 생각하자"></a>캡슐화를 항상 생각하자</h1><ul>
<li>캡슐화는 설계의 제 1원칙이다.  </li>
<li>데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제로 몸살을 앓게 된 근본적인 원인은 바로 캡슐화를 위반했기 때문이다.  </li>
<li>객체는 자신이 어떤 데이터를 가지고 있는지를 내부에서만 알아야 하고 외부에 공개하면 안된다.  (getter&#x2F;setter를 만들지 마라)</li>
</ul>
<h2 id="Rectangle-클래스로-보는-캡슐화의-중요성"><a href="#Rectangle-클래스로-보는-캡슐화의-중요성" class="headerlink" title="Rectangle 클래스로 보는 캡슐화의 중요성"></a>Rectangle 클래스로 보는 캡슐화의 중요성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> left;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> top;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> right;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> bottom;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.top = top;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">    <span class="built_in">this</span>.bottom = bottom;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeft</span><span class="params">()</span> &#123; <span class="keyword">return</span> left; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(<span class="type">int</span> left)</span> &#123; <span class="built_in">this</span>.left = left &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRight</span><span class="params">()</span> &#123; <span class="keyword">return</span> right; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(<span class="type">int</span> right)</span> &#123; <span class="built_in">this</span>.right = right &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTop</span><span class="params">()</span> &#123; <span class="keyword">return</span> top; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTop</span><span class="params">(<span class="type">int</span> top)</span> &#123; <span class="built_in">this</span>.top = top &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBottom</span><span class="params">()</span> &#123; <span class="keyword">return</span> bottom; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBottom</span><span class="params">(<span class="type">int</span> bottom)</span> &#123; <span class="built_in">this</span>.bottom = bottom &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnyClass</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">anyMethod</span><span class="params">(Rectangle rectangle, <span class="type">int</span> multiple)</span> &#123;</span><br><span class="line">    rectangle.setRight(rectangle.getRight() * multiple)</span><br><span class="line">    rectangle.setBottom(rectangle.getBottom() * multiple)</span><br><span class="line">    rectangle.setLeft(rectangle.getLeft() * multiple)</span><br><span class="line">    rectangle.setTop(rectangle.getTop() * multiple)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같은 코드는 많은 문제점이 있다. </p>
<ul>
<li><code>코드중복</code>이 발생할 확률이 높다.<ul>
<li>다른 곳에서도 사각형의 너비와 높이를 증가시키는 코드가 필요하면 또 이 코드를 작성해야 한다.</li>
<li>악의 근원인 setter를 남발하고 있다.</li>
</ul>
</li>
<li>변경에 취약하다<ul>
<li>Rectangle이 right와 bottom 대신 length와 height를 이용해서 사각형을 표현하게 되면 여러 부분에 코드를 수정해야 한다.</li>
<li>이런 변경은 기존 getter&#x2F;setter를 사용하던 코드 전반적으로 영향을 미치게 된다</li>
</ul>
</li>
</ul>
<p>해결 방법은 캡슐화를 강화시키는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enlarge</span><span class="params">(<span class="type">int</span> multiple)</span> &#123;</span><br><span class="line">    right *= multiple;</span><br><span class="line">    bottom *= multiple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자신의 크기를 코드 외부에서 증가시키는 것이 아닌 Rectangle 클래스 내부에서 스스로 할 수 있도록 <strong>책임을 이동하였다.</strong></p>
<h1 id="캡슐화의-진정한-의미"><a href="#캡슐화의-진정한-의미" class="headerlink" title="캡슐화의 진정한 의미"></a>캡슐화의 진정한 의미</h1><p>캡슐화는 단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미를 가진다.<br>사실 상 변경될 수 있는 어떤 것이라도 감추는 것이 진정한 캡슐화이다.<br>내부 속성을 외부로 부터 감추는 것은 <strong>데이터 캡슐화</strong>라고 불리는 캡슐화의 한 종류일 뿐이다.<br><strong>만약 클래스 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는 다면 그것은 캡슐화를 위반한 것이다.</strong><br>정리하자면 캡슐화란 무엇이든 변하는 것은 감추는 것이다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>​    Objects(코드로 이해하는 객체지향 설계) - Chapter4. 설계 품질과 트레이드오프</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2020/05/10/object-chapter3/">Objects Study - Chapter3. 역할, 책임, 협력</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="역할-책임-협력"><a href="#역할-책임-협력" class="headerlink" title="역할, 책임, 협력"></a>역할, 책임, 협력</h1><p>객체지향 패러다임의 관점에서의 핵심은 역할(role), 책임(responsibility), 협력(collaboration)이다.<br>애플리케이션의 기능을 구현하기 위해 <strong>어떤 협력이 필요하고</strong> 협력을 위해 <strong>어떤 역할과 책임이 필요한지</strong> 고민하지 않은 채 너무 이른 시기에 구현에만 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.</p>
<ul>
<li>협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용 </li>
<li>역할: 객체들이 협력안에서 수행하는 책임들을 일컫는 말 (&#x3D; 인터페이스라 의역하면 이해가 쉽다)</li>
<li>책임: 객체가 협력에 참여하기 위해 수행하는 로직 (&#x3D; 인터페이스 구현체 또는 객체)</li>
</ul>
<h1 id="협력"><a href="#협력" class="headerlink" title="협력"></a>협력</h1><p>협력은 객체지향 세계에서 기능을 구현할 수 있는 유일한 방법이다.<br>하나의 객체가 모든 일을 처리하는 것이 아닌 각각의 역할을 수행할 수 있는 객체들간의 <strong>메세지 전송</strong>이라는 커뮤니케이션 수단을 이용하여 객체 간 협력을 통해 애플리케이션 기능을 수행할 수 있다.</p>
<blockquote>
<p><strong>협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다.</strong><br>한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다.<br>즉, 두 객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다.<br>객체 사이의 협력을 설계할 때는 <strong>객체를 서로 분리된  인스턴스가 아닌 협력하는 파트너로 인식해야한다.</strong></p>
</blockquote>
<p>자율적인 객체는 자신에게 할당된 책임을 수행하던 중 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메세지를 전송해서 협력을 요청한다.  </p>
<p>객체들 사이의 협력을 구성하는 일련의 요청과 응답을 통해 애플리케이션의 기능이 구현된다.</p>
<h1 id="협력이-설계를-위한-문맥을-결정한다"><a href="#협력이-설계를-위한-문맥을-결정한다" class="headerlink" title="협력이 설계를 위한 문맥을 결정한다."></a>협력이 설계를 위한 문맥을 결정한다.</h1><ul>
<li>애플리케이션 안에서 객체가 필요하다면 그 이유는 단 하나여야 한다. (그 객체가 어떠한 협력에 참여하고 있기 때문)</li>
<li>객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 가지고 있기 때문이다.</li>
<li>객체는 행동(action)과 상태(state)로 구성된다.<ul>
<li>행동(action)은 협력 안에서 객체가 처리할 메세지 </li>
<li>상태(state)는 객체가 행동하는데 필요한 정보</li>
</ul>
</li>
<li>협력은 객체를 설계하는데 필요한 일종의 context를 제공한다.</li>
</ul>
<h1 id="책임"><a href="#책임" class="headerlink" title="책임"></a>책임</h1><p>책임이란, 협력에 참여하기 위해 객체 수행하는 행동(action)이라 부른다.<br>책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.<br>즉, 객체의 책임은 <strong>‘무엇을 알고 있는가’</strong>, <strong>‘무엇을 할 수 있는가’</strong> 로 구성된다.  </p>
<p><strong>하는 것</strong></p>
<ul>
<li>객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것</li>
<li>다른 객체의 행동을 시작시키는 것 (메세지를 전송하는 것)</li>
<li>다른 객체의 활동을 제어하고 조절하는 것</li>
</ul>
<p><strong>아는 것</strong></p>
<ul>
<li>사적인 정보에 관해 아는 것</li>
<li>관련된 객체에 관해 아는 것 (의존성)</li>
<li>자신이 유도하거나 계산할 수 있는 것에 대해 아는 것</li>
</ul>
<p>책임은 객체지향 설계의 핵심이다.<br><strong>객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것</strong><br>사실 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문이다.</p>
<h1 id="책임-주도-설계"><a href="#책임-주도-설계" class="headerlink" title="책임 주도 설계"></a>책임 주도 설계</h1><p>협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다.<br>어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정하기 때문이다.<br>이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을<br><strong>책임 주도 설계(Responsibility-Driven Design, RDD)</strong> 라고 부른다</p>
<h2 id="책임-주도-설계-방법"><a href="#책임-주도-설계-방법" class="headerlink" title="책임 주도 설계 방법"></a>책임 주도 설계 방법</h2><ol>
<li>시스템이 사용자에게 제공해야 하는 기능인 시스템의 책임을 판단한다. <ul>
<li>sms 전송요청 받은 요청을 sms로 보낼 수 있다.</li>
</ul>
</li>
<li>시스템 책임을 더 작은 책임으로 분할한다.<ul>
<li>sms 요청을 가공한다.</li>
<li>가공된 sms 요청을 벤더사로 전송한다.</li>
</ul>
</li>
<li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.<ul>
<li>sms 요청을 가공한다. -&gt; MessageTransformer</li>
<li>가공된 sms 요청을 벤더사로 전송한다. -&gt; MessageVenderSender</li>
</ul>
</li>
<li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.<ul>
<li>sms 요청을 Template 기반으로 변경한다. -&gt; TemplateMessageTransformer</li>
<li>발신번호가 예전 번호인 경우 신규 발신번호로 변경한다. -&gt; LegacySendNumberExchanger</li>
</ul>
</li>
<li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.</li>
</ol>
<p>예시</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSendRequest</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> sendNo: String,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> recipientNo: String,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> templateId: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MessageTransformer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span>: VendorMessageSendRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateMessageTransformer</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> templateLoader: TemplateLoader</span><br><span class="line">): MessageTransformer() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span>: VendorMessageSendRequest &#123;</span><br><span class="line">    <span class="keyword">val</span> template = templateLoader.findByTemplateId(templateId)</span><br><span class="line">    <span class="keyword">return</span> VendorMessageSendRequest(</span><br><span class="line">      sendNo = smsSendRequest.sendNo,</span><br><span class="line">      recipientNo = smsSendRequest.reciepientNo,</span><br><span class="line">      title = template.title,</span><br><span class="line">      contents = template.contents</span><br><span class="line">    )  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSendProcessor</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> messageTransformer: MessageTransformer</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> legacySendNumberExchanger: LegacySendNumberExchanger</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> messageVenderSender: MessageVenderSender</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">sendSms</span><span class="params">(smsSendRequest: <span class="type">SmsSendRequest</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    legacySendNumberExchanger.exchange(smsSendRequest)</span><br><span class="line">    <span class="keyword">val</span> vendorMessageSendRequest = messageTransformer.transform(smsSendRequest)</span><br><span class="line">    </span><br><span class="line">    messageVenderSender.sendTo(vendorMessageSendRequest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="메세지가-객체를-결정한다"><a href="#메세지가-객체를-결정한다" class="headerlink" title="메세지가 객체를 결정한다."></a>메세지가 객체를 결정한다.</h2><p>객체에게 책임을 할당하는 데 필요한 메세지를 먼저 식별하고 메세지를 처리할 객체를 나중에 선택하는 것이 중요하다</p>
<p>이유는 2가지가 있다.</p>
<ol>
<li>객체가 최소한의 인터페이스를 가질 수 있게 된다.<ul>
<li>필요한 메세지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않게 된다.</li>
<li>객체는 꼭 필요한 퍼블릭 인터페이스만 가질 수 있다.</li>
</ul>
</li>
<li>객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.<ul>
<li>객체의 인터페이스는 무엇을 하는지?는 표시해야하지만 어떻게 하는지는 노출하면 안된다.</li>
<li>메세지는 외부의 객체가 요청하는 무언가를 의미하기 때문에<br>메세지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.</li>
</ul>
</li>
</ol>
<h2 id="행동이-상태를-결정한다"><a href="#행동이-상태를-결정한다" class="headerlink" title="행동이 상태를 결정한다."></a>행동이 상태를 결정한다.</h2><p>객체가 존재하는 이유는 협력에 참여하기 위해서다.<br>따라서 객체는 협력에 필요한 행동을 제공해야 한다.<br>그렇기 때문에 객체는 상태보다는 행동에 초점을 맞춰야 한다.</p>
<p>적절한 객체를 만들었는지에 대한 기준은 얼마나 적절한 책임을 할당했느냐에 달려 있고, 책임이 얼마나 적절한지는 협력에 얼마나 적절한가에 달려있다.</p>
<p>객체지향 패러다임에서 <strong>가장 쉽게 하는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.</strong><br>객체의 행동을 고려하지 않고 일단 필드부터 정의하고 보는 행동이다.<br>이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.</p>
<p>상태란, 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료에 지나지 않는다.</p>
<h1 id="역할"><a href="#역할" class="headerlink" title="역할"></a>역할</h1><p>객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 된다.<br>객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다.<br>이처럼 <strong>객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합</strong>을 <strong>역할</strong>이라고 부른다.</p>
<p>역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다. (like 인터페이스)<br>인터페이스와 같이 협력 안에서 객체를 바꿔낄 수 있는 슬롯의 역할을 한다.</p>
<p>따라서 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음이다.</p>
<h2 id="객체-vs-역할"><a href="#객체-vs-역할" class="headerlink" title="객체 vs 역할"></a>객체 vs 역할</h2><p>만약 오직 한 종류의 객체만 협력에 참여하는 상황이라면 역할이라는 개념을 추가하는 것이 과연 좋을까?<br>역할의 개념을 생략하고 바로 협력에 객체를 이용하는 것이 좋지 않을까?<br>(spring에서 하나의 service를 사용하는 과정에서 굳이 인터페이스를 만들어야 할까 말아야 할까와 같다)</p>
<p>레베카 워브스브록은 </p>
<blockquote>
<p>협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만,<br>단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다.</p>
</blockquote>
<p>(즉, 하나의 Service만 필요하다면 클래스 기반의 Service를 만들면 되고, 2개 이상의 Service가 필요하다면 인터페이스 기반의 Service를 만들면 된다.)</p>
<p><strong>만약 서비스 개발 초반에 역할과 객체를 구분하는 것이 애매하다면 일단 객체로 시작해보자</strong><br><strong>객체로 시작하게 되면 자연스럽게 반복되고 중복되는 코드가 등장하게 되고 그때 역할로 분리해 내면 된다.</strong></p>
<p>협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용이 가능해진다.<br>역할의 가장 큰 장점은 설계의 구성 요소를 추상화할 수 있다는 점이다.</p>
<h2 id="역할과-추상화"><a href="#역할과-추상화" class="headerlink" title="역할과 추상화"></a>역할과 추상화</h2><p>추상화는 2가지 장점이 있다.</p>
<ol>
<li>추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화 할 수 있다.<ul>
<li>역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다.</li>
<li>협력이라는 관점에서는 세부적인 구현보다는 추상적인 책임에 집중하는게 유용하다.</li>
</ul>
</li>
<li>설계가 좀 더 유연해 진다.<ul>
<li>역할은 다양한 종류의 객체를 끼워 넣을 수 있는 슬롯이기 때문에 서로 대체가 가능하다</li>
<li>역할은 다양한 환경에서 다양한 객체들을 수용할 수 있게 해주기 때문에 협력에 유연하다</li>
</ul>
</li>
</ol>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - Chapter3. 역할, 책임, 협력</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2020/05/10/object-chapter2/">Objects Study - Chapter2. 객체지향 프로그래밍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="객체지향을-설계하는-방법"><a href="#객체지향을-설계하는-방법" class="headerlink" title="객체지향을 설계하는 방법"></a>객체지향을 설계하는 방법</h1><ul>
<li>클래스가 아닌 실제 working하는 instance(객체)에 초점을 둔다.</li>
<li>클래스는 객체들의 특징을 추상화 한 것</li>
<li>클래스 -&gt; 객체가 아닌 객체들을 정의하고 객체들의 특징을 기반으로 클래스를 정의한다.</li>
<li>객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.</li>
<li>객체는 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 구성원의 일원으로 봐야한다.<ul>
<li>객체를 협력하는 공동체의 일원으로 바라보게 되면 설계를 유연하고 확장 가능하게 만든다.</li>
</ul>
</li>
</ul>
<p>따라서 객체를 나열 -&gt; 타입으로 분류 -&gt; 클래스 작성 하는 순서를 따르는 것이 좋다.</p>
<h1 id="도메인-구조를-따르는-프로그램-구조"><a href="#도메인-구조를-따르는-프로그램-구조" class="headerlink" title="도메인 구조를 따르는 프로그램 구조"></a>도메인 구조를 따르는 프로그램 구조</h1><p>도메인이란? 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야<br>도메인 개념을 구현하기 위해 클래스를 사용<br>클래스 이름은 도메인 개념과 동일하거나 최대한 유사하게 짓는다.</p>
<h1 id="클래스를-설계할-때는-내부와-외부로-나눈다"><a href="#클래스를-설계할-때는-내부와-외부로-나눈다" class="headerlink" title="클래스를 설계할 때는 내부와 외부로 나눈다."></a>클래스를 설계할 때는 내부와 외부로 나눈다.</h1><ul>
<li>내부는 private, 외부에 공개할 것은 public으로 만든다.</li>
<li>경계의 명확성이 객체의 자율성을 보장한다.</li>
<li>클래스를 사용하는 입장에서는 public으로 공개된 인터페이스만 알면 된다. (내부의 구현에 대해서는 알 필요가 없다.)</li>
<li>클래스를 만들고 수정하는 입장에서는 private으로 된 부분은 클래스 외부에서 참조 하지 않으니 마음대로 구현을 변경해도 된다.</li>
<li>이러한 내&#x2F;외부의 경계를 잘 나눠야 하는 이유는 변경을 관리 하기 위해서이다.<ul>
<li>변경될 가능성이 있는 세부적인 구현 내용을 private 영역에 감춤으로써 변경으로 인한 혼란을 최소화 할 수 있다.</li>
</ul>
</li>
</ul>
<h1 id="객체는-상호-협력하는-존재들이다"><a href="#객체는-상호-협력하는-존재들이다" class="headerlink" title="객체는 상호 협력하는 존재들이다."></a>객체는 상호 협력하는 존재들이다.</h1><ul>
<li>객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있다.</li>
<li>요청 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.</li>
</ul>
<h2 id="객체의-협력"><a href="#객체의-협력" class="headerlink" title="객체의 협력"></a>객체의 협력</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> b: B</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b.method() <span class="comment">// 의존성을 가지는 B 클래스의 method 라는 메세지를 전송할 수 있다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">()</span></span> &#123; </span><br><span class="line">    doAction() </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메세지를 전송(send a message) 하는 것 뿐이다.<br>(의역하자면 다른 객체가 가지고 있는 공개된 인터페이스의 method signature를 호출한다.)</li>
<li>메세지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메세지를 처리할 방법을 결정한다.<br> 수신된 메세지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부른다.<br>(의역하자면 요청 받은 클래스의 인터페이스를 구현한 mehtod body 부분을 메서드라고 하는 것 같다.)</li>
<li>메세지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.<br>(메세지 : method signature, 메서드 : 실제 method 구현부)</li>
</ul>
<h1 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h1><ul>
<li>상속은 객체 지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.</li>
<li>자식 클래스는 부모 클래스가 수신할 수 있는 모든 메세지를 수신할 수 있다.<br>그렇기 때문에 자식 클래스는 부모 클래스와 동일한 Type으로 볼 수 있다.</li>
<li>상속은 부모 클래스의 코드를 기반으로 전혀 수정하지 않거나 일부분을 추가&#x2F;수정 하여 새로운 클래스를 만들 수 있다. (코드의 재사용)<ul>
<li>부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍 (programming by difference)라 한다.</li>
</ul>
</li>
<li>자식 클래스가 부모 클래스를 대신하는 것을 업 캐스팅(up casting)이라 한다.</li>
</ul>
<h1 id="상속의-단점"><a href="#상속의-단점" class="headerlink" title="상속의 단점"></a>상속의 단점</h1><ul>
<li>상속은 캡슐화를 위반한다.<ul>
<li>상속을 이용하기 위해선 부모 클래스의 내부 구조를 잘 알고 있어야 한다.</li>
<li>부모 클래스의 구현이 자식 클래스에 노출 되기 때문에 캡슐화가 약화된다.+</li>
<li>캡슐화는 자식 클래스와 부모 클래스의 강결합을 만들어 부모 클래스가 변경되야 하는 경우 자식 클래스도 함께 변경되게 된다.</li>
<li>상속을 과도하게 사용하면 코드를 변경하기 어렵게 된다.</li>
</ul>
</li>
<li>설계를 유연하게 하지 못한다.<ul>
<li>부모 클래스와 자식 클래스의 관계를 컴파일 타임에 결정한다.</li>
</ul>
</li>
</ul>
<h1 id="합성-composition"><a href="#합성-composition" class="headerlink" title="합성 (composition)"></a>합성 (composition)</h1><ul>
<li>인터페이스에 정의된 메세지를 통해서만 코드를 재사용하는 방법을 <strong>합성</strong>이라 한다.</li>
<li>인터페이스에 정의된 메세지를 통해서만 재사용이 가능하기 때문에 구현을 캡슐화 하기 용이하다</li>
<li>의존하는 인스턴스를 교체하는 것이 비교적 쉬워 설계를 유연하게 만든다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> DiscountPolicy discountPolicy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeDiscountPolicy</span><span class="params">(DiscountPolicy discountPolicy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.discountPolicy = discountPolicy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Movie</span> <span class="variable">avartar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="keyword">new</span> <span class="title class_">AmountDiscount</span>());</span><br><span class="line">avartar.changeDiscountPolicy(<span class="keyword">new</span> <span class="title class_">PercentDiscountPolicy</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><ul>
<li>동일한 메세지를 수신할 수 있지만, 어떤 메서드가 실행될 지는 수신하는 클래스에 따라 달라진다.<br>(인터페이스의 메서드를 호출할 수 있지만 메서드의 실행은 인터페이스를 구현한 클래스에 따라 달라진다.)</li>
<li>실행되는 메서드는 Runtime에 결정된다.  <ul>
<li>이를 Lazy Binding 또는 Dynamic Binding이라 한다.</li>
</ul>
</li>
</ul>
<h1 id="다형성의-Trade-off"><a href="#다형성의-Trade-off" class="headerlink" title="다형성의 Trade off"></a>다형성의 Trade off</h1><ul>
<li>다형성을 사용하게 되면 코드의 의존성과 Runtime의 의존성이 서로 다를 수 있다.  <ul>
<li>어떤 클래스를 주입하느냐에 따라 의존성이 달라진다.</li>
<li>하지만 코드 상으로는 인터페이스 &#x2F; 추상클래스에 대한 의존성만 가지고 있다.</li>
</ul>
</li>
<li>확장 가능한 객체 지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다.</li>
<li>코드의 의존성과 실행시점의 의존성이 다르면 코드를 이해하기 어렵고 디버깅을 어렵게 만든다.</li>
</ul>
<h1 id="추상화의-힘"><a href="#추상화의-힘" class="headerlink" title="추상화의 힘"></a>추상화의 힘</h1><ul>
<li>추상화 계층만 따로 떼어 놓고 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.<br>(뒤에 자세한 구현부는 모르겠지만 전체적인 틀을 잡기 편하다)</li>
<li>추상화를 이용하면 설계가 조금 더 유연해 진다.</li>
<li>Runtime에 주입되는 코드는 추상화를 이용해서 정의한 상위의 흐름을 따라가게 된다.</li>
<li>디자인 패턴(design pattern)이나 프레임워크(framework) 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 매커니즘을 활용하고 있다.</li>
<li>추상화를 이용하여 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.</li>
<li>유연성이 필요한 곳에 추상화를 사용하라</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - 객체지향 프로그래밍</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2020/05/09/object-chapter1/">Objects Study - Chapter1. 객체, 설계</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-09</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Object-Study/">Object-Study</a></span><div class="content"><h1 id="소프트웨어의-목적"><a href="#소프트웨어의-목적" class="headerlink" title="소프트웨어의 목적"></a>소프트웨어의 목적</h1><p>Robert C. Martin은 <strong>클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천방법</strong>에서 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.<br>(모듈이란, 크기와 상관 없이 클래스나 패키지, 라이브러리와 같은 프로그램을 구성하는 임의의 요소를 의미한다.)</p>
<ol>
<li>실행 중에 오류 없이 제대로 동작해야 한다.</li>
<li>소프트웨어는 변경을 위해 존재한다.  <ul>
<li>대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다.</li>
<li>변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다.</li>
</ul>
</li>
<li>코드를 읽는 사람과 의사소통 해야 한다.<ul>
<li>모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.</li>
<li>읽는 사람과 소통할 수 없는 모듈은 개선해야 한다.</li>
</ul>
</li>
</ol>
<h1 id="읽기-어려운-코드는-무엇일까"><a href="#읽기-어려운-코드는-무엇일까" class="headerlink" title="읽기 어려운 코드는 무엇일까?"></a>읽기 어려운 코드는 무엇일까?</h1><p>하나의 Class 또는 Method에서 너무 많은 항목을 다룬다.<br>다시 말해 Class, Method에서 하나 이상의 책임을 가지고 동작하는 코드이기 때문에<br>코드를 읽는 사람이 집중해야 할 부분이 많다.</p>
<p>코드를 작성하는 사람뿐만 아니라 코드를 읽고 이해해야 하는 사람에게 모두 부담이 된다.</p>
<h1 id="의존성-Dependency-이란"><a href="#의존성-Dependency-이란" class="headerlink" title="의존성(Dependency)이란?"></a>의존성(Dependency)이란?</h1><p>의존성이란 하나의 객체 안에서 다른 객체에 대한 코드를 호출하는 것이다.<br>의존성은 변경이란 문제와 직결된다. (의존성을 갖는 코드를 변경하게 되면 호출하는 객체에도 수정이 필요하기 때문)<br>객체 사이의 의존성이 강한 경우를 가리켜 <strong>결합도(Coupling)</strong> 가 높다고 말한다.</p>
<p>좋은 소프트웨어를 설계하기 위한 목표는 결합도가 낮은 코드를 설계하는 것이다.</p>
<h1 id="결합도는-낮추는-방법은-무엇인가"><a href="#결합도는-낮추는-방법은-무엇인가" class="headerlink" title="결합도는 낮추는 방법은 무엇인가?"></a>결합도는 낮추는 방법은 무엇인가?</h1><h2 id="객체에게-자율성을-부여하자"><a href="#객체에게-자율성을-부여하자" class="headerlink" title="객체에게 자율성을 부여하자"></a>객체에게 자율성을 부여하자</h2><p>자율성이란 객체 내부의 데이터를 변경하는 것을 객체 스스로에게 위임하는 행위를 말한다.<br>객체 내의 데이터를 다른 객체가 변경하는 것을 막는 것만으로도 결합도를 낮출 수 있다.</p>
<p>이 처럼 객체 스스로 자기 자신의 data를 제어하는 코드를 <strong>응집도(cohesion)</strong> 가 높은 코드라고 말한다.  </p>
<ul>
<li>객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임진다.</li>
<li>객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다.</li>
</ul>
<h2 id="객체를-캡슐화-한다"><a href="#객체를-캡슐화-한다" class="headerlink" title="객체를 캡슐화 한다"></a>객체를 캡슐화 한다</h2><p>개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 <strong>캡슐화(encapsulation)</strong> 라 한다.<br>캡슐화의 목적은 <strong>변경하기 쉬운 객체</strong> 를 만들기 위함이다.  </p>
<ul>
<li>객체 내부의 접근을 제한한다.</li>
<li>다른 객체에서 객체 내부의 데이터를 접근하거나 수정하지 못하도록 막으면,<br>객체 내에서 일어하는 일만 수정하면 되기 때문에 하나의 Class 파일만 변경할 수 있어 변경에 용이하다.</li>
</ul>
<h2 id="의존관계는-Interface에만-의존한다"><a href="#의존관계는-Interface에만-의존한다" class="headerlink" title="의존관계는 Interface에만 의존한다"></a>의존관계는 Interface에만 의존한다</h2><p>객체를 Interface와 구현부로 나누고 Interface만 공개한다.<br>객체간의 의존성이 필요한 부분은 Interface에서 제공하는 메서드를 가지고 코드를 작성하고 실제 구현부는<br>각각의 객체에 위임한다.</p>
<h1 id="절차-지향-vs-객체-지향"><a href="#절차-지향-vs-객체-지향" class="headerlink" title="절차 지향 vs 객체 지향"></a>절차 지향 vs 객체 지향</h1><p>절차 지향 프로그래밍(Procedural Programming)이란, Process (객체의 행위)와 데이터가 별도의 모듈에 위치한다.<br>객체 내의 데이터를 변경하는 주체가 모듈 내에서 변경하는 것이 아닌 다른 모듈에서 변경 시킨다.  </p>
<p>객체 지향 프로그래밍 (Object Oriented Programming)이란, Process(객체의 행위)와 데이터가 같은 모듈 내에 위치 한다.</p>
<h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul>
<li>변경하기 쉬운 설계는 한번에 하나만을 변경 할 수 있는 설계이다.  <ul>
<li>설계를 어렵게 만드는 것은 의존성이다.</li>
<li>하나의 변경으로 인해 의존성을 갖는 여러 코드를 변경하는 것은 좋지 못하다.</li>
</ul>
</li>
<li>훌륭한 객체 지향 설계는 캡슐화를 이용해 의존성을 적절히 관리하여 의존성을 최대한 낮추는 것이다.  <ul>
<li>객체 외부의 파급력이 없어서 변경이 수월하다.</li>
<li>캡슐화를 하면 객체의 자율성↑, 응집도↑, 결합도↓</li>
</ul>
</li>
<li>객체는 생물 처럼 스스로 생각하고 행동하도록 의인화하며 설계하면 도움이 된다.<ul>
<li>객체에 대한 적절한 책임을 위임한다.</li>
<li>기능은 최대한 객체에 위임한다.</li>
</ul>
</li>
<li>좋은 설계란, 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용 할 수 있어야 한다.<ul>
<li>개발을 시작하는 시점에 요구사항 분석이 100% 이루어지는 것은 불가능에 가깝다.</li>
<li>코드는 변화하고 살아 숨쉰다. 변화에 유연하게 대처할 수 있는 코드를 작성할 수 있는 설계를 해야 한다.</li>
</ul>
</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Objects(코드로 이해하는 객체지향 설계) - 객체, 설계</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2020/01/27/2020-01-27-hikaricp-maximum-pool-size-tuning/">HikariCP Maximum Pool Size 설정 시, 고려해야할 부분</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-27</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Springboot/">Springboot</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Hikari-CP/">Hikari CP</a></span><div class="content"><h1 id="이-글의-예상-독자"><a href="#이-글의-예상-독자" class="headerlink" title="이 글의 예상 독자"></a>이 글의 예상 독자</h1><p>아래와 같은 에러의 원인을 찾아헤멘 개발자</p>
<ul>
<li>o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLState: null</li>
<li>o.h.engine.jdbc.spi.SqlExceptionHelper   : hikari-pool-1 - Connection is not available, request timed out after 30000ms.</li>
<li>unable to obtain isolated JDBC connection; nested exception is org.hibernate.exception.JDBCConnectionException: unable to obtain isolated JDBC connection</li>
<li>Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection</li>
</ul>
<p>또는 HikariCP maximum pool size 설정할 때, 고려할게 있나?  그냥 대충 많이 만들어 두면 되는거 아니었어? 라고 하시는 개발자</p>
<h1 id="장애를-맞았습니다"><a href="#장애를-맞았습니다" class="headerlink" title="장애를 맞았습니다."></a>장애를 맞았습니다.</h1><p><img src="./db-insert-flow.png" alt="db-insert-flow"></p>
<p>사내에서 사용하는 시스템의 간략한 모식도 입니다.<br>Message Queue를 통해 Data를 application에서 consume하여 consume 한 데이터를 DB에 insert하고 있습니다.</p>
<p><img src="./db-write-lag.png" alt="db-write-lag"></p>
<p>시스템 운영중 Message Queue에 많은 데이터가 한번에 유입되었습니다. 그로 인해</p>
<ol>
<li>DB에 insert하는 과정에서 쓰기지연이 발생 하였습니다. </li>
<li>쓰기 지연이 발생하여, Message Queue의 lag이 증가하여 많은 량의 Data를 처리하지 못하고 밀리는 상황이 되었습니다.</li>
</ol>
<p>원인은 분석하니, Message Queue Consumer Thread 갯수와 HikariCP maximum pool size간의 상관관계가 있음을 발견하였고,<br>그 과정에서 <strong>HikariCP의 Pool Size로 인한 Thread dead lock이 발생하여 Insert Query가 실패하고 있음을 알게 되었습니다.</strong><br>이번 장애를 통해 알게 된 <strong>Dead lock을 피할 수 있는 HikariCP maximum pool size 갯수</strong>를 설정하는 방법에 대해 공유하고자 합니다.</p>
<h1 id="HikariCP에서는-Connection을-어떻게-관리하나"><a href="#HikariCP에서는-Connection을-어떻게-관리하나" class="headerlink" title="HikariCP에서는 Connection을 어떻게 관리하나?"></a>HikariCP에서는 Connection을 어떻게 관리하나?</h1><p>Springboot 2.x가 출범하면서 HikariCP를 default JDBC Connection Pool로 사용하고 있고,  성능이 좋고 빠르기로 이미 검증된 Connection Pool입니다.<br>이번 문제를 해결하면서 하나의 스레드가 Hikari Pool에서 커넥션을 얻고 <strong>(getConnection)</strong>, 커넥션을 반납 <strong>(close)</strong> 하는 과정을 살펴보았습니다.</p>
<p>아래 내용을 보시기 전에…</p>
<ul>
<li>HikariPool에서는 Connection 객체를 한번 wrapping한  PoolEntry라는 Type으로 내부적으로 Connection을 관리합니다.<br>아래 글에서는 이해를 편하게 하도록 Connection이라는 용어로 언급하도록 하겠습니다.</li>
<li><strong>1인칭 Thread 시점</strong>을 통해 생각해 보았습니다.</li>
</ul>
<h2 id="하나의-Query가-실행되는-과정"><a href="#하나의-Query가-실행되는-과정" class="headerlink" title="하나의 Query가 실행되는 과정"></a>하나의 Query가 실행되는 과정</h2><p>내부적인 코드는 더 잘 구성이 되어있지만, 간략한 코드로 표현하자면 아래와 같을 것 입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  connection = hikariDataSource.getConnection(); </span><br><span class="line">  preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">  preparedStatement.executeQuery();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(preparedStatement != <span class="literal">null</span>) &#123;</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(connection != <span class="literal">null</span>) &#123;</span><br><span class="line">    connection.close(); <span class="comment">// this returns the connection to the pool</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>hikariDataSource.getConnection()을 통해 hikariPool에서 Connection을 하나 얻습니다.</li>
<li>execute()를 통해 쿼리를 실행하고 connection.close()을 통해 hikari pool에 connection을 반납합니다.</li>
</ol>
<p>getConnection(), close()를 조금 더 내려가서 HikariPool에서의 처리를 자세하게 살펴보겠습니다.</p>
<h2 id="Hikari님-Connection-하나만-주세여"><a href="#Hikari님-Connection-하나만-주세여" class="headerlink" title="Hikari님! Connection 하나만 주세여"></a>Hikari님! Connection 하나만 주세여</h2><p>Hikari Pool에서 getConnection 로직은 3단계를 통해 Connection 객체를 얻을 수 있게 되어있습니다.<br><strong>(HikariCP에서 얼마나 성능을 올리기 위해 노력했는지 코드로 보입니다.)</strong><br>Hikari CP에서는 <strong>ConcurrentBag</strong>이라는 구조체를 이용해 Connection을 관리하고 있습니다.<br><strong>HikariPool.getConnection() -&gt; concurrentBag.borrow()</strong> 라는 메서드를 통해 사용가능한 Connection을 리턴하도록 되어있습니다.</p>
<p>1인칭 Thread 시점으로 Hikari Pool에게 Connection을 하나 요청해 보았습니다.<br><em><strong>(개발은 유치하게 이해할수록 이해도 잘되고 기억에 잘 남는것 같아서.. 각본을 준비해봤습니다.)</strong></em></p>
<p><em><strong>[Thread-1님]</strong> 안녕하세요 Hikari님! Connection 하나만 주세요~</em><br><strong>[Hikari님]</strong> 안녕하세요 Thread-1님! 저희 pool에서는 Connection을 주는 규칙이 있답니다. 확인해볼게요~<br><strong>[Hikari님]</strong> 이전에 Thread-1님이 저희 pool에 방문한 내역 먼저 살펴볼게요!<br><strong>[Hikari님]</strong> 오! 이전에 방문한 내역이 있으시네요~ 근데 그때 사용한 Connection은 다른 Thread 님이 사용 중(IN_USE) 이시네요~<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;다른 Thread님이 안 쓰셨으면 빠르게 이 Connection 먼저 드렸을 텐데 아쉽네요ㅠㅠ<br><em><strong>[Thread-1님]</strong> 괜찮아요! Hikari님 다른 Connection 주세요~</em><br><strong>[Hikari님]</strong> Pool 전체에서 사용 가능한(idle) Connection이 있는지 찾아볼께요~<br><strong>[Hikari님]</strong> (Loop 돌면서 찾는중…)<br><strong>[Hikari님]</strong> Thread-1님 지금 전체 Connection이 다 사용중이에요! ㅠㅠ<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;저기 handoffQueue 앞에 가서 좀 기다리셔야 할 것 같아요 ㅜㅜ<br><em><strong>[Thread-1님]</strong> 네 괜찮아요! (안 괜찮음) 저기서 30초만 기다려보고 없으면 Exception내면 되죠^^<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <strong>(깨알 Tip. HikariCP default Connection timeout은 30초 입니다.)</strong></em><br><strong>[Hikari님]</strong> 네 죄송합니다 Thread-1님. 다음에 또 다시 방문해주세요~<br><em><strong>[Thread-1님]</strong> (handoffQueue에서 다른 Thread가 쓰고 반납한 Connection을 얻었다!)</em></p>
<p>혹시 잘 이해가 가셨을까요..?<br>이해가 아직 안되신 분들을 위한 Flow chart를 준비해보았습니다.</p>
<p><img src="./getConnection-flow.png" alt="getConnection-flow"></p>
<p>코드 레벨로 확인해보시려면 -&gt; <a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP/blob/dev/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L126">ConcurrentBag.borrow()</a></p>
<h2 id="Hikari님-Connection-다-썼어요"><a href="#Hikari님-Connection-다-썼어요" class="headerlink" title="Hikari님! Connection 다 썼어요"></a>Hikari님! Connection 다 썼어요</h2><p>HikariCP에서 얻은 Connection은 <code>(ProxyConnection) Connection.close()</code>를 하게 되면 HikariPool에 반납이 됩니다.<br>(HikariPool에서 얻은 Connection은 ProxyConnection 타입입니다.)<br>정상적인 transaction이 마무리 되거나, Rollback이 호출 되어도 <code>connection.close()</code>가 호출되어 Connection을 반납합니다.<br>getConnection과 마찬가지로 <code>connection.close()</code> 시, <code>concurrentBag.requite()</code>이 실행되며 Connection이 반납됩니다.</p>
<p>위와 같이 1인칭 Thread 시점으로 각본을 짜보겠습니다. </p>
<p><em><strong>[Thread-1님]</strong> Transaction내의 쿼리를 모두 수행하고 Commit이 되었어 이제 Connection을 반납해볼까?</em><br><em><strong>[Thread-1님]</strong> Thread-1님이 (ProxyConnection) connection.close()을 실행하였습니다.</em><br><strong>[Hikari님]</strong> 안녕하세요 Thread-1님! Connection 이용은 만족스러우셨나요? Connection 반납 절차 도와드리겠습니다.<br><strong>[Hikari님]</strong> 일단 PoolEntry의 상태를 STATE_NOT_IN_USE로 바꿀게요. <strong>(여기서 idle connection이 됩니다.)</strong><br><strong>[Hikari님]</strong> handOffQueue에서 Connection을 받길 원하는 다른 Thread님이 있나봐요~<br><strong>[Hikari님]</strong> (handOffQueue에 Connection 삽입)<br><strong>[Hikari님]</strong> Thread-1님 고생하셨습니다~ 이번에 사용한 Connection 정보 등록해 드릴께요<del>! 다음에 빠르게 이용하실 수 있으실거에요<br>***[Thread-1님]** 감사합니다! Hikari님 또 Connection 받으러 올께요</del>*  </p>
<p>혹시 잘 이해가 가셨을까요..?<br>이해가 아직 안되신 분들을 위한 Flow chart를 준비해보았습니다.</p>
<p><img src="./close-flow.png" alt="close-flow"></p>
<p>코드 레벨로 확인해보시려면 -&gt; <a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP/blob/dev/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java#L181">ConcurrentBag.requite()</a></p>
<h1 id="HikariCP에서-Dead-lock이-발생하는-Case"><a href="#HikariCP에서-Dead-lock이-발생하는-Case" class="headerlink" title="HikariCP에서 Dead lock이 발생하는 Case"></a>HikariCP에서 Dead lock이 발생하는 Case</h1><p>consumer thread 갯수에 따른 충분한 HikariCP의 maximum pool size를 설정하지 못해 Dead lock이 발생하여 이번 장애로 이어지게 되었습니다.<br>도데체 무슨 관계가 있다고 Dead lock이 발생했을까요?<br>간단한 예시를 통해 알아보도록 하겠습니다.</p>
<p>Thread count와 maximum pool size의 조건은 아래와 같습니다.</p>
<ul>
<li>Thread Count: 1개</li>
<li>HikariCP MaximumPoolSize: 1개</li>
<li>하나의 트랜잭션에서 요구되는 Connection 갯수: <strong>2개!!</strong></li>
</ul>
<p>조금은 감이 오시나요?<br>그림으로 살펴보도록 하겠습니다.</p>
<p><img src="./dead-lock-case.png" alt="dead-lock-case"></p>
<ol>
<li>하나의 Thread가 Repository.save(entity) 라는 insert query를 실행하기 위해 Transaction을 구성합니다.</li>
<li>Transaction용 Connection을 하나 가져옵니다. <strong>(PoolStats : total&#x3D;1, active&#x3D;1, idle&#x3D;0, waiting&#x3D;0)</strong></li>
<li>Transaction을 시작하였고 Repository.save를 하기 위해 Connection이 하나 더 필요하다고 <strong>가정</strong>해보겠습니다.</li>
<li>Thread-1은 Hikari Pool에 Connection을 요청합니다.<ol>
<li>위의 3단계 절차대로, 현재 자기 Thread의 방문내역을 살펴봅니다.<br>아직 방문내역이 등록된 게 없습니다.</li>
<li>전체 Hikari Pool에서 idle상태의 Connection을 스캔합니다.<br>Pool Size는 1개이고 1개 있던 Connection은 Thread-1에서 이미 사용중입니다.</li>
<li>마지막으로 handOffQueue에서 누군가 반납한 Connection이 있길 기대하며 30초 동안 기다립니다.<br>하나 있던 Connection을 자기 자신이 사용하고 있기 때문에 자기 자신이 반납하지 않는 이상 사용할 Connection이 없습니다.<br><strong>(PoolStats : total&#x3D;1, active&#x3D;1, idle&#x3D;0, waiting&#x3D;1)</strong></li>
<li>결국 30초가 지나고 Connection Timeout이 발생하고<br><code>hikari-pool-1 - Connection is not available, request timed out after 30000ms.</code> 와 같은 에러가 발생</li>
</ol>
</li>
<li>Transaction에 대한 evictMark가 찍히고 트랜잭션이 롤백 됩니다. </li>
<li>롤백 됨과 동시에 Transaction용 Connection은 다시 Pool에 반납됩니다. <strong>(PoolStats : total&#x3D;1, active&#x3D;0, idle&#x3D;0, waiting&#x3D;0)</strong></li>
</ol>
<p>이렇게 Thread내에서 하나의 Task에 수행하는데 필요한 Connection갯수가 모자라게 되면<br><strong>Dead Lock 상태에 빠져 Insert Query를 실행할 수 없게 됩니다.</strong></p>
<h1 id="위에는-예시이고-실제-상황은-뭐였어요"><a href="#위에는-예시이고-실제-상황은-뭐였어요" class="headerlink" title="위에는 예시이고, 실제 상황은 뭐였어요?"></a>위에는 예시이고, 실제 상황은 뭐였어요?</h1><p>제가 장애를 맞았던 실제 환경에 대해 설명해드리겠습니다.</p>
<p>장애 환경에 대한 Thread count와 maximum pool size의 조건은 아래와 같습니다.</p>
<ul>
<li><p>CPU Core : 4개</p>
</li>
<li><p>Thread Count: 16개</p>
</li>
<li><p>HikariCP MaximumPoolSize: 10개</p>
</li>
<li><p>하나의 트랜잭션에서 요구되는 Connection 갯수: <strong>2개</strong><br>(처음엔 1개일거라 생각했지만, getConnection에 대한 디버깅을 해보니 2번의 getConnection 요청이 발생했습니다.)</p>
</li>
</ul>
<p>실제 구현부의 간단한 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Message <span class="title function_">save</span><span class="params">(<span class="keyword">final</span> Message message)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> repository.save(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>혹시 이 코드에서 왜 Connection이 2개나 필요한지 짐작이 되시나요?<br>코드만 보면 하나의 Connection으로 Insert가 잘 될 것 같습니다.<br>여태까지 그런줄 알았고 이번 장애가 아니었다면 몰랐을 것이었습니다.</p>
<h2 id="GeneratedValue-strategy-x3D-GenerationType-AUTO"><a href="#GeneratedValue-strategy-x3D-GenerationType-AUTO" class="headerlink" title="@GeneratedValue(strategy &#x3D; GenerationType.AUTO)"></a>@GeneratedValue(strategy &#x3D; GenerationType.AUTO)</h2><p>이 사건의 범인은 이 코드로 부터 시작됩니다.<br>GeneratedValue(strategy &#x3D; GenerationType.AUTO)인 경우에는 JPA 구현체가 자동으로 ID값 생성전략을 결정합니다.<br>사내에서 사용하는 RDB는 MySQL을 사용하고 있습니다.<br>ID의 Type이 long 타입이고, <code>hibernate.id_new_generator_mappings</code> 값이<code>true</code> (default true)이기 때문에<br>ID 필드에 대한 Generator는 내부적으로 SequenceStyleGenerator를 사용하게 됩니다.<br>하지만 MySQL에서는 Oracle처럼 Sequence라는게 존재하지 않기 때문에 <code>hibernate_sequence</code>라는 테이블을 생성하고, 테이블에 단일 로우로 된 id값을 계속 update하며 sequence처럼 관리합니다.  </p>
<p>getConnection에 대한 call tree를 역주행하면서 hibernate 내부 코드까지 보게 되었습니다.<br>call tree에 대한 대략적인 단계는 아래와 같습니다.</p>
<ol>
<li>repository.save(entity): 내부적으로 SimpleJpaRepository.save가 호출됩니다.</li>
<li>DefaultPersistEventListener에 의해 saveWithGeneratedId가 호출됩니다.</li>
<li>saveWithGeneratedId가 실행되며, Entity의 Id값을 생성할 때 SequenceStyleGenerator를 이용하여 생성합니다.</li>
<li>SequenceStyleGenerator.generate 코드에서 databaseStructure.buildCallback()이 실행되며, TableStructure.buildCallBack()이 실행됩니다<br>(이 코드에서 hibernate_sequence에 대한 조회, update가 이루어집니다.)</li>
<li>hibernate_sequence를 조회, update를 하는데에 있어서 별도의 Transaction으로 동작하게 됩니다.<br>  <code>select next_val as id_val from hibernate_sequence for update</code> 쿼리를 실행하게 되고, 트랜잭션이 끝나기 전까지 Table Lock이 걸리게 됩니다.<br>(만약 같은 Transaction 내에서 동작했다면은 hibernate_sequence table에 대한 Table Lock이 동작해 다른 스레드에서 id값을 생성하지 못할 것입니다.)</li>
<li><strong>별도의 트랜잭션으로 동작하게 되면서 새로운 Connection을 하나 받아오게 됩니다</strong> (여기서 2번째 connection을 받아옵니다.)</li>
</ol>
<p>위의 call tree에 대한 코드 입니다.</p>
<p><img src="./save.png" alt="save"></p>
<p><img src="./AbstractSaveEventListener.saveWithGeneratedId.png" alt="AbstractSaveEventListener.saveWithGeneratedId"></p>
<p><img src="./id_generator.png" alt="id_generator"></p>
<p><img src="./execute_hibernate_sequence.png" alt="execute_hibernate_sequence"></p>
<p><img src="./TableStructure.delegateWork.png" alt="TableStructure.delegateWork"></p>
<h2 id="하나의-Task에서-필요한-Connection은-2개인데-왜-Dead-Lock이-걸리죠"><a href="#하나의-Task에서-필요한-Connection은-2개인데-왜-Dead-Lock이-걸리죠" class="headerlink" title="하나의 Task에서 필요한 Connection은 2개인데 왜 Dead Lock이 걸리죠?"></a>하나의 Task에서 필요한 Connection은 2개인데 왜 Dead Lock이 걸리죠?</h2><p>부하가 크게 걸리지 않는 일반적인 상황에서는 문제가 없을 것입니다. 스레드 전체가 일을 하지 않을 것이기 때문입니다.<br>문제는 전체 스레드가 동시에 일을 하게 되는 부하 상황 시에 발생합니다.  </p>
<p><img src="./dead-lock-case2.png" alt="dead-lock-case2"></p>
<p>이런 식으로 16개의 스레드 중 10개의 스레드가 10개의 Connection을 모두 잡고 있으면 10개의 스레드 중 하나의 스레드에서<br>2번째 Connection에 대한 timeout이 발생하지 않으면 계속 30초씩 지연이 발생하게 됩니다.<br>하물며 idle Connection이 다시 발생한들 남은 6개의 Thread들 중 하나가 Connection을 가져가면 dead lock의 악순환의 고리에 빠지게 됩니다.<br>간혹 운이 좋게 하나의 스레드가 Connection 2개를 획득하여 트랜잭션이 성공하는 case도 있을 것 입니다.<br>(이런 경우 간헐적으로 동작하기 때문에 원인 파악이 매우 힘들어 집니다.)</p>
<h1 id="Dead-lock을-피하는-Maximum-pool-size는-어떻게-설정하나요"><a href="#Dead-lock을-피하는-Maximum-pool-size는-어떻게-설정하나요" class="headerlink" title="Dead lock을 피하는 Maximum pool size는 어떻게 설정하나요?"></a>Dead lock을 피하는 Maximum pool size는 어떻게 설정하나요?</h1><p>HikariCP의 Dead lock에 대한 case는 이미 HikariCP issue에 등록되어있다.<br>HikariCP에서는 Dead Lock을 피하기 위한 최적의 Maximum Pool Size를 방법을 제시하고 있다.  </p>
<p>공식은 아래와 같다.</p>
<blockquote>
<h3 id="pool-size-x3D-Tn-x-Cm-1-1"><a href="#pool-size-x3D-Tn-x-Cm-1-1" class="headerlink" title="pool size &#x3D; Tn x (Cm - 1) + 1"></a><em>pool size &#x3D; Tn x (Cm - 1) + 1</em></h3></blockquote>
<ul>
<li><em>Tn</em> : Thread의 최대 수</li>
<li><em>Cm</em>: 하나의 Task에서 필요한 Connection 갯수</li>
</ul>
<h2 id="실제로-맞는-공식인지-알아보자"><a href="#실제로-맞는-공식인지-알아보자" class="headerlink" title="실제로 맞는 공식인지 알아보자"></a>실제로 맞는 공식인지 알아보자</h2><ul>
<li>Thread Count : 8개</li>
<li>하나의 Task에 필요한 Connection 갯수: 2개</li>
<li>pool Size &#x3D; 8 x ( 2 - 1) + 1 &#x3D; 9개</li>
</ul>
<p><img src="./avoid-dead-lock.png" alt="avoid-dead-lock"></p>
<ul>
<li>thread 8개가 골고루 Connection을 하나씩 얻었고 7개의 스레드가 2번째 스레드를 기다리고 있다.  </li>
<li>이렇게 되면 스레드 2번의 2번째 Connection은 빠르게 hibernate_sequence만 조회, update하고 빠르게 반납되게 된다.  </li>
<li>이로 인해 다른 스레드에서도 Connection을 받을 수 있게 된다</li>
<li>thread 2번에서도 정상적으로 트랜잭션이 처리되게 된다. -&gt; connection이 반납된다.</li>
<li>위와 같은 pool size로 dead lock을 피할 수 있는 최소한의 pool size를 얻을 수 있게 되었다.</li>
</ul>
<h1 id="이-글을-쓰고나니-생기는-질문"><a href="#이-글을-쓰고나니-생기는-질문" class="headerlink" title="이 글을 쓰고나니 생기는 질문"></a>이 글을 쓰고나니 생기는 질문</h1><ul>
<li><p>Embedded Tomcat의 default thread count는 200개인데 공식을 적용하면 hikari pool size가 수백개가 될 수도 있다.</p>
<ul>
<li>기본적으로 task당 1개의 connection만 필요하면 poolSize 1개로도 모든 요청은 다 처리할 수 있다.</li>
<li>2개 이상의 connection이 필요한 경우에는 tomcat thread count를 줄이고 hikari pool size도 100개 이하로 조정한다.</li>
<li>퍼포먼스가 안나오는 경우에는 DB에 insert하는 application의 아키텍쳐를 수정하는 방법도 있을 것 같다.</li>
</ul>
</li>
<li><p>퍼포먼스 저하는 없었나?</p>
<ul>
<li>기존 16개인 thread를 4개 정도로 조절했다.</li>
<li>1 thread 당 300 TPS정도의 성능이 나와 4 core인 환경에서는 문제 없이 처리할 수 있다.</li>
<li>오히려 thread 수를 줄여 message queue의 throttling을 할 수 있게 되었다.</li>
<li>core 수에 맞게 제한된 리소스를 사용하는 것이 오히려 context-switching에 대한 overhead를 줄여 성능상의 이점이 있다고 한다.<br>([About Pool Sizing] - &lt;<a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing">https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing</a>)</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="Limited-Resources"><a href="#Limited-Resources" class="headerlink" title="Limited Resources"></a>Limited Resources</h4><p>It is not quite as simple as stated above, but it’s close. There are a few other factors at play. When we look at what the major bottlenecks for a database are, they can be summarized as three basic categories: <em>CPU</em>, <em>Disk</em>, <em>Network</em>. We could add <em>Memory</em> in there, but compared to <em>Disk</em> and <em>Network</em> there are several orders of magnitude difference in bandwidth.</p>
<p>If we ignored <em>Disk</em> and <em>Network</em> it would be simple. On a server with 8 computing cores, setting the number of connections to 8 would provide optimal performance, and anything beyond this would start slowing down due to the overhead of context switching. But we cannot ignore <em>Disk</em> and <em>Network</em>. Databases typically store data on a <em>Disk</em>, which traditionally is comprised of spinning plates of metal with read&#x2F;write heads mounted on a stepper-motor driven arm. The read&#x2F;write heads can only be in one place at a time (reading&#x2F;writing data for a single query) and must “seek” to a new location to read&#x2F;write data for a different query. So there is a seek-time cost, and also a rotational cost whereby the disk has to wait for the data to “come around again” on the platter to be read&#x2F;written. Caching of course helps here, but the principle still applies.</p>
</blockquote>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>[About Pool Sizing] - <a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing">https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing</a></li>
<li>[Down the Rabbit Hole] - <a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole">https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">https://github.com/brettwooldridge/HikariCP</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2020/01/08/2020-01-08-hikari-pool-validate-connection/">HikariCP Failed to Validate Connection Warning 이야기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-08</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Springboot/">Springboot</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Hikari-CP/">Hikari CP</a></span><div class="content"><h1 id="hikari-pool-Failed-to-validate-connection"><a href="#hikari-pool-Failed-to-validate-connection" class="headerlink" title="hikari-pool - Failed to validate connection"></a>hikari-pool - Failed to validate connection</h1><p>Springboot2.x를 사용하다 보면 이런 warn level 에러를 마주칠 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hikari-pool - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@1e2db70  </span><br><span class="line">(No operations allowed after connection closed.).  </span><br><span class="line">Possibly consider using a shorter maxLifetime value.</span><br></pre></td></tr></table></figure>

<p>로그의 내용을 의역하면 아래와 같습니다.</p>
<ul>
<li>Hikari pool의 connection을 validate하는데 실패 했다.</li>
<li>이미 close된 connection에 어떤 operation을 하는것은 안된다.</li>
<li>HikariPool의 <code>maxLifetime</code> 값을 짧게 하는 것을 생각해봐라</li>
</ul>
<h3 id="무슨말-일까요"><a href="#무슨말-일까요" class="headerlink" title="무슨말 일까요?"></a><strong>무슨말 일까요?</strong></h3><p>요약하자면, connection을 갱신하고자 하는데 이미 닫힌 커넥션이라 어떤 행위도 할 수 없다. 입니다.<br>여기서 중요한건 HikariConfig의 MaxLifetime과 MySQL의 wait_timeout의 상관관계를 알아야 합니다.</p>
<h1 id="Hikari-Pool의-MaxLifetime"><a href="#Hikari-Pool의-MaxLifetime" class="headerlink" title="Hikari Pool의 MaxLifetime"></a>Hikari Pool의 MaxLifetime</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">This property controls the maximum lifetime of a connection in the pool.  </span><br><span class="line">An in-use connection will never be retired, only when it is closed will it then be removed.  </span><br><span class="line">On a connection-by-connection basis, minor negative attenuation is applied to avoid mass-extinction in the pool.  </span><br><span class="line">We strongly recommend setting this value, and it should be several seconds shorter than any  </span><br><span class="line">database or infrastructure imposed connection time limit.   </span><br><span class="line">A value of 0 indicates no maximum lifetime (infinite lifetime),  </span><br><span class="line">subject of course to the idleTimeout setting. Default: 1800000 (30 minutes)</span><br></pre></td></tr></table></figure>



<p>구글번역기로 대충 돌려보면..</p>
<ul>
<li>MaxLifetime은 Hikari pool에서 Connection이 살아 있을 수 있는 시간</li>
<li>현재 사용중인 Connection은 종료하지 않고 이미 닫혀 있는 경우에만 제거</li>
<li>Connection을 한번에 대량으로 종료하고 생성하면 비용이 많이 듬 (실제로 2.5%의 유격으로 maxLifetime이 Connection에 설정됨)</li>
<li>Database에 설정된 Connection time limit 보다 짧아야 한다.</li>
<li>0으로 설정하면 무한으로 Connection이 살아있음</li>
<li>default 180000ms (&#x3D; 30분)</li>
</ul>
<p>Hikari Pool 내부적으로 Connection의 life time을 관리하는 속성입니다.</p>
<p>maxLifetime은 최소 30초 이상으로 설정하여야 합니다. (안그러면 180000ms로 설정)</p>
<p><img src="./minimum-maxLifetime.png" alt="minimum-maxLifetime"></p>
<h1 id="MySQL의-wait-timeout"><a href="#MySQL의-wait-timeout" class="headerlink" title="MySQL의 wait_timeout"></a>MySQL의 wait_timeout</h1><ul>
<li>wait_timeout: 활동하지 않는 커넥션을 끊을때까지 서버가 대기하는 시간</li>
</ul>
<p>현재 아무것도 안하고 sleep 상태인 Connection을 끊는 주기입니다.</p>
<h2 id="주의"><a href="#주의" class="headerlink" title="주의!"></a>주의!</h2><p>wait_timeout은 session, global variable 두 개로 구성되어있습니다.</p>
<ul>
<li>show variables like ‘wait_timeout’; : 현재 연결된 session에 대한 wait_timeout 값</li>
<li>show <strong>global</strong> variables like ‘wait_timeout’: global wait_timeout값</li>
</ul>
<p>활동하지 않는 커넥션을 종료하는 것은 mysql daemon에서 해주기 때문에 global wait_timeout 값에 의해 종료됩니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br></pre></td></tr></table></figure>

<p>위의 명령어는 현재 mysql에서 동작중인 process (&#x3D; connection) 정보입니다. </p>
<p><img src="./processlist.png" alt="processlist"></p>
<p>Time 필드의 값이 Sleep Command가 실행되고 경과된 시간입니다.<br>Time 필드의 값이 설정된 global wait_timeout 시간이 지나면 <strong>Connection을 종료하게 됩니다.</strong></p>
<h1 id="Hikari-Pool에서-Connection을-관리하는-방법"><a href="#Hikari-Pool에서-Connection을-관리하는-방법" class="headerlink" title="Hikari Pool에서 Connection을 관리하는 방법"></a>Hikari Pool에서 Connection을 관리하는 방법</h1><p>JDBC4를 지원하는 드라이버에서는 예전처럼 더이상 <code>validationQuery</code> 를 수행하여 Connection을 갱신하지 않습니다.<br>이제는 Connection이 생성될 때 Hikari PoolEntry에 Scheduled Event를 걸어 maxLifetime 시간 이후에 강제적으로 Connection을 종료하도록 되어있습니다.</p>
<p><img src="./createPoolEntry.png" alt="createPoolEntry"></p>
<p>maxLifeTime에 2.5%의 변화를 주어 모든 Connection이 한순간에 종료되지 않도록 설정하였습니다.</p>
<p><img src="./softEvictConnection.png" alt="softEvictConnection"><br><img src="./reserve-PoolEntry-Status.png" alt="reserve-PoolEntry-Status"><br>softEvict Connection. 말 그대로 status만 변경하여 evict connection을 수행합니다.</p>
<p><img src="./soft-remove.png" alt="soft-remove"></p>
<p>위에서 변경한 Connection의 상태에 따라 진짜로 connection을 close 할지 말지 결정합니다.<br>(STATE_RESERVED 상태인 PoolEntry에 대한 Connection을 제거 합니다.)</p>
<p><img src="./connection-close.png" alt="connection-close"></p>
<h1 id="진짜-validationQuery는-필요없어졌나"><a href="#진짜-validationQuery는-필요없어졌나" class="headerlink" title="진짜 validationQuery는 필요없어졌나?"></a>진짜 validationQuery는 필요없어졌나?</h1><p>기존에는 validationQuery, ConnectionTestQuery &#x3D; SELECT 1등, test-idle-while 같은 기능을 구현하기 위해 또는<br>Connection의 갱신, validation을 하기 위해 의미 없는 Query를 실행하여, DB에 부하를 계속 주고 있었습니다.</p>
<p>하지만 JDBC4를 구현한 driver에서는 더 이상 validationQuery, ConnectionTestQuery를 사용하지 않도록 권장합니다.<br>(지금도 Hikari CP에는 기능은 있으나 코드가 실행안됨)</p>
<p>Connection Pool에서 한 개의 Connection을 받아 사용하기 전에 <code>isConnectionAlive</code> 라는 메서드가 실행됩니다.<br>(내가 지금 받은 커넥션이 유효한가? 에 대한 검사입니다.)</p>
<p><img src="./isConnectionAlive.png" alt="isConnectionAlive"></p>
<p>위의 코드를 보면 Jdbc4Validation을 사용하는 경우에는 Connection.isValid 메서드를 통해 현재 커넥션이 유효한지 검사합니다.<br>하지만, Jdbc4Validation을 사용하지 않는 경우에는 직접 ConnectionTestQuery를 실행하여 현재 커넥션에 대한 유효성을 판단합니다.</p>
<p><img src="./isUseJdbc4Validation.png" alt="isUseJdbc4Validation"></p>
<p>HikariPool 설정에서는 ConnectionTestQuery property가 null인 경우 Jdbc4Validation으로 동작합니다.</p>
<h1 id="그래서-Failed-to-validate-connection-로그는-왜-나오나요"><a href="#그래서-Failed-to-validate-connection-로그는-왜-나오나요" class="headerlink" title="그래서  Failed to validate connection 로그는 왜 나오나요"></a>그래서  Failed to validate connection 로그는 왜 나오나요</h1><p>저의 경우에는<br>mysql의 global wait_timeout 값이 60초로 설정되어 있었습니다.<br>Hikari Pool의 maxLifetime 값은 default로 180000ms (&#x3D; 30분) 으로 되어져 있었습니다 .</p>
<p>따라서 30분마다 PoolEntry에서 놀고 있는 Connection을 종료하고자 하였지만, 이미 MySQL process는 종료되었기에<br><strong>이미 닫힌 커넥션에 왜 무언가를 하려고하는가?</strong> 라고 warning log가 발생하였습니다. </p>
<p><img src="./isConnectionAlive.png" alt="isConnectionAlive"></p>
<p>catch 절에서 Exception이 발생하여 해당 로그가 찍히게 됩니다.</p>
<h1 id="maxLifetime-wait-timeout-어떻게-설정해야-하나요"><a href="#maxLifetime-wait-timeout-어떻게-설정해야-하나요" class="headerlink" title="maxLifetime, wait_timeout 어떻게 설정해야 하나요?"></a>maxLifetime, wait_timeout 어떻게 설정해야 하나요?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We strongly recommend setting this value, and it should be at least 30 seconds less than any  </span><br><span class="line">database or infrastructure imposed connection time limit.</span><br></pre></td></tr></table></figure>

<p>Hikari CP에서는 maxLifetime을 MySQL의 wait_timeout보다 최소 30초 이상 적게 주도록 권장하고 있습니다.<br>(하지만 이는 잘못되었다고 합니다. <a target="_blank" rel="noopener" href="https://pkgonan.github.io/2018/04/HikariCP-test-while-idle">pkgonan님 질문 참고</a>)</p>
<p>pkgonan님이 받으신 답변을 참고하면 </p>
<p>답변 요약</p>
<ul>
<li>max_lifetime을 Database의 wait_timeout보다 30초 이상 짧게 주라는 것은 잘못 되었다.<br>공식 문서 업데이트를 진행하지 않은 것이다.</li>
<li>HikariCP는 DBA를 존중하기 때문에 DBA가 설정한 wait_timeout을 지킨다.</li>
<li>HikariCP는 커넥션 풀을 관리하기 위해 HouseKeeper라는 Thread가 30초마다 돌고 있다.</li>
<li>HouseKeeper가 30초마다 돌며 커넥션을 종료하였기에, 이전 29.xx초까지의 커넥션들에 대해 유효성 체크가 누락될 수 있어서 30초의 여유를 준 것이다.</li>
<li>현재 방식은, ThreadLocal에서 각각 타이머를 통해 max-lifetime에 도달했는지 체크를 하는 방식으로 변경되었다.</li>
<li><code>따라서, max-lifetime은 네트워크 통신 등을 감안해서 Database의 wait_timeout으로 부터 2~3초 정도 짧게 주면 된다.</code></li>
<li><code>커넥션이 사용중일 경우 즉시 종료를 하지 않기에 커넥션이 매우 바쁜 상황을 감안해서 여유있게 준다면 wait_timeout으로 부터 5초정도까지 짧게 주면 된다는 개발자의 추가 답변.</code></li>
</ul>
<p>결론적으로<br>maxLifetime &#x3D; wait_timeout - (2~5초) 정도로 설정하면 됩니다. </p>
<h1 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h1><p>저의 경우에는 maxLifetime의 Default를 더 존중하여 30분을 유지하도록 하고<br>MySQL의 global wait_timeout 값을 1830초 정도로(그냥 넉넉하게) 수정하여 사용하도록 변경하였습니다.<br>(maxLifetime을 바꾸자니 너무 잦은 커넥션 생성 비용이 염려스러웠습니다.)  </p>
<p>이렇게 설정하고 나니 더 이상 Failed to validate connection WARN 로그는 발생하지 않았습니다. </p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">https://github.com/brettwooldridge/HikariCP</a></li>
<li><a target="_blank" rel="noopener" href="https://pkgonan.github.io/2018/04/HikariCP-test-while-idle">https://pkgonan.github.io/2018/04/HikariCP-test-while-idle</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/12/23/2019-12-23-kafka-streams-binder-feature/">Spring-Kafka-Streams Serde 내부 이야기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-23</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Kafka/">Kafka</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Springboot/">Springboot</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Kafka-streams/">Kafka-streams</a></span><div class="content"><h1 id="Version-Up"><a href="#Version-Up" class="headerlink" title="Version Up"></a>Version Up</h1><p>팀에서 사용하는 Spring boot version up (2.1.6 -&gt; 2.2.2)을 하면서 호환성을 맞추기 위해<br>spring-cloud-stream-binder-kafka-streams 라이브러리도 같이 버전업을 하게 되었습니다. (2.2.0 -&gt; 2.3.4)<br>그 과정에서 발생한 value Serde 이슈에 대한 내용을 얘기해 보고자 합니다.</p>
<h1 id="Kafka-Streams란"><a href="#Kafka-Streams란" class="headerlink" title="Kafka Streams란?"></a>Kafka Streams란?</h1><p>kafka streams는 kafka streams api를 사용하여, 지속적으로 흘러들어오는 데이터에 대한 분석, 처리를 위한 클라이언트 라이브러리 입니다.</p>
<p>간단하게는 어떤 Topic으로 들어오는 데이터를 Consume하여, streams api를 통해 처리 후<br>다른 Topic으로 전송(Producing) 하거나 끝내는 행위를 하게 됩니다.</p>
<h1 id="Spring에서-사용하기"><a href="#Spring에서-사용하기" class="headerlink" title="Spring에서 사용하기"></a>Spring에서 사용하기</h1><p>Springboot에서 kafka streams를 사용하게 되면 <code>@StreamListener</code> annotation을 사용해서 로직을 구현하게 됩니다.</p>
<p><img src="./StreamListener-annoataion.png" alt="StreamListener-annoataion"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(MessageDispatcher.Dispatch.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageDispatcher</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@StreamListener(Dispatch.TOPIC)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(KStream&lt;String, Message&gt; input)</span> &#123;</span><br><span class="line">    input.mapValues(value -&gt; value.markSendFlag())</span><br><span class="line">      .to(<span class="string">&quot;next-topic&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Dispatch</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;message-topic&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Input(TOPIC)</span></span><br><span class="line">    KStream&lt;String, Message&gt; <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>간단하게 Message를 처리하는 kafka streams code를 작성해 보았습니다<br><code>message-topic</code>토픽으로 들어오는 메세지를 consume하여 sendFlag 처리를 하고 <code>next-topic</code>으로 다시 producing하는 코드 입니다.</p>
<p>기본적으로 kafka에서 쓰이는 content-type은 <code>application/json</code>이기 때문에  value fotmat을 Json으로 사용하고 있습니다.</p>
<p>그렇다면 kafka에는 <strong>분명 value가 json string일텐데,</strong> @StreamListener 메서드에서는 <code>어떻게 json -&gt; Pojo로 Deserializing 해주었을까요? </code></p>
<p>이걸 찾아보기 전까지는 막연하게 default.value.serde (Serializier&#x2F;DeSerializer)가 해주는줄 알았습니다.  <code>(반은 맞고 반은 아님) </code><br>하지만 이번 version up 이슈를 통해 자세하게 알아보았고, 그 내용을 적어보았습니다.</p>
<h1 id="spring-cloud-stream-binder-kafka-streams-2-2-0"><a href="#spring-cloud-stream-binder-kafka-streams-2-2-0" class="headerlink" title="spring-cloud-stream-binder-kafka-streams 2.2.0"></a>spring-cloud-stream-binder-kafka-streams 2.2.0</h1><p><code>@StreamListener</code> annoataion은 <code>StreamListenerAnnotationPostProcessor</code> class에 의해 annotation processing 작업이 이루어집니다.</p>
<p>그 내부에서 StreamListenerSetupMethodOrchestrator class에 의해 processing이 이루어지며,<br>정확히는 <code>KafkaStreamsStreamListenerSetupMethodOrchestrator</code> 입니다.</p>
<p>살펴볼 코드의 순서는 이렇습니다.</p>
<ol>
<li><code>orchestrateStreamListenerSetupMethod</code></li>
<li><code>adaptAndRetrieveInboundArguments</code></li>
<li><code>keySerde, valueSerde</code> 설정하는 부분</li>
<li><code>valueSerde 설정</code> (과연 valueSerde는 뭐를 쓰고 있었을까?)</li>
<li><code>if (parameterType.isAssignableFrom(KStream.class))</code></li>
<li><code>getkStream(inboundName, spec, bindingProperties, streamsBuilder, keySerde, valueServde, autoOffsetReset)</code></li>
<li><code>streamListenerParameterAdapter.adapt</code></li>
<li><code>deserializeOnInbound</code></li>
<li><code>convertAndSetMessage</code></li>
<li><code>ApplicationJsonMessageMarshallingConverter.convertFromInternal</code></li>
</ol>
<h2 id="3-keySerde-valueSerde-설정"><a href="#3-keySerde-valueSerde-설정" class="headerlink" title="3. keySerde, valueSerde 설정"></a>3. keySerde, valueSerde 설정</h2><p><img src="./setSerde.png" alt="setSerde"></p>
<p>6번째 줄부터 keySerde, valueSerde를 설정하는 부분을 볼 수 있습니다.</p>
<h2 id="4-valueSerde-설정"><a href="#4-valueSerde-설정" class="headerlink" title="4. valueSerde 설정"></a>4. valueSerde 설정</h2><p><img src="./getInboundValueSerde-7085172.png" alt="getInboundValueSerde"></p>
<p>중요!한 valueSerde 설정 부분입니다.<br>try 블록 첫번째 if문을 보면 consumerProperties에 <code>useNativeDecoding</code> 속성이 true인 경우에만 getValueSerde() 메서드를 호출하여 default.value.serde가 적용되게 됩니다.<br>그게 아니라면 ByteArray Serde가 적용됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When set to true, the inbound message is deserialized directly by client library,</span></span><br><span class="line"><span class="comment"> * which must be configured correspondingly (e.g. setting an appropriate Kafka</span></span><br><span class="line"><span class="comment"> * producer value serializer). <span class="doctag">NOTE:</span> This is binder specific setting which has no</span></span><br><span class="line"><span class="comment"> * effect if binder does not support native serialization/deserialization. Currently</span></span><br><span class="line"><span class="comment"> * only Kafka binder supports it. Default: &#x27;false&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> useNativeDecoding;</span><br></pre></td></tr></table></figure>

<p>default는 false이기 때문에 기본적으로 ByteArray Serde가 적용됩니다.<br>(그것도 모르고 default.value.serde에 명시한 Serde가 적용되는 줄 알았습니다.)</p>
<p><img src="./getValueSerde.png" alt="getValueSerde"></p>
<h2 id="5-if-parameterType-isAssignableFrom-KStream-class"><a href="#5-if-parameterType-isAssignableFrom-KStream-class" class="headerlink" title="5. if (parameterType.isAssignableFrom(KStream.class))"></a>5. if (parameterType.isAssignableFrom(KStream.class))</h2><p><img src="./KStream-if.png" alt="KStream-if"></p>
<p>여기서 중요하게 봐야 할 부분은 두군데 입니다.</p>
<ul>
<li>getkStream()</li>
<li>streamListenerParameterAdapter.adapt(kStreamWrapper, methodParameter)</li>
</ul>
<h2 id="6-getkStream"><a href="#6-getkStream" class="headerlink" title="6. getkStream()"></a>6. getkStream()</h2><p><img src="./getStream.png" alt="getStream"></p>
<p>마지막의 stream.mapValues 쪽을 잘봐야 합니다.<br>여기에도 nativeDecoding에 대한 조건이 있습니다.<br>contentType은 default를 사용하고 있기 때문에 <code>application/json</code>이 적용됩니다.<br>stream.mapValues내의 함수는 runtime에서 실행되는 함수이기 때문에 kafka streams에서 message를 consume하고 실행하는 함수입니다.</p>
<p>정리해보면..</p>
<ul>
<li>contentType &#x3D; <code>application/json</code></li>
<li>useNativeDecoding &#x3D; <code>false</code></li>
</ul>
<p>이므로</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">returnValue = MessageBuilder.withPayload(value)</span><br><span class="line">  .setHeader(MessageHeaders.CONTENT_TYPE, contentType)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure>

<p>kafka에서 처리하는 Message Type으로 처리가 되게 됩니다.</p>
<h1 id="7-streamListenerParameterAdapter-adapt"><a href="#7-streamListenerParameterAdapter-adapt" class="headerlink" title="7. streamListenerParameterAdapter.adapt"></a>7. streamListenerParameterAdapter.adapt</h1><p><img src="./streamListenerParameterAdapter.png" alt="streamListenerParameterAdapter"></p>
<p><img src="./StreamListenerParameterAdapter-interface.png" alt="StreamListenerParameterAdapter-interface"></p>
<p>다음은 @StreamListener가 달린 Parameter를 처리하기 위한 Adapter 설정입니다.<br>이 메서드 내에서 KStream&lt;String, YourPojoType&gt;인 KStream의 Deserializing이 이루어집니다.</p>
<p><img src="./adapt.png" alt="adapt"></p>
<p>interface 구현체는 <code>KStreamStreamListenerParameterAdapter</code> 클래스입니다.<br>여기서도 useNativeDecoding 속성에 따라 코드가 분기가 됩니다.<br>default &#x3D; false이기 때문에 아래 deserializeOnInbound 메서드가 호출됩니다.</p>
<h2 id="8-deserializeOnInbound"><a href="#8-deserializeOnInbound" class="headerlink" title="8. deserializeOnInbound"></a>8. deserializeOnInbound</h2><p><img src="./deSerializeOnInbound.png" alt="deSerializeOnInbound"></p>
<p>쭉~ 복잡한 코드가 보입니다.<br>그중에서도 볼것은 <code>convertAndSetMessage</code> 메서드입니다.</p>
<h2 id="9-convertAndSetMessage"><a href="#9-convertAndSetMessage" class="headerlink" title="9. convertAndSetMessage"></a>9. convertAndSetMessage</h2><p><img src="./convertAndSetMessage.png" alt="convertAndSetMessage"></p>
<p><img src="./CompositeMessageConverter-fromMessage.png" alt="CompositeMessageConverter-fromMessage"></p>
<p>valueClass.isAssignableFrom() &#x3D; false이므로 messageConverter.fromMessage() 메서드가 실행됩니다.<br>(여기서 사용되는 messageConverter는 여러가지 messageConvert를 모아둔 <code>CompositeMessageConverter</code> 가 사용됩니다.)</p>
<p>그중에서도 <code>ApplicationJsonMessageMarshallingConverter</code>를 사용하여 Json Data를 targetClass 타입으로 변환시킵니다.<br><strong>그렇기 때문에 따로 Serde를 정의하지 않아도 Kafka Stream 라이브러리에서 알아서 잘 deserialize를 해주었습니다.</strong></p>
<h2 id="10-ApplicationJsonMessageMarshallingConverter-convertFromInternal"><a href="#10-ApplicationJsonMessageMarshallingConverter-convertFromInternal" class="headerlink" title="10. ApplicationJsonMessageMarshallingConverter.convertFromInternal"></a>10. ApplicationJsonMessageMarshallingConverter.convertFromInternal</h2><p><img src="./convertFromInternal2.png" alt="convertFromInternal2"></p>
<p>내부적으로는 Jackson 라이브러리의 objectMapper를 이용하여 deserialize 하는 코드가 있습니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul>
<li>spring kafka streams에 대한 별다른 설정을 안했다면 default로 작동할 것 입니다.</li>
<li>useNativeDecoding &#x3D; false로 설정 되어있을 것입니다.</li>
<li>위의 설정을 true로 하지 않았다면, default.key.serde, default.value.serde 설정은 먹히지 않습니다.</li>
<li>기본적으로 ByteArray valueSerde를 사용했을 것입니다.</li>
<li>ApplicationJsonMessageMarshallingConverter에 의해 Json String이 파라미터에 정의한 타입에 맞게 알아서 잘 deserializing 해줬을 것입니다.</li>
</ul>
<h1 id="spring-cloud-stream-binder-kafka-streams-2-3-4"><a href="#spring-cloud-stream-binder-kafka-streams-2-3-4" class="headerlink" title="spring-cloud-stream-binder-kafka-streams 2.3.4"></a>spring-cloud-stream-binder-kafka-streams 2.3.4</h1><p>대부분의 코드 및 설정은 2.2.0 버전과 같습니다.<br>하지만 2.2.0을 default로 세팅해서 사용하시는 분들은 버전 업 후에는 잘 안되는것을 보실수 있습니다.<br>2.3.4에서 크게 바뀐 점 한 가지로 인해서 코드가 정상적으로 동작하지 않을 수 있게 되었습니다.</p>
<h2 id="useNativeDecoding의-default가-true로-변경"><a href="#useNativeDecoding의-default가-true로-변경" class="headerlink" title="useNativeDecoding의 default가 true로 변경"></a>useNativeDecoding의 default가 true로 변경</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When set to true, the inbound message is deserialized directly by client library,</span></span><br><span class="line"><span class="comment"> * which must be configured correspondingly (e.g. setting an appropriate Kafka</span></span><br><span class="line"><span class="comment"> * producer value serializer). <span class="doctag">NOTE:</span> This is binder specific setting which has no</span></span><br><span class="line"><span class="comment"> * effect if binder does not support native serialization/deserialization. Currently</span></span><br><span class="line"><span class="comment"> * only Kafka binder supports it. Default: &#x27;false&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> useNativeDecoding;</span><br></pre></td></tr></table></figure>

<p>2.3.4의 ConsumerProperties의 useNativeDecoding 주석을 보면 여전히 Default: false로 표기되어 있습니다.<br>하지만 로직 상에서는 아무런 처리도 하지 않은 <strong>useNativeDecoding의 값이 true로 나오게 됩니다.</strong></p>
<p><strong>어디서 useNativeDecoding 값을 true로 바꿨을까요?</strong><br>call tree를 찾아보니 다행히도 딱  세 군데에서만 호출하고 있습니다.</p>
<ul>
<li>KStreamBoundElementFactory</li>
<li>KTableBoundElementFactory</li>
<li>GlobalKTableBoundElementFactory</li>
</ul>
<p><img src="./createInput2-2-0.png" alt="createInput 2.2.0"><br><img src="./createInput.png" alt="createInput 2.3.4"></p>
<p>createInput 메서드에 집중해 보겠습니다.<br>createInput 메서드는 @StreamListener에 대한 post processing 단계에서 호출되는 코드입니다.</p>
<p>parameter로 들어오는 name은 input binding name입니다. (@StreamListener에 설정한 input name)<br>코드를 보면 consumerProperties의 useNativeDecoding을 무조건 true로 만들어 주고 있습니다.<br>(2.2.0 버전에서는 없던 코드가 추가되었습니다. useNativeDecoding이 default false였네요)</p>
<ul>
<li>KStreamBoundElementFactory</li>
<li>KTableBoundElementFactory</li>
<li>GlobalKTableBoundElementFactory</li>
</ul>
<p>그래서 useNativeDecoding가 true가 되었다는 의미는<br><strong>더이상 kafka에서 제공하는 Message Type으로 자동 deserializing이 되지 않고 개발자가 하나하나 deserializer을 지정해주어야 함을 의미합니다.</strong></p>
<p>이를 해결하기 위한 방법은 2가지 있습니다.</p>
<ol>
<li>useNativeDecoding을 false로 설정한다. &#x3D;&gt; 다시 kafka에서 제공하는 자동 deserialize 기능을 사용한다.</li>
<li>binding input 별로 하나하나 deserializer를 지정한다.</li>
</ol>
<p>해결방법을 보고나니 spring에서 왜 이렇게 코드를 변경했는지 알 것만 같습니다.</p>
<p>기존에는 별도로 지정하지 않게 되면 무조건 자동 deserialize가 되도록 했는데,<br>일부러 true로 바꾸었다는 것은 bindings 별로 deserializer를 각각 지정하도록 권장하는 것 같습니다.</p>
<h2 id="1-useNativeDecoding을-false로-설정한다"><a href="#1-useNativeDecoding을-false로-설정한다" class="headerlink" title="1. useNativeDecoding을 false로 설정한다."></a>1. useNativeDecoding을 false로 설정한다.</h2><p><img src="./createInput.png" alt="createInput"></p>
<p>위의 코드를 잘 보게되면, encodingDecodingBindAdviceHandler.isDecodingSettingProvided() &#x3D; false일때 true로 설정하게 합니다.<br>저 코드도 궁금해서 한번 들어가보았습니다.</p>
<p><img src="./EncodingDecodingBindAdviceHandler.png" alt="EncodingDecodingBindAdviceHandler"></p>
<p>apply() 메서드를 보게되면 spring configuration properties를 모두 읽으면서 조건에 맞는 configName을 찾고 있습니다.<br>아마도 <code>spring.cloud.streams.binding.[input-name].use-native-decoding</code> 또는 <code>encoding</code>을 찾는가 봅니다.<br>저게 설정이 있으면 true로 변경되니 일단 원하는대로 설정을 해줘보겠습니다.</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.stream.bindings.message-topic.use-native-decoding</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>이렇게 하면 use-native-decoding 설정이 false가 되어 2.2.0에서 제공하던 kafka의 자동 deserialize 기능이 동작해서 이전버전과 동일하게 동작합니다.</p>
<blockquote>
<p>주의) use-native-decoding default 설정을 다시 전체 false로 하고 싶은데..<br>아쉽게도 binder 별로 설정이 적용되어 전체를 하기 어렵게 되었습니다.<br>귀찮더라도 하나하나 지정해 줍시다.</p>
<p>spring.cloud.stream.bindings.message-topic1.use-native-decoding&#x3D;false<br>spring.cloud.stream.bindings.message-topic2.use-native-decoding&#x3D;false</p>
</blockquote>
<h2 id="2-binding-input-별로-하나하나-deserializer를-지정한다"><a href="#2-binding-input-별로-하나하나-deserializer를-지정한다" class="headerlink" title="2. binding input 별로 하나하나 deserializer를 지정한다."></a>2. binding input 별로 하나하나 deserializer를 지정한다.</h2><p>이번 spring-kafka 버전에서 원하는대로 input 별로 하나하나 deserializer를 지정해 주겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageSerde</span> <span class="keyword">implements</span> <span class="title class_">Serde</span>&lt;Message&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Serializer&lt;Message&gt; <span class="title function_">serializer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (topic, data) -&gt; JsonUtils.toByteArray(data);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Deserializer&lt;Message&gt; <span class="title function_">deserializer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (topic, data) -&gt; JsonUtils.fromJson(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>참고. JsonUtils는 제가 만든 Json 변환 Utils입니다.</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">stream</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">streams</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">binder</span>:<span class="string"></span></span><br><span class="line">           <span class="attr">configuration</span>:<span class="string"></span></span><br><span class="line">            <span class="attr">default</span>:<span class="string"></span></span><br><span class="line">              <span class="attr">key.serde</span>: <span class="string">org.apache.kafka.common.serialization.Serdes$StringSerde</span></span><br><span class="line">              <span class="attr">value.serde</span>: <span class="string">org.springframework.kafka.support.serializer.JsonSerde</span></span><br><span class="line">          <span class="attr">bindings</span>:<span class="string"></span></span><br><span class="line">            <span class="attr">message-topic</span>:<span class="string"></span></span><br><span class="line">              <span class="attr">consumer</span>:<span class="string"></span></span><br><span class="line">                <span class="attr">applicationId</span>: <span class="string">messageDispatcher</span></span><br><span class="line">                <span class="attr">keySerde</span>: <span class="string">org.apache.kafka.common.serialization.Serdes$StringSerde</span></span><br><span class="line">                <span class="attr">valueSerde</span>: <span class="string">com.my.packages.serde.MessageSerde</span></span><br></pre></td></tr></table></figure>

<p><strong>주의) property의 depth가 깊어서 틀리지 않게 주의해야 합니다.</strong></p>
<p>default key, value serde는 <code>spring.cloud.stream.kafka.streams.binder.configuration</code> 아래에 정의합니다.<br>binding input 별 key, value serde는 <code>spring.cloud.stream.kafka.streams.bindings.[input-name].consumer</code> 아래에 정의합니다.</p>
<h1 id="추가내용"><a href="#추가내용" class="headerlink" title="추가내용"></a>추가내용</h1><p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-stream-binder-kafka/3.0.0.M3/reference/html/spring-cloud-stream-binder-kafka.html#_kafka_streams_properties">https://cloud.spring.io/spring-cloud-static/spring-cloud-stream-binder-kafka/3.0.0.M3/reference/html/spring-cloud-stream-binder-kafka.html#_kafka_streams_properties</a></p>
<p>내용을 보면 <code>useNativeEncoding</code> 과 <code>useNativeDecoding</code> 의 default value가 true라고 알려주고 있습니다.<br>spring-cloud-stream의 backend가 무엇이냐에 따라 default 값이 달라지므로 주의해야할 것 같습니다.<br>(kafka에서는 default가 true이고 다른 backend는 default가 false일 수 있습니다.)</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="../../"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="../../">1</a><span class="page-number current">2</span><a class="page-number" href="../3/">3</a><span class="space">&hellip;</span><a class="page-number" href="../12/">12</a><a class="extend next" rel="next" href="../3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="../../js/utils.js?version=1.9.0"></script><script src="../../js/fancybox.js?version=1.9.0"></script><script src="../../js/sidebar.js?version=1.9.0"></script><script src="../../js/copy.js?version=1.9.0"></script><script src="../../js/fireworks.js?version=1.9.0"></script><script src="../../js/transition.js?version=1.9.0"></script><script src="../../js/scroll.js?version=1.9.0"></script><script src="../../js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>