<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다. | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../melody-favicon.ico"><link rel="stylesheet" href="../../css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href=".."><span class="pull-left">Articles</span><span class="pull-right">112</span></a><a class="author-info-articles__tags article-meta" href="../../tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Carrey`s 기술블로그</div><div id="site-sub-title">공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/20/effective-java-item17/">Item 17. 변경 가능성을 최소화하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="불변-클래스-immutable-class-란"><a href="#불변-클래스-immutable-class-란" class="headerlink" title="불변 클래스(immutable class)란?"></a>불변 클래스(immutable class)란?</h1><ul>
<li>인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.  </li>
<li>불변 클래스의 인스턴스는 객체가 생성되는 시점에 초기화되고 소멸이 될 때까지 값이 변경되지 않는다.  </li>
<li>불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.</li>
<li>값이 변경되지 않으니 오류가 발생할 일도 적고 안전하다.</li>
</ul>
<h1 id="불변-클래스를-만들기-위한-5가지-조건"><a href="#불변-클래스를-만들기-위한-5가지-조건" class="headerlink" title="불변 클래스를 만들기 위한 5가지 조건"></a>불변 클래스를 만들기 위한 5가지 조건</h1><h2 id="객체의-상태를-변경하는-메서드-변경자-를-제공하지-않는다"><a href="#객체의-상태를-변경하는-메서드-변경자-를-제공하지-않는다" class="headerlink" title="객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다."></a>객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.</h2><ul>
<li>쉽게 말해 setter나, 필드 정보를 변경하는 메서드를 제공하지 않는다.<h2 id="클래스를-확장-할-수-없도록-한다"><a href="#클래스를-확장-할-수-없도록-한다" class="headerlink" title="클래스를 확장 할 수 없도록 한다."></a>클래스를 확장 할 수 없도록 한다.</h2></li>
<li>클래스를 final로 선언한다.</li>
<li>모든 생성자는 private으로 만들고 생성자 정적 팩터리 메서드를 제공한다.</li>
<li>정적 팩터리 메서드는 유연성을 제공한다.</li>
<li>다음 릴리즈에서 Boolean처럼 <code>캐싱</code>을 이용해 성능을 끌어올릴 수도 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor(access = AccessLevel.PRIVATE, staticName=&quot;of&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="모든-필드를-final로-선언한다"><a href="#모든-필드를-final로-선언한다" class="headerlink" title="모든 필드를 final로 선언한다."></a>모든 필드를 final로 선언한다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor(access = AccessLevel.PRIVATE, staticName=&quot;of&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>필드에 대해 수정을 막겠다는 설계자의 의도를 보여준다. - final클래스는 생성자에서 딱 <code>1회 초기화</code> 할 수 있기 때문이다.</li>
<li>인스턴스에 대한 동기화(syncronized)처리 없이도 다른 스레드에서 문제없이 처리 된다.</li>
</ul>
<h2 id="모든-필드를-private로-선언한다"><a href="#모든-필드를-private로-선언한다" class="headerlink" title="모든 필드를 private로 선언한다."></a>모든 필드를 private로 선언한다.</h2><ul>
<li>필드가 참조하는 가변 객체를 클라이언트에서 직접 접근하여 수정하는 일을 막는다.</li>
<li>public final로만 처리해도 되지만, 그 안의 내용을 바꿀 수 있고 다 릴리즈에서 내부 표현을 변경하지 못하므로 사용하지 않는게 좋다.</li>
</ul>
<h2 id="자신-객체-이외에는-내부의-가변-컴포넌트에-접근-할-수-없도록-한다"><a href="#자신-객체-이외에는-내부의-가변-컴포넌트에-접근-할-수-없도록-한다" class="headerlink" title="자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다."></a>자신(객체) 이외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.</h2><ul>
<li>클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다. - Collection에 대한 getter를 제공하면 안된다!</li>
<li>생성자, 접근자(getter), readObject 메서드에서 모두 <code>방어적 복사</code>를 수행해야 한다.</li>
</ul>
<h1 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍"></a>함수형 프로그래밍</h1><ul>
<li>피연산자에 함수를 적용해 결과를 반환하는 프로그래밍 기법</li>
<li>피연산자에 대해 연산하지만 피연산자는 값이 변하지 않음<br>(캡처 - 피연산자는 사실상 final)</li>
<li>코드의 불변이 영역이 되는 비율이 높아져 안전하다.</li>
</ul>
<h1 id="불변-객체의-장점"><a href="#불변-객체의-장점" class="headerlink" title="불변 객체의 장점"></a>불변 객체의 장점</h1><ul>
<li>불변 객체는 생성 시점부터 소멸될 때 까지 변하지 않는다. - 서비스 로직에 더 안전하다.</li>
<li>불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. - 스레드에 따라 값이 변하지 않기 때문이다.</li>
<li>불변 객체는 안심하고 공유 할 수 있다. - 불변 클래스라면 최대한 재사용 하라 (캐싱)</li>
<li>불변 객체는 방어적 복사본이 필요없다 - 바뀌지 않으므로 방어할 일이 없다.</li>
<li>불변 객체는 clone메서드를 제공하지 않는게 좋다. - 의미가 없다.</li>
<li>불변 객체를 key로 하면 이점이 많다.<ul>
<li>Map의 key</li>
<li>Set의 원소</li>
</ul>
</li>
<li>불변 객체는 그 자체로 실패 원자성을 제공한다.<ul>
<li>메서드에서 예외가 발생하더라도 객체의 변경내용이 없다.</li>
</ul>
</li>
<li>불변 객체끼리는 자유롭게 내부 데이터를 공유 할 수 있다.<ul>
<li>BigInteger 클래스에서 mag는 크기를 나타내는 배열</li>
<li>signum은 부호를 나타내는 int 필드</li>
<li>mag는 배열이지만 불변이므로 방어적 복사본을 만들지 않고 원래 객체의 mag를 써도 된다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a BigInteger whose value is &#123;<span class="doctag">@code</span> (-this)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> -this&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="built_in">this</span>.mag, -<span class="built_in">this</span>.signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>불변 객체는 값이 다르면 반드시 독립된 객체로 만들어야 한다.</li>
</ul>
<h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul>
<li>접근자(getter)를 제공한다고 습관처럼 수정자(setter)를 만들지 말자<ul>
<li>꼭 필요한 경우가 아니라면 클래스는 불변이어야 한다.</li>
<li>장점이 훨씬많고, 단점이라면 잠재적 성능저하 뿐이다.</li>
</ul>
</li>
<li>불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한 줄이자<ul>
<li>객체가 가질 수 있는 상태를 제한하면, 예외를 예측하기 쉽고, 오류가 생길 가능성이 줄어든다.</li>
<li>꼭 변경할 필드가 아닌 필드는 final로 선언하자 - 웬만하면 final로 해야한다.</li>
</ul>
</li>
<li>생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.<ul>
<li>확실한 이유가 없다면, 생성자와 정적팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다.</li>
<li>특히! 객체를 재활용할 목적으로 상태를 다시 초기화 하는 메서드도 안된다.</li>
<li>복잡성만 커지고 성능 이점은 거의 없다.</li>
</ul>
</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 17. 변경 가능성을 최소화하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/20/effective-java-item16/">Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="퇴보한-클래스"><a href="#퇴보한-클래스" class="headerlink" title="퇴보한 클래스"></a>퇴보한 클래스</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> x;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이런 클래스는 데이터 필드에 직접 접근하여 수정이 가능하다. 따라서 캡슐화의 이점을 제공하지 못한다. </p>
<ul>
<li>API를 수정하지 않고는 내부 표현을 바꿀 수 없다.</li>
<li>불변식을 보장할 수 없다.</li>
<li>외부에서 필드에 접근할 때 부수 작업을 수행 할 수도 없다.<br>(예를들면, x값 조회 시, Comma case로 리턴하는 식의?)</li>
</ul>
<h1 id="흔하게-만드는-캡슐레이션"><a href="#흔하게-만드는-캡슐레이션" class="headerlink" title="흔하게 만드는 캡슐레이션"></a>흔하게 만드는 캡슐레이션</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Point</span> <span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getX</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getY</span><span class="params">()</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">double</span> x)</span> &#123; <span class="built_in">this</span>.x = x; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">double</span> y)</span> &#123; <span class="built_in">this</span>.y = y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>public 클래스라면 반드시 이정도의 접근자와 수정자를 만드는 정도는 해야된다.  </li>
<li>클래스 내부 표현 방식을 언제든지 바꿀 수 있는 유연성을 제공해야 한다.</li>
<li>package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 문제가 없다.<ul>
<li>같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.</li>
</ul>
</li>
</ul>
<h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><ul>
<li>public 클래스는 절대 가변 필드를 노출해선 안된다.</li>
<li>불변 필드라면 노출해도 덜위험 하지만 그래도 하지 말아라.</li>
<li>package-private 클래스, 톱 레벨 클래스에서는 노출하는 편이 나을 수도 있다. (글쎄..?)</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 16. Public 클래스에서는 Public 필드가 아닌 접근자 메서드를 사용하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/19/effective-java-item15/">Item 15. 클래스와 멤버의 접근 권한을 최소화하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-19</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>잘 설계된 컴포넌트는 클래스는 모든 내부구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리 해놨다.<br>오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.<br>정보은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.</p>
<h1 id="정보-은닉의-장점"><a href="#정보-은닉의-장점" class="headerlink" title="정보 은닉의 장점"></a>정보 은닉의 장점</h1><h2 id="시스템-개발-속도를-높인다"><a href="#시스템-개발-속도를-높인다" class="headerlink" title="시스템 개발 속도를 높인다."></a>시스템 개발 속도를 높인다.</h2><p>여러가지 컴포넌트를 병렬로 개발할 수 있기 때문이다.<br>예를 들어, 회원탈퇴 기능을 개발한다고 해보자</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WithdrawalService</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">withdrawalMember</span><span class="params">(Member member)</span>;</span><br><span class="line">  List&lt;Member&gt; <span class="title function_">getMembers</span><span class="params">()</span>;</span><br><span class="line">  WithdrawalProcessType <span class="title function_">getProcessType</span><span class="params">()</span>; </span><br><span class="line">  <span class="keyword">default</span> <span class="title function_">startProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Member&gt; members = getMembers();</span><br><span class="line">    members.stream().foreach(<span class="built_in">this</span>::withdrawalMember);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이러한 회원탈퇴 로직에 대한 인터페이스를 제공하고,<br>일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴등의 로직이 상이하여 Service를 별도로 구현한다고하는 경우 Interface 스펙에 맞추어 여러 개발자가 개발할 수 있기 때문이다.</p>
<h2 id="시스템-관리-비용을-낮춘다"><a href="#시스템-관리-비용을-낮춘다" class="headerlink" title="시스템 관리 비용을 낮춘다."></a>시스템 관리 비용을 낮춘다.</h2><p>각 컴포넌트를 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 로직에 변경이 생긴 경우<br><code>WithdrawalService</code> interface를 구현한 비회원 탈퇴 서비스를 만들면 되기 때문이다.</p>
<h2 id="성능-최적화에-도움을-준다"><a href="#성능-최적화에-도움을-준다" class="headerlink" title="성능 최적화에 도움을 준다."></a>성능 최적화에 도움을 준다.</h2><p>완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있다.<br>위에서 예시로 들은 일반회원 탈되, 해외회원 탈퇴, 비회원 탈퇴에서 비회원 탈퇴 중 비회원 탈퇴에 대해 처리대상이 많아 startProcess 메서드를 확장하여 내부적으로 withdrawalMember 메서드를 사용하지 않고 회원 리스트에 대해 쿼리를 이용해 Insert~ Select로 한방에 처리 할 수도 있다.</p>
<h2 id="소프트웨어-재사용성을-높인다"><a href="#소프트웨어-재사용성을-높인다" class="headerlink" title="소프트웨어 재사용성을 높인다."></a>소프트웨어 재사용성을 높인다.</h2><p>외부에 의존하지 않고, 독자적으로 동작할 수 있는 컴포넌트라면, 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.<br>예를들면 알림톡 서버 API를 호출 할 수 있는 인터페이스가 있는 경우 그 인터페이스를 그대로 사용할 수 있다.</p>
<h2 id="큰-시스템을-제작하는-난이도를-낮춰준다"><a href="#큰-시스템을-제작하는-난이도를-낮춰준다" class="headerlink" title="큰 시스템을 제작하는 난이도를 낮춰준다."></a>큰 시스템을 제작하는 난이도를 낮춰준다.</h2><p>시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.<br>쉬운 예로 Mockito를 이용한 TestCase 작성이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith(MockitoJUnitRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithdrawalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TestWithdrawalService</span> <span class="keyword">implements</span> <span class="title class_">WithdrawalService</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">withdrawalMember</span><span class="params">(Member member)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Member&gt; <span class="title function_">getMembers</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> TestWithdrawalService testWithdrawalService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMocks</span><span class="params">()</span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 회원탈퇴_테스트() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        doReturn(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;Carrey&quot;</span>))).when(testWithdrawalService).getMembers();</span><br><span class="line">        doCallRealMethod().when(testWithdrawalService).startProcess();</span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> testWithdrawalService.startProcess();</span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(result, is(<span class="string">&quot;FINISHED&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java의-접근제한자"><a href="#Java의-접근제한자" class="headerlink" title="Java의 접근제한자"></a>Java의 접근제한자</h1><ul>
<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. </li>
<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.</li>
<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>
<li>public: 모든 곳에서 접근 할 수 있다.</li>
</ul>
<h1 id="모든-클래스와-멤버의-접근성을-가능한-좁혀야-한다"><a href="#모든-클래스와-멤버의-접근성을-가능한-좁혀야-한다" class="headerlink" title="모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다."></a>모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.</h1><p>소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다.</p>
<h2 id="클래스-레벨-접근제한자"><a href="#클래스-레벨-접근제한자" class="headerlink" title="클래스 레벨 접근제한자"></a>클래스 레벨 접근제한자</h2><p>톱레벨 수준(파일명 &#x3D; 클래스명)이 같은 수준에서의 접근제한자는 public과 package-private만 사용 할 수 있다.</p>
<ul>
<li>public으로 선언하는 경우 공개 API로 사용 - 하위호환을 평생 신경써야 한다.</li>
<li>package-private로 사용하는 경우 해당 패키지 안에서만 사용 가능 - 다음 릴리즈에 내부로직을 변경해도 괜찮다.</li>
</ul>
<h2 id="이너클래스-사용하기"><a href="#이너클래스-사용하기" class="headerlink" title="이너클래스 사용하기"></a>이너클래스 사용하기</h2><ul>
<li>한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩해보자</li>
<li>public일 필요가 없는 클래스의 접근 수준을 package-private로 해보자 - 다른 패키지에서 사용하지 못하게 막아야 한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Shop&gt; shops;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="private과-package-private은-해당-클래스의-구현에-해당하므로-공개-API에-영향을-주지-않는다"><a href="#private과-package-private은-해당-클래스의-구현에-해당하므로-공개-API에-영향을-주지-않는다" class="headerlink" title="private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다."></a>private과 package-private은 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.</h2><ul>
<li>일단 처음에는 모든 멤버는 private으로 만들어야 한다.</li>
<li>같은 패키지에서 접근해야 하는 멤버가 있는 경우 package-private로 변경</li>
<li>단, Serialize를 구현한 클래스의 경우 공개 API에 의도치 않게 공개 될 수도 있다.</li>
<li>필드의 접근 권한을 package-private에서 protected로 바꾸는 순간 필드에 접근 할 수 있는 대상 범위가 늘어나니 주의해야 한다.</li>
</ul>
<h2 id="메서드를-재정의-할-경우에는-접근-수준을-상위-클래스에서보다-좁게-설정-할-수-없다"><a href="#메서드를-재정의-할-경우에는-접근-수준을-상위-클래스에서보다-좁게-설정-할-수-없다" class="headerlink" title="메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다."></a>메서드를 재정의 할 경우에는 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다.</h2><ul>
<li>상위 클래스에서 접근제한자가 protected인데 하위클래스에서 갑자기 package-private이나 private로 변경할 수 없다.</li>
<li>상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환원칙)을 위반하기 때문이다.</li>
<li>단 인터페이스를 구현하는 경우에는 클래스의 메서드는 모두 public으로 해야 한다.</li>
</ul>
<h2 id="코드를-테스트-하려는-목적으로-클래스-인터페이스를-접근-범위를-넓히는-것을-주의하라"><a href="#코드를-테스트-하려는-목적으로-클래스-인터페이스를-접근-범위를-넓히는-것을-주의하라" class="headerlink" title="코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라"></a>코드를 테스트 하려는 목적으로 클래스, 인터페이스를 접근 범위를 넓히는 것을 주의하라</h2><p>public 클래스의 private -&gt; package-private으로 바꾸는거는 괜찮다. 하지만 그이상의 경우 공개 API에 문제가 될 수 있다.</p>
<h1 id="public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다"><a href="#public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다" class="headerlink" title="public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다."></a>public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</h1><p>필드가 가변객체를 참조하거나(Collections이나 배열), final이 아닌 인스턴스 필드를 public으로 선언하면 <strong>불변식을 보장할 수 없다.</strong><br>public 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지않다.<br>내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링이 불가하다.</p>
<p>하지만 상수라면 관례대로 public static final 필드로 공개해도 좋다.<br>필드 명 네이밍은 관례 상 <code>대문자 + _(언더바)</code>로 구성한다.<br>그리고 반드시 불변 객체를 참조하도록 한다.<br>불변성이 깨지는 순간 어마무시한 일이 일어난다.</p>
<h1 id="클래스에서-public-static-final-배열-필드를-두지말아라"><a href="#클래스에서-public-static-final-배열-필드를-두지말아라" class="headerlink" title="클래스에서 public static final 배열 필드를 두지말아라"></a>클래스에서 public static final 배열 필드를 두지말아라</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>이런 경우 VALUES에 대한 참조를 변경할 수는 없지만, 배열내의 내용을 변경하는 것은 가능하다.</p>
<h2 id="해결책1-Thing-배열을-private로-만들고-public-불변-리스트를-추가한다"><a href="#해결책1-Thing-배열을-private로-만들고-public-불변-리스트를-추가한다" class="headerlink" title="해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다."></a>해결책1. Thing 배열을 private로 만들고 public 불변 리스트를 추가한다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure>

<h2 id="해결책2-Thing-배열을-private로-만들고-public-메서드를-추가한다"><a href="#해결책2-Thing-배열을-private로-만들고-public-메서드를-추가한다" class="headerlink" title="해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다."></a>해결책2. Thing 배열을 private로 만들고 public 메서드를 추가한다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">  <span class="keyword">return</span> PRIVATE_VALUES.clone(); <span class="comment">//방어적 복사본</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-9에-추가된-Modules-Project-Jigsaw"><a href="#Java-9에-추가된-Modules-Project-Jigsaw" class="headerlink" title="Java 9에 추가된 Modules (Project Jigsaw)"></a>Java 9에 추가된 Modules (Project Jigsaw)</h1><p>Java9 부터는 Module시스템이라는 개념이 도입 되었다.  </p>
<p>패키지는 클래스의 묶음인 것 처럼, 모듈(Modules)은 패키지의 묶음이다.<br>모듈은 관례 상, 자신이 속하는 패키지 중 공개(export) 할 것을 선언한다.<br>관례상 <strong>module-info.java</strong> 에 선언한다.<br>모듈을 정의하기 위해 3가지 정보를 작성해야 한다.</p>
<ol>
<li>module 명 - module 명칭</li>
<li>공개할 package (export)</li>
</ol>
<ul>
<li>공개한 package의 public type에 접근제한자만 외부에서 접근할 수 있다.</li>
<li>만약 export에 적지 않은 패키지의 클래스 중 public 접근제한자가 있어도 접근을 할 수 없다.</li>
</ul>
<ol start="3">
<li>module내 package의 클래스를 사용하기 위해 종속되는 package (require)</li>
</ol>
<ul>
<li>다른 모듈의 대한 require를 작성하면 다른 모듈에서 export하는 클래스의 public type에 접근이 가능하다</li>
</ul>
<h2 id="Java-8에서-접근-제한자"><a href="#Java-8에서-접근-제한자" class="headerlink" title="Java 8에서 접근 제한자"></a>Java 8에서 접근 제한자</h2><ul>
<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. </li>
<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li>
<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>
<li>public: 모든 곳에서 접근할 수 있다.</li>
</ul>
<h2 id="Java-9부터의-접근-제한자"><a href="#Java-9부터의-접근-제한자" class="headerlink" title="Java 9부터의 접근 제한자"></a>Java 9부터의 접근 제한자</h2><ul>
<li>private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. </li>
<li>package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.</li>
<li>protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.</li>
<li>모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.</li>
<li>required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.</li>
<li>export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 15. 클래스와 멤버의 접근 권한을 최소화하라</li>
<li><a target="_blank" rel="noopener" href="https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/">https://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/13/effective-java-item14/">Item 14. Comparable을 구현할지 고려하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Comparable을 구현하는 이유는 클래스의 인스턴스들간의 Ordering을 목적으로 구현하는 클래스이다.<br>따라서 Comparable을 구현한 클래스에 대한 배열은 다음처럼 손쉽게 정렬 할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br></pre></td></tr></table></figure>

<p>사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거타입은 Compareable을 구현했다.<br>알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면, 반드시 Comparable 인터페이스를 구현하자</p>
<h1 id="compareTo-메서드-규약"><a href="#compareTo-메서드-규약" class="headerlink" title="compareTo 메서드 규약"></a>compareTo 메서드 규약</h1><p>이 객체와 주어진 객체의 순서를 비교한다.<br>이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 리턴한다.<br>이 객체와 비교할 수 없는 타입이 주어지면 ClassCaseException을 던진다.</p>
<h2 id="대칭성"><a href="#대칭성" class="headerlink" title="대칭성"></a>대칭성</h2><ul>
<li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) &#x3D;&#x3D; (y.compareTo(x)) * (-1)을 만족해야 한다.</li>
<li>따라서 x.compareTo(y)가 예외를 던지는 경우, y.compareTo(x)도 예외를 던져야 한다.</li>
</ul>
<h2 id="추이성"><a href="#추이성" class="headerlink" title="추이성"></a>추이성</h2><ul>
<li>Comparable을 구현한 클래스는 모든 x, y, z에 대해 x.compareTo(y) &gt; 0 이고 y.compareTo(z)이면, x.compareTo(z)를 만족해야 한다.</li>
</ul>
<h2 id="반사성"><a href="#반사성" class="headerlink" title="반사성"></a>반사성</h2><ul>
<li>Comparable을 구현한 클래스 z는 x.compareTo(y) &#x3D;&#x3D; 0 이면, sgn(x.compareTo(z)) &#x3D;&#x3D; sgn(y.compareTo(z))를 만족해야 한다.</li>
</ul>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><ul>
<li>Comparable을 구현한 클래스는 모든 x, y에 대해 x.compareTo(y) &#x3D;&#x3D; 0 이면, x.equals(y)를 만족하는 것이 좋다. (권고사항은 아니다.)<br>이 권고를 지키지 않으려면, <code>주의: 이 클래스의 순서는 equals 메서드와 일관되지 않다.</code>라고 명시해 주자.</li>
</ul>
<h1 id="equals와-compareTo-차이점"><a href="#equals와-compareTo-차이점" class="headerlink" title="equals와 compareTo 차이점"></a>equals와 compareTo 차이점</h1><p>compareTo 규약 4번째의 예시로 BigDecimal 클래스가 있다.<br>new Decimal(“1.0”)과 new Decimal(“1.00”)이 있다고 할 때 두 객체를 HashSet<Decimal>에 담게 되면 size는 2개가 된다.<br>하지만 TreeSet<Decimal>에 담게 되면 size는 1개가 된다.  </p>
<p>왜 이런 결과가 나올까?<br>HashSet에서는 equals를 기반으로 비교하기 때문에 new Decimal(“1.0”)과 new Decimal(“1.00”)은 서로 다른 객체이다. 그렇기 때문에 size가 2개가 된다.<br>하지만 TreeSet에서는 객체에 대한 동치성 비교를 compareTo로 하기 때문에 new Decimal(“1.0”)과 new Decimal(“1.00”)의 compareTo는 0을 리턴한다.<br>따라서 같은 객체로 인식하여 size가 1개가 된다.</p>
<h1 id="compareTo-안티패턴"><a href="#compareTo-안티패턴" class="headerlink" title="compareTo 안티패턴"></a>compareTo 안티패턴</h1><p>compareTo 메서드에서 관계연산자 (<code>&lt;</code> 와 <code>&gt;</code>)를 사용하지 말아야 한다.<br>대신 Type.compare(T t1, T t2)를 사용하여 비교하는 것이 좋다.</p>
<p>안티 패턴 코드</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? <span class="number">1</span> : (x == y) ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashcode의 차를 이용한 비교는 안된다. (추이성에 위배된다.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; o1.hashCode() - o2.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드 처럼 실행하면, 정수 overflow를 일으키거나 IEEE754 부동소수점 계산방식에 따른 오류를 발생 시킬 수 있다.<br>따라서 아래 코드로 고쳐서 사용하는 것이 좋다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;() &#123;</span><br><span class="line">  (Object o1, Object o2) -&gt; Integer.compare(o1.hashCode(), o2.hashCode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure>

<h1 id="사용-예제"><a href="#사용-예제" class="headerlink" title="사용 예제"></a>사용 예제</h1><h2 id="기본-타입-필드가-여러-개-일때-비교자"><a href="#기본-타입-필드가-여러-개-일때-비교자" class="headerlink" title="기본 타입 필드가 여러 개 일때 비교자"></a>기본 타입 필드가 여러 개 일때 비교자</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhoneNumber pn)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Short.compare(<span class="built_in">this</span>.areaCode, pn.areaCode);</span><br><span class="line">  <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">    result = Short.compare(<span class="built_in">this</span>.prefix, pn.prefix);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">      result = Short.compare(<span class="built_in">this</span>.line</span><br><span class="line">      Num, pn.lineNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>필드의 정렬 우선순위를 정해 같은 값이 있을 때 마다 조건을 추가한다.</p>
<h2 id="비교자-생성-메서드를-이용한-비교자"><a href="#비교자-생성-메서드를-이용한-비교자" class="headerlink" title="비교자 생성 메서드를 이용한 비교자"></a>비교자 생성 메서드를 이용한 비교자</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR </span><br><span class="line">                        = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class="line">                                      .thenComparingInt(pn -&gt; pn.lineNum)</span><br></pre></td></tr></table></figure>
<p>comparingInt라는 static 메서드를 import하여 사용하고, 2번째 조건 부터 thenComparingInt를 사용하여 비교자를 추가 할 수 있다.<br>최초 사용 시, PhoneNumber pn을 사용하여 람다식에서 타입을 추론 할 수 있도록 코드를 추가 하였다.<br>thenComparingInt부터는 자바 컴파일러가 충분히 타입을 추론 할 수 있으므로 명시적으로 지정하지 않았다.<br>Long타입과 Double타입에 대해서는 각각 comparingLong, thenComparingLong과 comparingDouble, thenComparingDouble이 별도로 있다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 14. Comparable을 구현할지 고려하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/13/java-object-copy/">Shallow Copy와 Deep Copy</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="객체의-복사-Copy"><a href="#객체의-복사-Copy" class="headerlink" title="객체의 복사(Copy)"></a>객체의 복사(Copy)</h1><p>객체 지향 프로그래밍에서 객체를 복사하는 방법은 크게 두가지로 나뉜다.<br>얇은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있다.<br>두가지 개념 모두 원본 객체를 바탕으로 새로운 객체를 만들어 낸다는 점에서는 같지만 미묘한 차이가 있다.</p>
<p>설명을 진행하기 전에 아래와 같은 Interface를 구현한 객체에 대해 copy가 진행된다고 가정하겠다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Copyable</span>&lt;T&gt; &#123;</span><br><span class="line">   T <span class="title function_">shallowCopy</span><span class="params">(T t)</span>;</span><br><span class="line">   T <span class="title function_">deepCopy</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="./clone.jpg" alt="clone"></p>
<h1 id="Shallow-Copy"><a href="#Shallow-Copy" class="headerlink" title="Shallow Copy"></a>Shallow Copy</h1><p>Shallow copy란 원본 객체를 바탕으로 새로운 객체를 생성한 뒤, 내부 필드의 참조에 대해서는 원본 객체와 같은 필드의 참조를 바라보는 형태이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">implements</span> <span class="title class_">Copyable</span>&lt;Menu&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Menu <span class="title function_">shallowCopy</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">    <span class="type">Menu</span> <span class="variable">copyMenu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(menu.getName(), menu.getPrice(), menu.getRecipe());</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>불변 객체에 대해서는 같은 객체를 공유한다는 점에서 메모리에 대한 비용을 아낄 수 있다는 장점이 있고, deep copy보다는 빠르다.</p>
<p>하지만, 가변 객체에 대해서는 원본 객체의 Recipe 객체가 변경되는 경우 의도치 않게 복사한 Recipe도 변경되는 경우가 발생한다.<br>이런 경우에는 Deep Copy를 통해 완전히 분리를 시켜줘야 한다.</p>
<h1 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h1><p>Deep Copy 원본 객체의 타입을 바탕으로 새로운 객체를 생성한 뒤, 내부 필드가 참조하는 객체에 대해서도 새로운 객체를 만들어 주는 방식이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">implements</span> <span class="title class_">Copyable</span>&lt;Menu&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line">  <span class="keyword">private</span> Recipe recipe;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Menu <span class="title function_">deepCopy</span><span class="params">(Menu menu)</span> &#123;</span><br><span class="line">    <span class="type">Menu</span> <span class="variable">copyMenu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>();</span><br><span class="line">    copyMenu.setName(<span class="keyword">new</span> <span class="title class_">String</span>(menu.getName));</span><br><span class="line">    copyMenu.setPrice(menu.getPrice());</span><br><span class="line">    copyMenu.setRecipe(Recipe.deepCopy(menu.getRecipe));</span><br><span class="line">    <span class="keyword">return</span> copyMenu;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 필드에 대해 원본객체와 같은 reference를 사용하는 것이 아닌 필드의 reference에 대해서도 새로운 객체를 생성하여 복사하는 방식이다.  </p>
<p>이런 경우 가변객체에 대한 변경에는 안전하다는 장점이 있다.<br>서로 다른 객체를 다루기 떄문에 안전하다.  </p>
<p>하지만 객체 생성 비용이 shallow copy보다 비싸고 상대적으로 느리며,<br>copy하는 객체 수가 많을 수록 메모리를 많이 점유하게 된다는 단점이 있다.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/13/effective-java-item13/">Item 13. Clone 재정의는 주의해서 진행하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Cloneable은 복제해도 되는 인터페이스 임을 명시하는 용도의 믹스인 인터페이스이다.<br>하지만 아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는데 있다. 그래서 Cloneable을 구현하는 것만으로는 외부에서 clone 메서드를 호출 할 수 없다.</p>
<h1 id="Cloneable-인터페이스는-무슨일을-할까"><a href="#Cloneable-인터페이스는-무슨일을-할까" class="headerlink" title="Cloneable 인터페이스는 무슨일을 할까?"></a>Cloneable 인터페이스는 무슨일을 할까?</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class="line"><span class="comment"> * is legal for that method to make a</span></span><br><span class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Invoking Object&#x27;s clone method on an instance that does not implement the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object.clone&#125; (which is protected) with a public method.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class="line"><span class="comment"> * method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;<span class="doctag">@code</span> clone&#125; method.</span></span><br><span class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자바의 Cloneable 인터페이스를 보면 아무런 메서드도 없다.<br>아무것도 없지만, 사실은 Object의 clone메서드의 동작방식을 결정한다.<br>Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면, 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면, <code>ClassNotSupportedException</code>을 던진다.</p>
<h1 id="Object-클래스의-clone-규약"><a href="#Object-클래스의-clone-규약" class="headerlink" title="Object 클래스의 clone 규약"></a>Object 클래스의 clone 규약</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment"> * of &quot;copy&quot; may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment"> * intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment"> * While it is typically the case that:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment"> * it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment"> * by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal &quot;deep structure&quot;</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment"> * primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment"> * the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment"> * need to be modified.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class="line"><span class="comment"> * are considered to implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125; and that</span></span><br><span class="line"><span class="comment"> * the return type of the &#123;<span class="doctag">@code</span> clone&#125; method of an array type &#123;<span class="doctag">@code</span> T[]&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class="line"><span class="comment"> * Otherwise, this method creates a new instance of the class of this</span></span><br><span class="line"><span class="comment"> * object and initializes all its fields with exactly the contents of</span></span><br><span class="line"><span class="comment"> * the corresponding fields of this object, as if by assignment; the</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment"> * whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment"> * exception at run time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     a clone of this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  CloneNotSupportedException  if the object&#x27;s class does not</span></span><br><span class="line"><span class="comment"> *               support the &#123;<span class="doctag">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class="line"><span class="comment"> *               that override the &#123;<span class="doctag">@code</span> clone&#125; method can also</span></span><br><span class="line"><span class="comment"> *               throw this exception to indicate that an instance cannot</span></span><br><span class="line"><span class="comment"> *               be cloned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Cloneable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>

<p>Object에 명시된 clone 규약이 주석으로 쓰여져 있다.</p>
<ul>
<li>x.clone() !&#x3D; x은 참이다.<br>복사한 객체와 원본 객체는 서로 다른 객체이다.</li>
<li>x.clone() .getClass() &#x3D;&#x3D; x.getClass()은 일반적으로 참이다.<br>하지만 반드시 만족해야 하는 것은 아니다.</li>
<li>x.clone.equals(x) 은 참이다.<br>복사한 객체와 원본객체는 논리적 동치성이 같다.</li>
<li>x.clone().getClass() &#x3D;&#x3D; x.getClass()은 참이다.<br>관례상, 이 방법으로 반환된 객체는 독립성이 있어야 한다.<br>이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.</li>
<li>Cloneable을 구현하지 않은 클래스의 경우, CloneNotSupportedException이 throw된다.</li>
<li>모든 Array는 Cloneable을 구현하도록 고려되었다. clone 메서드는 T[]를 리턴하도록 설계</li>
<li>T는 기본타입 또는 참조타입으로 설계</li>
<li>기본적으로 Object.clone은 clone대상 클래스에 대해 새로운 객체를 new로 생성</li>
<li>모든 필드들에 대해 초기화를 진행</li>
<li>하지만 필드에 대한 객체를 다시 생성하지 않는 Shallow copy 방식으로 수행한다 (deep copy아님)</li>
<li>클래스에 대한 복제본을 원하지 않는 경우 clone메서드를 재정의하여 CloneNotSupportedException을 throw하도록 함</li>
</ul>
<h1 id="clone-메서드-재정의-시-주의할-점"><a href="#clone-메서드-재정의-시-주의할-점" class="headerlink" title="clone 메서드 재정의 시, 주의할 점"></a>clone 메서드 재정의 시, 주의할 점</h1><h2 id="기본적인-clone메서드-재정의"><a href="#기본적인-clone메서드-재정의" class="headerlink" title="기본적인 clone메서드 재정의"></a>기본적인 clone메서드 재정의</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> PhoneNumber <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (PhoneNumber) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotSupportedException e) &#123;</span><br><span class="line">      <span class="comment">//아무처리를 하지 않거나, RuntimeException으로 감싸는 것이 사용하기 편하다.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>super.clone()을 실행하면 PhoneNumber에 대한 완벽한 복제가 이루어진다.</li>
<li>super.clone()의 리턴 타입은 Object이지만, 자바의 공변 반환타이핑 기능을 통해 PhoneNumber 타입으로 캐스팅하여 리턴하는 것이 가능하다.<br>(추천하는 기능)</li>
<li>try-catch 부분으로 감싼것은 super.clone() 메서드에서 ClassNotSupportedException이라는 checked exception을 리턴하기 떄문에 처리 해주었다. <ul>
<li>하지만 PhoneNumber가 Cloneable을 구현하기 떄문에 절대 실패하지 않는다.<br>따라서 이부분은 RuntimeException으로 처리하거나, 아무것도 설정하지 않아야 한다.</li>
</ul>
</li>
</ul>
<h2 id="가변-상태를-갖는-필드에-대한-복제"><a href="#가변-상태를-갖는-필드에-대한-복제" class="headerlink" title="가변 상태를 갖는 필드에 대한 복제"></a>가변 상태를 갖는 필드에 대한 복제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object o)</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Stack <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Stack</span> <span class="variable">result</span> <span class="operator">=</span> (Stack) <span class="built_in">super</span>.clone();</span><br><span class="line">      result.elements = </span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 클래스가 단순히 clone메서드를 이용해 super.clone()만 실행하게 된다면,<br>new Stack()을 통해 새로운 객체가 생성되고 필드모두 원본 객체와 동일하게 초기화가 될 것이다.<br>하지만, 위에서 얘기한 Object의 clone 기본규약에는 Deep copy가 아닌 Shallow Copy를 이용해 초기화를 진행한다고 적혀있다.<br>따라서 배열과 같은 가변필드는 원본 필드와 객체를 공유하게 된다. </p>
<p>Clone메서드는 사실상 생성자와 같은 효과를 낸다.<br>즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.<br>그렇기 때문에 제대로 복제하기 위해서는, elements라는 배열을 똑같이 복사해서 만들어줘야 한다.</p>
<h2 id="배열-복사"><a href="#배열-복사" class="headerlink" title="배열 복사"></a>배열 복사</h2><p>배열을 복제하는 방법 중 가장 권장하는 방법은<br>array.clone()을 이용해 복사하는 방법이다.<br>사실, 배열은 clone기능을 가장 제대로 사용하는 유일한 예이다.</p>
<p>하지만, array 필드가 final이 적용되어 있다면 array.clone()을 통한 초기화는 할 수 없다. (final이기 떄문에 객체 생성 이후 초기화 불가)<br><strong>Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다.</strong><br>그래서 복제 할 수 있는 클래스를 만들기 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.</p>
<h2 id="Stack-overflow-문제"><a href="#Stack-overflow-문제" class="headerlink" title="Stack overflow 문제"></a>Stack overflow 문제</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>  &#123;</span><br><span class="line">  <span class="keyword">private</span> Entry[] buckets = ...;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object key;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry next;</span><br><span class="line"></span><br><span class="line">    Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> HashTable <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">HashTable</span> <span class="variable">result</span> <span class="operator">=</span> (HashTable) <span class="built_in">super</span>.clone();</span><br><span class="line">      result.buckets = buckets.clone();</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Assertion</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>복제본은 자신만의 버킷 배열은 갖지만, 배열내의 Entry는 원본과 같은 연결리스트를 참조하여, 불변성이 꺠지게 된다.</p>
<p>그래서 HashTable.Entry 클래스는 내부적으로 deep copy를 지원하도록 보강되었다. 연결리스트에 대한 next를 복제할 때 재귀적으로 clone을 호출하도록 되어있는데, 재귀 호출 떄문에 연결리스트의 size만큼 스택프레임을 소비하여, 리스트가 길면 stackoverflow에러를 발생시킬 위험이 있다.<br>이 문제를 해결하기 위해서는 재귀 호출을 통한 deepcopy대신 반복자를 써서 순회하는 방법으로 수정해야 한다.</p>
<h2 id="안전하지만-느린-copy"><a href="#안전하지만-느린-copy" class="headerlink" title="안전하지만 느린 copy"></a>안전하지만 느린 copy</h2><p>HashTable을 예로 들면, buckets필드를 새로운 배열로 초기화 한다음 원본테이블의 있는 버킷의 내용을 put(key, value) 메서드를 호출해<br>새로 버킷을 만드는 방법이 있다.<br>이 방법은 안전하긴 하지만, low level에서 작동하는 copy보다는 느리다.</p>
<h2 id="생성자-내에서는-재정의-될-수-있는-메서드를-호출-하지-말자"><a href="#생성자-내에서는-재정의-될-수-있는-메서드를-호출-하지-말자" class="headerlink" title="생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자"></a>생성자 내에서는 재정의 될 수 있는 메서드를 호출 하지 말자</h2><p>만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복사과정에서 자신의 상태를 교정할 기회를 잃게되어<br>원본과 복제본의 상태가 달라질 수 있다.</p>
<h2 id="ClassNotSupportedException"><a href="#ClassNotSupportedException" class="headerlink" title="ClassNotSupportedException"></a>ClassNotSupportedException</h2><p>Object의 clone메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않다.<br>public인 clone 메서드에서는 throws절을 없애던가, RuntimeException으로 throws 해야한다.<br>그렇지 않으면 clone 메서드를 호출 할 떄마다, 예외처리를 해야 해서 사용하기가 불편하다.</p>
<p>하위 클래스에서 Clone을 방지하기 위해 동작하지 않게 만들수도 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="스레드-안전성을-고려한다면-적절히-동기화해야-한다"><a href="#스레드-안전성을-고려한다면-적절히-동기화해야-한다" class="headerlink" title="스레드 안전성을 고려한다면 적절히 동기화해야 한다."></a>스레드 안전성을 고려한다면 적절히 동기화해야 한다.</h2><p>스레드 안정성을 고려한다면 clone 메서드에 대해 적절히 동기화 처리 해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="복사-생성자와-복사-팩터리-메서드"><a href="#복사-생성자와-복사-팩터리-메서드" class="headerlink" title="복사 생성자와 복사 팩터리 메서드"></a>복사 생성자와 복사 팩터리 메서드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Yum</span><span class="params">(Yum yum)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Yum <span class="title function_">newInstance</span><span class="params">(Yum yum)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>복사 생성자와 복사 팩터리 메서드는 Cloneable&#x2F;clone 방식보다 나은 면이 많다. </p>
<ul>
<li>언어 모순적이고 위험한 객체 생성 메커니즘을 사용하지 않는다. (super.clone())</li>
<li>clone 규약에 기대지 않는다.</li>
<li>정상적인 final필드 용법과도 충돌하지 않는다.</li>
<li>불필요한 check exception 처리가 필요없다.</li>
<li>형변환도 필요없다.</li>
<li>복사 생성자와 복사 팩터리는 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.</li>
</ul>
<h1 id="Deep-copy-vs-Shallow-copy"><a href="#Deep-copy-vs-Shallow-copy" class="headerlink" title="Deep copy vs Shallow copy"></a>Deep copy vs Shallow copy</h1><p><a target="_blank" rel="noopener" href="http://localhost:4000/2019/01/13/java-object-copy">Shallow Copy와 Deep Copy</a> - 이 포스팅을 참고하자</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 13. clone 재정의는 주의해서 진행하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/13/effective-java-item12/">Item 12. toString을 항상 재정의하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.<br>이 메서드는 <code>PhoneNumber@adbbd</code>처럼 단순히 <strong>클래스이름@16진수로_표현한_해시코드</strong>를 반환할 뿐이다.<br>toString의 일반 규약에 따르면, <code>간결하면서 사람이 읽기 쉬운 형태의 유익한 정보</code>를 반환해야 한다.<br>toString의 규악은 <code>모든 하위클래스에서 이 메서드를 재정의하라</code>라고 하고 있다.</p>
<h1 id="toString을-재정의-해야하는-이유"><a href="#toString을-재정의-해야하는-이유" class="headerlink" title="toString을 재정의 해야하는 이유"></a>toString을 재정의 해야하는 이유</h1><ul>
<li>toString을 잘 구현한 클래스는 사용하기 편하고, 그 클래스에 대해 디버깅 하기 쉽다.<ul>
<li>map객체를 출력하는 경우 <code>&#123;Jenny=PhoneNumber@addbb&#125;</code> 보다는 <code>&#123;Jenney=707-867-5308&#125;</code>이라는 메세지가 가독서이 좋다.</li>
</ul>
</li>
<li>실전에서는 toString메서드를 재작성 할 때, 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.</li>
<li>toString을 구현할 때면 반환값의 포맷을 문서화 할 지 정해야 한다.<ul>
<li>포맷을 명시하면, 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li>
<li>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</li>
<li>단, 포맷을 한번 명시하면, 평생 그 포맷에 얽매이게 된다.</li>
<li>포맷을 명시하지 않는다면 다음 릴리즈에 포맷을 변경할 수 있는 유연성을 더 가져갈 수 있다.</li>
</ul>
</li>
<li>포맷을 명시하든 아니든, 개발자의 의도는 명확히 밝혀야 한다.</li>
<li>toString이 반환한 값에 대해 포함된 정보를 얻어올 수 있는 API를 제공하자<ul>
<li>toString에 있는 getter를 제공하지 않는다면, 클라이언트에서 toString을 파싱하여 사용할 지도 모른다.</li>
</ul>
</li>
</ul>
<h2 id="포맷을-명시하기로-했으면-명시한-포맷에-맞는-문자열과-객체를-상호전환-할-수-있는-정적-팩터리나-생성자를-함께-제공하면-좋다"><a href="#포맷을-명시하기로-했으면-명시한-포맷에-맞는-문자열과-객체를-상호전환-할-수-있는-정적-팩터리나-생성자를-함께-제공하면-좋다" class="headerlink" title="포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다."></a>포맷을 명시하기로 했으면, 명시한 포맷에 맞는 문자열과 객체를 상호전환 할 수 있는 정적 팩터리나 생성자를 함께 제공하면 좋다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RunWith(JUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> toString테스트() &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="string">&quot;707-908-9999&quot;</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">908</span>, <span class="number">9999</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(expected = UnknownFormatConversionException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 파싱문자열_오류_테스트() &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="string">&quot;707-908&quot;</span>;</span><br><span class="line">        assertEquals(PhoneNumber.parse(phoneNumber), <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">908</span>, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer areaCode;</span><br><span class="line">        <span class="keyword">private</span> Integer prefix;</span><br><span class="line">        <span class="keyword">private</span> Integer lineNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">phoneNumberPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;$&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">PhoneNumber</span> <span class="variable">pn</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.areaCode.equals(pn.areaCode)</span><br><span class="line">                    &amp;&amp; <span class="built_in">this</span>.prefix.equals(pn.prefix)</span><br><span class="line">                    &amp;&amp; <span class="built_in">this</span>.lineNum.equals(pn.lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.hashCode(areaCode);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(prefix);</span><br><span class="line">            result = <span class="number">31</span> * result + Integer.hashCode(lineNum);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%03d-%03d-%04d&quot;</span>, areaCode, prefix, lineNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> PhoneNumber <span class="title function_">parse</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!phoneNumberPattern.matcher(phoneNumber).find()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownFormatConversionException</span>(phoneNumber + <span class="string">&quot; cannot be parsed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] numbers = phoneNumber.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> PhoneNumber.builder()</span><br><span class="line">                    .areaCode(Integer.parseInt(numbers[<span class="number">0</span>]))</span><br><span class="line">                    .prefix(Integer.parseInt(numbers[<span class="number">1</span>]))</span><br><span class="line">                    .lineNum(Integer.parseInt(numbers[<span class="number">2</span>]))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="toString을-따로-재정의-안해도-되는-경우"><a href="#toString을-따로-재정의-안해도-되는-경우" class="headerlink" title="toString을 따로 재정의 안해도 되는 경우"></a>toString을 따로 재정의 안해도 되는 경우</h1><ul>
<li>정적 Utils 클래스는 따로 재정의 하지 않아도 된다.<br>(객체의 상태(state)를 가지는 클래스가 아니기 떄문)</li>
<li>enum 타입 또한 이미 완벽한 toString을 제공한다.</li>
<li>대다수의 컬렉션 구현체는 추상 컬렉션 클래스(AbstractMap, AbstractSet등)의 toString 메서드를 상속하여 쓴다.</li>
<li>라이브러리를 통해 자동생성하자<ul>
<li>구글의 @Autovalue</li>
<li>Lombok의 @ToString</li>
<li>위의 라이브러리들을 이용해 자동생성하는 편이 더 간편하다.</li>
</ul>
</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 12. toString을 항상 재정의하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/12/effective-java-item11/">Item 11. Equals를 재정의하려거든 Hashcode도 재정의하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-12</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p><code>equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.</code><br>그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.</p>
<p>이번 글을 읽기 전에 아래 글을 먼저 읽어 해시, 해시테이블에 대한 용어를 먼저 익히는 것이 도움이 될 것 같다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://bcho.tistory.com/1072">해쉬 테이블의 이해와 구현 (Hashtable) - 조대협의 블로그</a></li>
<li><a target="_blank" rel="noopener" href="https://d2.naver.com/helloworld/831311">Java HashMap은 어떻게 동작하는가? - Naver D2</a></li>
</ul>
<h1 id="hashcode의-규약"><a href="#hashcode의-규약" class="headerlink" title="hashcode의 규약"></a>hashcode의 규약</h1><ul>
<li>equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.<br>(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))</li>
<li>equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.</li>
<li>equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision)<br>단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.</li>
</ul>
<h1 id="equals-메서드는-재정의했지만-hashcode를-재정의하지-않은-경우"><a href="#equals-메서드는-재정의했지만-hashcode를-재정의하지-않은-경우" class="headerlink" title="equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우"></a>equals 메서드는 재정의했지만, hashcode를 재정의하지 않은 경우</h1><p>hashcode의 규약 2번째 조건을 위반하는 행위이다.<br>Effective Java 11장에서 설명하는 PhoneNumber 클래스를 생성해 테스트 해 보았다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(JUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCodeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의() &#123;</span><br><span class="line">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 1 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 2 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        Assert.assertEquals(map.get(<span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>)), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의안함() &#123;</span><br><span class="line">        HashMap&lt;PhoneNumber, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 1 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 2 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        Assert.assertNotEquals(map.get(<span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>)), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> firstNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> secondNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> thirdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">PhoneNumber</span> <span class="variable">p</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class="line">                    <span class="built_in">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class="line">                    <span class="built_in">this</span>.thirdNumber == p.thirdNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtendedPhoneNumber</span> <span class="keyword">extends</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ExtendedPhoneNumber</span><span class="params">(<span class="type">int</span> firstNumber, <span class="type">int</span> secondNumber, <span class="type">int</span> thirdNumber)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hashcode</span> <span class="operator">=</span> Integer.hashCode(firstNumber);</span><br><span class="line">            hashcode = c * hashcode + Integer.hashCode(secondNumber);</span><br><span class="line">            hashcode = c * hashcode + Integer.hashCode(thirdNumber);</span><br><span class="line">            <span class="keyword">return</span> hashcode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Test-1-hashcode를-재정의-하지-않은-경우"><a href="#Test-1-hashcode를-재정의-하지-않은-경우" class="headerlink" title="Test.1 hashcode를 재정의 하지 않은 경우"></a>Test.1 hashcode를 재정의 하지 않은 경우</h2><p>PhoneNumber 클래스에서는 객체 동치성 체크를 위해 equals메서드를 재정의했다. <strong>하지만 hashcode 메서드는 재정의 하지 않았다.</strong><br>new를 통해 새로운 객체를 만들 때마다 늘 다른 hashcode를 리턴하여, 실제 HashMap에 key로 PhoneNumber클래스를 삽입하더라도<br>hashcode가 다르기 때문에 다른 버킷에가서 데이터를 조회 하려고해서 결과적으로 null이 나와 기댓값인 <code>&quot;제니&quot;</code>를 만족하지 못했다. </p>
<p>실제 로그를 찍어보니</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 1686369710</span><br><span class="line">Instance 2 hashcode : 194706439</span><br></pre></td></tr></table></figure>
<p>두 개의 다른 객체에 대해 다른 hashcode를 리턴하고 있었다.</p>
<h2 id="Test-2-hashcode를-재정의-한-경우"><a href="#Test-2-hashcode를-재정의-한-경우" class="headerlink" title="Test.2 hashcode를 재정의 한 경우"></a>Test.2 hashcode를 재정의 한 경우</h2><p>ExtendPhoneNumber 클래스에서는 PhoneNumber를 상속 받은 뒤, hashCode 메서드를 재정의하였다.<br>(equals메서드는 PhoneNumber의 equals를 그대로 사용하였다.) </p>
<p>실제 로그를 찍어보니</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 711611</span><br><span class="line">Instance 2 hashcode : 711611</span><br></pre></td></tr></table></figure>
<p>두 개의 ExtendPhoneNumber 객체에 대해 같은 hashcode를 리턴하고 있었다.<br>그렇기 때문에 HashMap에 삽입한 ExtendPhoneNumber 객체에 대해 new ExtendPhoneNumber()로 조회를 하니 같은 hashCode의 버킷을 조회하여<br><code>&quot;제니&quot;</code>라는 데이터를 얻어올 수 있었다.</p>
<h1 id="최악의-hashcode-구현"><a href="#최악의-hashcode-구현" class="headerlink" title="최악의 hashcode 구현"></a>최악의 hashcode 구현</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법한 해시코드 처럼 보인다.<br>하지만, 모든 객체에 대해 똑같은 해시코드를 반환하니 모든 객체가 같은 해시테이블 버킷에 담겨 연결리스트(Linked List)처럼 동작하게 된다.<br>평균 수행시간이 O(1)에서 O(n)으로 느려져서, 성능이 매우 낮아질 뿐더러 버킷에 대한 overflow가 발생하는 경우 데이터가 누락될 수도 있다.</p>
<h2 id="hashcode가-같으면-HashMap에서-어떻게-동작할까"><a href="#hashcode가-같으면-HashMap에서-어떻게-동작할까" class="headerlink" title="hashcode가 같으면 HashMap에서 어떻게 동작할까?"></a>hashcode가 같으면 HashMap에서 어떻게 동작할까?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(JUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCodeTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> hashcode_재정의() &#123;</span><br><span class="line">        HashMap&lt;ExtendedPhoneNumber, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 1 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5307</span>).hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Instance 2 hashcode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5301</span>).hashCode());</span><br><span class="line">        <span class="comment">//다른 객체를 넣어 데이터를 조회해 보았다.</span></span><br><span class="line">        Assert.assertEquals(map.get(<span class="keyword">new</span> <span class="title class_">ExtendedPhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5301</span>)), <span class="string">&quot;제니&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> firstNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> secondNumber;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> thirdNumber;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">PhoneNumber</span> <span class="variable">p</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstNumber == p.firstNumber &amp;&amp;</span><br><span class="line">                    <span class="built_in">this</span>.secondNumber == p.secondNumber &amp;&amp;</span><br><span class="line">                    <span class="built_in">this</span>.thirdNumber == p.thirdNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtendedPhoneNumber</span> <span class="keyword">extends</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ExtendedPhoneNumber</span><span class="params">(<span class="type">int</span> firstNumber, <span class="type">int</span> secondNumber, <span class="type">int</span> thirdNumber)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(firstNumber, secondNumber, thirdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instance 1 hashcode : 42</span><br><span class="line">Instance 2 hashcode : 42</span><br><span class="line"></span><br><span class="line">java.lang.AssertionError: </span><br><span class="line">Expected :null</span><br><span class="line">Actual   :제니</span><br><span class="line"> &lt;Click to see difference&gt;</span><br></pre></td></tr></table></figure>

<p>이 결과로 보아하니, hashcode가 같으면 같은 버킷에 LinkedList로 저장되면서 객체에 대해 equals 체크를 통해 데이터를 조회하는 것으로 판단 된다.</p>
<blockquote>
<p>설사 두 인스턴스가 같은 버킷에 담았더라도, hashmap.get메서드는 null을 반환한다.<br>만약 hashcode가 다른경우에는 동치성비교를 실행하지 않도록 최적화 되어있기 때문이다.<br>hashcode가 같더라도 동치성비교(equals)를 실행하여 객체에 대한 값(value)를 조회한다.</p>
</blockquote>
<h1 id="좋은-해시-함수-만들기"><a href="#좋은-해시-함수-만들기" class="headerlink" title="좋은 해시 함수 만들기"></a>좋은 해시 함수 만들기</h1><p>좋은 해시 함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다.<br>이게 바로 hashcode의 세번째 규약이 요구하는 속성이다.<br>이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="comment">//1. int변수 result를 선언한 후 첫번째 핵심 필드에 대한 hashcode로 초기화 한다.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.hashCode(firstNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 기본타입 필드라면 Type.hashCode()를 실행한다</span></span><br><span class="line">    <span class="comment">//Type은 기본타입의 Boxing 클래스이다.</span></span><br><span class="line">    result = c * result + Integer.hashCode(secondNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 참조타입이라면 참조타입에 대한 hashcode 함수를 호출 한다.</span></span><br><span class="line">    <span class="comment">//4. 값이 null이면 0을 더해 준다.</span></span><br><span class="line">    result = c * result + address == <span class="literal">null</span> ? <span class="number">0</span> : address.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 필드가 배열이라면 핵심 원소를 각각 필드처럼 다룬다.</span></span><br><span class="line">    <span class="keyword">for</span> (String elem : arr) &#123;</span><br><span class="line">      result = c * result + elem == <span class="literal">null</span> ? <span class="number">0</span> : elem.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 배열의 모든 원소가 핵심필드이면 Arrays.hashCode를 이용한다.</span></span><br><span class="line">    result = c * result + Arrays.hashCode(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. result = 31 * result + c 형태로 초기화 하여 </span></span><br><span class="line">    <span class="comment">//result를 리턴한다.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>hashcode를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 TestCase를 작성해보자</li>
<li>파생필드는 hashcode 계산에서 제외해도 된다.</li>
<li>equals 비교에 사용되지 않는 필드는 반드시 제외한다.</li>
<li>31 * result를 곱하는 순서에 따라 result 값이 달라진다.</li>
<li>곱할 숫자를 31로 지정하는 이유는 31이 홀수 이면서 소수(prime)이기 때문이다. 2를 곱하는 것은 shift연산과 같은 결과를 내기 떄문에 추천하지 않는다.</li>
<li>31을 이용하면 (i &lt;&lt; 5) - i와 같이 최적화 할 수 있다.</li>
</ul>
<h1 id="hashcode를-편하게-만들어-주는-모듈"><a href="#hashcode를-편하게-만들어-주는-모듈" class="headerlink" title="hashcode를 편하게 만들어 주는 모듈"></a>hashcode를 편하게 만들어 주는 모듈</h1><ul>
<li>Objects.hash()<ul>
<li>내부적으로 AutoBoxing이 일어나 성능이 떨어진다.</li>
</ul>
</li>
<li>Lombok의 @EqualsAndHashCode</li>
<li>Google의 @AutoValue</li>
</ul>
<h1 id="hashcode를-재정의-할-때-주의-할-점"><a href="#hashcode를-재정의-할-때-주의-할-점" class="headerlink" title="hashcode를 재정의 할 때 주의 할 점!"></a>hashcode를 재정의 할 때 주의 할 점!</h1><ul>
<li>불변 객체에 대해서는 hashcode 생성비용이 많이 든다면, hashcode를 캐싱하는 것도 고려하자<ul>
<li>스레드 안전성까지 고려해야 한다.</li>
</ul>
</li>
<li>성능을 높인답시고 hashcode를 계산할 떄 핵심필드를 생략해서는 안된다.<ul>
<li>속도는 빨라지겠지만, hash품질이 나빠져 해시테이블 성능을 떨어뜨릴 수 있다 (Hashing Collision)</li>
</ul>
</li>
<li>hashcode 생성규칙을 API사용자에게 공표하지 말자<ul>
<li>그래야 클라이언트가 hashcode값에 의지한 코드를 짜지 않는다.</li>
<li>다음 릴리즈 시, 성능을 개선할 여지가 있다.</li>
</ul>
</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 11. equals를 재정의하려거든 hashcode도 재정의하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/10/effective-java-item10/">Item 10. Equals는 일반 규약을 지켜 재정의하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>equals 메서드는 Object 클래스에 구현된 메서드로 객체 내의 정보들에 대한 동등성(equality) 비교를 목적으로 하는 메서드이다.<br>equals 메서드를 잘못 작성하게 되면 의도하지 않는 결과들이 초래되므로 웬만하면 변경하지 않는 것이 좋다.</p>
<h1 id="equals를-재정의-하지-않아도-되는-경우"><a href="#equals를-재정의-하지-않아도-되는-경우" class="headerlink" title="equals를 재정의 하지 않아도 되는 경우"></a>equals를 재정의 하지 않아도 되는 경우</h1><ul>
<li>각 인스턴스가 본질적으로 고유 한 경우 - 값이 아닌 동작을 표현하는 클래스의 경우 (Thread가 좋은 예이다.)</li>
<li>인스턴스의 논리적 동치성 (Logical Equality)를 검사할 일이 없는 경우 - <code>java.utils.regex.Pattern</code>의 equals는 내부의 정규표현식이 같은지를 검사하는 메서드이다.</li>
<li>상위 클래스에서 재정의한 equals가 하위 클래스에서도 적용 되는 경우 - Set, Map, List의 경우 Abstract(Type)의 equals를 쓴다.</li>
<li>클래스가 private이거나, package-private여서 equals를 호출할 일이 없는 경우</li>
<li>싱글턴을 보장하는 클래스(인스턴스 통제 클래스, Enum (열거타입)) 인 경우 - 객체 간 동등성, 동일성이 보장된다.</li>
</ul>
<h1 id="equals를-재정의-하는-경우-지켜야-할-규약"><a href="#equals를-재정의-하는-경우-지켜야-할-규약" class="headerlink" title="equals를 재정의 하는 경우 지켜야 할 규약"></a>equals를 재정의 하는 경우 지켜야 할 규약</h1><p>equals를 재정의 해야 하는 경우는 객체 동일성(식별성(Object Identity))를 확인해야 하는 경우가 아니라<br>논리적 동치성(동등성(Logical equality))를 비교 하도록 재정의 되지 않았을 경우이다.</p>
<h2 id="반사성-reflexivity"><a href="#반사성-reflexivity" class="headerlink" title="반사성(reflexivity)"></a>반사성(reflexivity)</h2><p><strong>null이 아닌 모든 참조 값 x에 대해 x.equals(x)를 만족해야한다.</strong><br>단순히 말하면 객체는 자기 자신과 비교했을 때 같아야 한다는 뜻이다.<br>이 조건을 만족하지 않는 예를 찾기가 더 어렵다.<br>만약 x.equals(x)가 성립하지 않는 객체라면, 컬렉션에서 contain 메서드를 사용하는 경우 방금 넣은 객체도 찾을 수 없을 것이다.</p>
<h2 id="대칭성-symmetry"><a href="#대칭성-symmetry" class="headerlink" title="대칭성 (symmetry)"></a>대칭성 (symmetry)</h2><p><strong>null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면, y.equals(x)가 true를 만족해야 한다.</strong>  </p>
<p>예시 코드를 보면</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CaseInsensitiveString</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CaseInsensitiveString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.s = Objects.requireNonNull(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> CaseInsensitiveString) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String) &#123; <span class="comment">//한 방향으로만 작동!!</span></span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 클래스를 기반으로 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CaseInsensitiveString</span> <span class="variable">caseInsensitiveString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaseInsensitiveString</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">System.out.println(caseInsensitiveString.equals(test)); <span class="comment">//true</span></span><br><span class="line">System.out.println(test.equals(caseInsensitiveString)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>위의 코드를 실행하게 되면, x.equals(y)가 true일 때, y.equals(x)가 false이므로 <code>대칭성</code>이 깨지는 코드가 된다.<br>String 클래스에서는 CaseInsensitiveString의 존재를 모르기 때문에 false가 날 수 밖에 없는 상황이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">CaseInsensitiveString</span>(<span class="string">&quot;Test&quot;</span>));</span><br><span class="line">System.out.println(list.contain(<span class="string">&quot;test&quot;</span>)); <span class="comment">//false or true</span></span><br></pre></td></tr></table></figure>
<p>위의 예제의 경우는 JDK버전에 따라 다를 수 있다. x.equals(y)로 비교할 수 도 있고, y.equals(x)로 비교될 수 있기 때문이다.</p>
<p>위의 내용을 수정한다면, String과의 비교는 포기해야 한다.<br>같은 CaseInsensitiveString 타입인 경우에만 비교하도록 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="추이성-transitivity"><a href="#추이성-transitivity" class="headerlink" title="추이성 (transitivity)"></a>추이성 (transitivity)</h2><p><strong>null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)가 true이면 x.equals(z)도 true가 되야 한다는 조건이다.</strong></p>
<p>Point클래스와 ColorPoint 클래스를 가지고 예시를 들어보겠다.<br>(ColorPoint는 Point클래스를 확장(extends)한 클래스이다.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">ColorPoint</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure>
<p>위와 같은 인스턴스 a, b, c가 있다.<br>이 때, a.equals(b)와 b.equals(c) 일 때, a.equals(c)<br>가 되는 과정을 살펴 보자</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x == p.x &amp;&amp; <span class="built_in">this</span>.y == p.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="대칭성이-위배되는-case"><a href="#대칭성이-위배되는-case" class="headerlink" title="대칭성이 위배되는 case"></a>대칭성이 위배되는 case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; <span class="built_in">this</span>.color == ((ColorPoint) o).color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 처럼 ColorPoint 클래스의 equals 메서드를 재정의 했다면… </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//false</span></span><br><span class="line">System.out.println(b.equals(a)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>a.equals(b)</code>를 보면 a는 ColorPoint이기 떄문에 ColorPoint 클래스에서 재정의 된 equals 메서드를 타게 된다.<br>이렇게 되면 첫번째 if 조건에서 걸리게 된다. b는 Point이지만 ColorPoint는 아니기 떄문이다.<br>따라서 <code>a.equals(b)</code>는 <code>false</code>가 된다.</p>
</li>
<li><p><code>b.equals(a)</code>를 보면 b는 Point클래스이기 떄문에 Point클래스의 equals메서드를 타게 된다.<br>이렇게 되면 ColorPoint는 Point클래스를 상속하고 있기 때문에 첫번째 if조건을 통과하게 되고,<br>int x, int y값을 기준으로만 비교하기 떄문에 값이 참이 된다.<br>따라서 <code>b.equals(a)</code>는 <code>true</code>가 된다.</p>
</li>
</ol>
<p>위의 예시는 equals 정의 규약 중 하나인 대칭성을 위반하고 있으므로 다시 작성해야 한다.</p>
<h3 id="추이성이-위반되는-case"><a href="#추이성이-위반되는-case" class="headerlink" title="추이성이 위반되는 case"></a>추이성이 위반되는 case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> o.equals(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; <span class="built_in">this</span>.color == ((ColorPoint) o).color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 처럼 ColorPoint 클래스의 equals메서드를 다시 재정의 했다면..  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">ColorPoint</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true</span></span><br><span class="line">System.out.println(b.equals(c)); <span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(c)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>a.equals(b)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>b가 Point인 경우이기 때문에 2번쨰 if 절을 타게 되어 Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li>
<li><code>b.equals(c)</code>를 보면 b는 Point클래스의 인스턴스이므로 Point클래스의 equals 메서드를 실행하게 된다.<br>Point의 x, y정보만 비교하게 되므로 결과는 <code>true</code>이다.</li>
<li><code>a.equals(c)</code>를 보면 a는 ColorPoint클래스의 인스턴스이므로 재정의된 equals 메서드를 실행하게 된다.<br>하지만, c가 ColorPoint클래스의 인스턴스이므로 x, y값 뿐만아니라 color까지 비교하게되어 결과는 <code>false</code>이다.</li>
</ol>
<p>이렇게 a.equals(b)는 <code>true</code>를 만족하고 b.equals(c)는 <code>true</code>를 만족하지만 a.equals(c)는 <code>false</code>가 되므로<br>위의 코드는 equals 정의 규약 중 <code>추이성</code>을 위반하는 코드가 된다.</p>
<h3 id="무한-재귀-Infinite-Recursion-이-발생하는-case"><a href="#무한-재귀-Infinite-Recursion-이-발생하는-case" class="headerlink" title="무한 재귀 (Infinite Recursion)이 발생하는 case"></a>무한 재귀 (Infinite Recursion)이 발생하는 case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmellPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Smell smell;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> SmellPoint)) <span class="keyword">return</span> o.equals(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//o가 ColorPoint이면 색상까지 비교한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; <span class="built_in">this</span>.smell == ((SmellPoint) o).smell;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 처럼 Point를 상속받는 SmellPoint라는 클래스도 추가되었다고 가정해보자</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmellPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Smell.SWEET);</span><br><span class="line"></span><br><span class="line">System.out.println(cp.equals(sp));  <span class="comment">//?</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 ColorPoint와 SmellPoint에 대해 equals비교를 한다고 하면 어떻게 될까??<br>이렇게 되면 두번째 if절에서 무한재귀(Infinite Recursion)이 발생하게 된다.  </p>
<p>무슨 의미인지 자세히 설명하면, cp는 ColorPoint 클래스의 인스턴스이기 때문에<br><code>cp.equals(sp)</code> 코드는 ColorPoint 클래스의 재정의 된 equals 메서드를 타게 된다.<br>이렇게 되면 두번째 if에서 걸리게 된다. 왜냐하면 o는 <strong>SmellPoint</strong> 타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 o는 SmellPoint 클래스의 인스턴스이기 때문에<br>SmellPoint 클래스의 재정의된 equals메서드를 타게 된다.</p>
<p>다시 SmellPoint클래스의 입장에서 보게되면 두번째 if에서 걸리게 된다.<br>여기서 o는 ColorPoint타입이기 때문에 <code>!(o instanceof ColorPoint)</code> 이 조건식이 true가 된다.<br>그렇기 때문에 o.equals(this)가 실행되게 되면 결과적으로 다시 ColorPoint 클래스의 재정의된 equals메서드를 타게 된다.</p>
<p>이런 작업이 계속 재귀적으로 호출 되면서, 결국은 StackOverflowError를 내며 프로그램이 죽는 참사를 맞이 하게 될 것이다.</p>
<h3 id="리스코프-치환-원칙-SOLID"><a href="#리스코프-치환-원칙-SOLID" class="headerlink" title="리스코프 치환 원칙 (SOLID)"></a>리스코프 치환 원칙 (SOLID)</h3><p>SOLID원칙 중 3번째인 리스코프 치횐 원칙이란?</p>
<blockquote>
<p>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.</p>
</blockquote>
<p>쉽게 말해서, 자식클래스에서 부모클래스의 기능을 수행하지 못하는 건 리스코프 치환원칙에 위배된다고 볼 수 있다.</p>
<p>위에서 equals 재정의에 실패해서 다시 또 변경하였다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Point&gt; unitCircle = Set.of(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Point</span>(-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">onUnitCircle</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unitCircle.contains(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span> || o.getClass() != <span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x == p.x &amp;&amp; <span class="built_in">this</span>.y = p.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이번에는 주어진 점이 반지름이 1인 원안에 포함되는지에 대한 여부를 판단하는 로직이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">0</span>, Color.RED);</span><br><span class="line">System.out.println(Point.onUnitCircle(cp)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>ColorPoint는 Point를 상속한 클래스이다.<br>실제 oint.onUnitCircle 메서드의 contains 메서드에서 Set내의 element들에 대한 equals 비교가 일어나게 된다.<br>하지만 equals 메서드 첫번째 if문에서 걸리게 된다.<br>ColorPoint 객체가 파라미터로 전달되어 null은 아니지만,<br>두번째 조건식인 o.getClass()에서 <code>ColorPoint.class</code>가 도출되고 this.getClass()에서는 <code>Point.class</code>가 도출되게 된다.  </p>
<p>위 조건식 때문에 ColorPoint 클래스는 Point클래스로서 equals메서드 내에서 활용되지 못했기 때문에<br>위 코드는 리스코프 치환원칙에 위배되는 코드로 전락해 버렸다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(o == <span class="literal">null</span> || !(o <span class="keyword">instanceof</span> Point)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.x == p.x &amp;&amp; <span class="built_in">this</span>.y = p.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>차라리 이런식으로 instanceof를 사용했다면 좋았을 것이다.</p>
<h2 id="상속-대신-컴포지션-Composition-을-사용하라"><a href="#상속-대신-컴포지션-Composition-을-사용하라" class="headerlink" title="상속 대신 컴포지션(Composition)을 사용하라"></a>상속 대신 컴포지션(Composition)을 사용하라</h2><p>구체클래스의 하위클래스에서 값을 추가할 방법은 없지만, 우회방법이 있다.<br>상속 대신에 Point 변수를 갖도록 Composition(구성)을 이용하는 방법이다.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ColorPoint &#123;</span><br><span class="line">  <span class="keyword">private</span> Point point;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ColorPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Color color)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.point = <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    <span class="built_in">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Point <span class="title function_">asPoint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> (ColorPoint) o;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.point.equals(cp) &amp;&amp; <span class="built_in">this</span>.color.equals(cp.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이와 같이 컴포지션을 이용하면 상속에 때문에 발생하는 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.</p>
<h2 id="일관성-consistency"><a href="#일관성-consistency" class="headerlink" title="일관성 (consistency)"></a>일관성 (consistency)</h2><p><strong>null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.</strong><br>두 객체가 같다면 수정되지 않는 한 영원히 같아야 함을 의미한다.<br>가변객체는 비교시점에 따라 서로 달라질 수 있지만 불변객체라면 한번 다르면 끝까지 달라야 한다. (그래서 불변객체로 만드는 것이 나을때가 많다)</p>
<p>하지만, 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안된다.<br><code>java.net.URL</code> 클래스는 URL과 매핑된 host의 IP주소를 이용해 비교한다.<br>당장 우리회사 서버만 봐도 L4스위치가 적용되있기 때문에 로드밸런싱이 되어 같은 도메인주소라도 그떄그떄 나오는 IP정보가 다르다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;www.site-name.co.kr&quot;</span>);</span><br><span class="line"><span class="type">URL</span> <span class="variable">url2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;www.site-name.co.kr&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(url1.equals(url2)); <span class="comment">//?</span></span><br></pre></td></tr></table></figure>
<p>실제 url1이 10.0.0.1 이라는 IP가 나왔다면<br>url2의 경우 10.0.0.1이 나올수도 있고, 같은 대역에 있는 10.0.0.2가 나올 수도 있다.<br>그렇기 떄문에 equals의 결과가 가변적이기 떄문에 다른 자원의 개입으로 인해 equals의 일관성이 깨지게 된다.  </p>
<p>그렇게 때문에 항상 equals를 사용할 때는 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.</p>
<h2 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h2><p><strong>null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다</strong><br>기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//불필요</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.x == o.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 equals를 재정의 할 때 이러한 코드를 작성하기 쉽다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> MyClass)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//묵시적 null검사</span></span><br><span class="line">  <span class="type">MyClass</span> <span class="variable">clazz</span> <span class="operator">=</span> (MyClass) o;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.x == clazz.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이런식으로 instanceof 키워드를 통해 묵시적 null 체크를 하는 방법이 좋다.</p>
<h1 id="요약-정리"><a href="#요약-정리" class="headerlink" title="요약 정리"></a>요약 정리</h1><h2 id="equals-구현-절차"><a href="#equals-구현-절차" class="headerlink" title="equals 구현 절차"></a>equals 구현 절차</h2><ul>
<li><code>==</code> 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다. (동일성 검사 - Object Identity)<ul>
<li>성능 향상을 위한 코드</li>
<li>equals가 복잡할 때 같은 참조를 가진 객체에 대한 비교를 안하기 위함</li>
</ul>
</li>
<li><code>instanceof</code> 연산자로 파라미터의 타입이 올바른지 체크<ul>
<li>묵시적 null체크 용도로도 사용</li>
<li>equals중에서는 같은 interface를 구현한 클래스끼리도 비교하는 경우가 있다.</li>
</ul>
</li>
<li>입력을 올바른 타입으로 형변환한다.<ul>
<li>Object타입의 파라미터를 비교하고자 하는 타입으로 형변환한다.</li>
<li>앞서 <code>instanceof</code> 연산을 수행했기 때문에 100% 성공한다.</li>
</ul>
</li>
<li>파라미터 Object 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인한다.<ul>
<li>하나라도 다르면 false를 리턴</li>
<li>만약 interface기반의 비교가 필요하다면 필드정보를 가져오는 메서드가 interface에 정의되어있어야하고,<br>구현체 클래스에서는 메서드를 재정의 해야한다.</li>
</ul>
</li>
<li>float, double을 제외한 기본타입은 <code>==</code>을 통해 비교</li>
<li>참조(reference) 타입은 equals를 통해 비교</li>
<li>float, double은 Float.compare(float, float)와 Double.compare(double, double)로 비교한다.<ul>
<li>Float.Nan, -0.0f등을 비교하기 위함이다.</li>
<li>이 메서드들은 float -&gt; Float, double -&gt; Double로 변환하는 오토박싱 기능이 수반되므로 성능상 좋지 못하다.</li>
</ul>
</li>
<li>배열의 모든 원소가 핵심 필드라면 Arrays.equals를 사용하자</li>
<li>null이 의심되는 필드는 Objects.equals(obj, obj)를 이용해 NullPointerException을 예방하자</li>
<li>성능을 올리고자 한다면<ul>
<li>다를 확률이 높은 필드부터 비교한다.</li>
<li>비교하는 비용(시간복잡도)이 적은 비교를 먼저 수행</li>
</ul>
</li>
</ul>
<h1 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h1><ul>
<li>equals를 재정의 했다면, 대칭성, 추이성, 일관성에 대한 체크를 꼭 하자 (테스트 케이스 작성 요망)</li>
<li>equals를 작성할 때는 hashcode도 반드시 재정의하자 (Item.11)</li>
<li>너무 복잡하게 해결하려 들지 말자</li>
<li>equals의 파라미터는 Object이외의 타입으로 선언하지 말자 (컴파일 에러 발생)</li>
<li>구글에서 만든 @AutoValue을 이용해서 equals와 hashcode를 자동으로 재정의해보자 (Lombok의 @EqualsAndHashCode도 있다.)</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 10. equals는 일반 규약을 지켜 재정의하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/01/08/effective-java-item9/">Item 9. Try-Finally 보다는 Try-With-Resources를 사용하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-08</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Java 라이브러리 중에는 close메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, Connection등이 있다.<br>자원 닫기는 클라이언트가 놓치기 쉽기 때문에 예측할 수 없는 성능 문제로 이어지기도 한다.  </p>
<p>나의 경우에도 신입 때 JDBC로 개발을 해야 했던 적이 있었는데,<br>DB의 max-connection이 10이어서 11번째 호출 시 부터는 JDBCException이 발생하는 오류를 겪은 적이 있다.<br>알고 보니 하나의 메서드에서 Connection 객체에 대한 참조를 해제 하지 않아 계속 Connection을 물고 있는 상황이었다.<br>Spring을 사용하면서는 Mybatis나 JPA같은 프레임웍 내에서 자원에 대한 관리를 해주기 때문에 이런 일을 만날 일은 없게 되었다.</p>
<p>하지만 예전처럼 JDBC를 사용하거나, IO관련 작업을 할 때는 반드시 close를 통해 자원에 대한 해제가 필요하다.<br>이전에는 finallizer를 통해 했다고는 아는데 이전 장에서 봤듯이 안 쓰는것이 좋다.<br>그리고 try-catch-finally 구문을 통해 Exception이 발생하더라도, finally 절에서 close를 호출 하도록 했는데, 코드가 복잡해 지고, finally 절 내에서 Exception이 발생하는 경우도 있기 때문에 이를 방지하기 위해 더 더러운 코드를 생산하는 일이 적지 않았다.</p>
<p>옛날에 자주 사용해 본 아주아주 슬픈 코드이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCExam</span> &#123;</span><br><span class="line">  Connection connection;</span><br><span class="line">  Statement statement;</span><br><span class="line">  ResultSet resultSet;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;oracle:thin:localhost:1521:ORCL&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">JDBCExam</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Class.forName(driverName);</span><br><span class="line">          connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;[로드 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;[연결 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                  connection.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                  statement.close();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                  resultSet.close();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;[닫기 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AutoCloseable"><a href="#AutoCloseable" class="headerlink" title="AutoCloseable"></a>AutoCloseable</h1><p>JDK 1.7 부터 try-with-resources 구문이 추가 되었고, <code>AutoCloseable</code> 인터페이스가 추가되었다. 이 인터페이스가 나오고 부터 Java의 close를 지원하는 클래스에서 AutoCloseable을 구현하도록 변경되었다.</p>
<h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><p>try 절에 AutoCloseable을 구현한 클래스에 대한 인스턴스를 선언하게 되면 try절이 종료되는 시점에 AutoCloseable 인터페이스의 close() 메서드를 자동으로 호출 한다. 그렇기 때문에 이전처럼 finally 구문에서 별도로 자원에 대한 해제를 하지 않아도 된다.</p>
<p>위의 예시코드를 try-with-resources 구문으로 바꿔보았다.<br>위의 코드보다는 한층 깔끔해 짐을 볼 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCExam</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;oracle:thin:localhost:1521:ORCL&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDBCExam</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">             <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;select * from member&quot;</span>);</span><br><span class="line">             <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.getResultSet();</span><br><span class="line">             )&#123;</span><br><span class="line">            Class.forName(driverName);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;회원명 : &quot;</span> + name);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[로드 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[연결 오류]\n&quot;</span> + e.getStackTrace());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 9. try-finally 보다는 try-with-resources를 사용하라</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="../6/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../6/">6</a><span class="page-number current">7</span><a class="page-number" href="../8/">8</a><span class="space">&hellip;</span><a class="page-number" href="../12/">12</a><a class="extend next" rel="next" href="../8/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="../../js/utils.js?version=1.9.0"></script><script src="../../js/fancybox.js?version=1.9.0"></script><script src="../../js/sidebar.js?version=1.9.0"></script><script src="../../js/copy.js?version=1.9.0"></script><script src="../../js/fireworks.js?version=1.9.0"></script><script src="../../js/transition.js?version=1.9.0"></script><script src="../../js/scroll.js?version=1.9.0"></script><script src="../../js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>