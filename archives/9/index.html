<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다. | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../melody-favicon.ico"><link rel="stylesheet" href="../../css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href=".."><span class="pull-left">Articles</span><span class="pull-right">112</span></a><a class="author-info-articles__tags article-meta" href="../../tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Carrey`s 기술블로그</div><div id="site-sub-title">공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/07/2018-12-07-docker-11/">Docker기반 Redis 구축하기 - (11) Redis-Cli Docker로 사용하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-07</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Redis를 운영하다 보면 redis-cli를 주로 사용하게 되는데<br>항상 docker exec 명령을 통해 docker container 내의 redis-cli를 사용하여 불편한 점이 많았습니다.</p>
<p>찾아보니 간단하게 Docker로 Redis-cli를 사용할 방법이 있어 기록을 남기게 되었습니다.</p>
<h1 id="Docker로-Redis-cli-접속하기"><a href="#Docker로-Redis-cli-접속하기" class="headerlink" title="Docker로 Redis-cli 접속하기"></a>Docker로 Redis-cli 접속하기</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it \                                  </span><br><span class="line">                --<span class="built_in">rm</span> \ </span><br><span class="line">                --net host \ </span><br><span class="line">                redis:5.0.0-alpine redis-cli \</span><br><span class="line">                -a <span class="string">&quot;&lt;password&gt;&quot;</span> \</span><br><span class="line">                -p &lt;port&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>it 옵션 : container와 conversation이 가능한 옵션</li>
<li>rm옵션 : container가 종료되면 container를 삭제</li>
<li>net옵션 : network 옵션 </li>
<li>redis:5.0.0-alpine redis-cli : redis:5.0.0-alpine이미지의 redis-cli를 사용</li>
<li>a 옵션 : redis에서 requirepass를 사용하는 경우 password를 적어준다.</li>
<li>p 옵션 : 접속 port</li>
<li>h 옵션 : 접속하고자 하는 host (옵션 안주면 127.0.0.1로 접속한다)</li>
</ul>
<h1 id="Docker-Redis-cli로-cluster-설정하기"><a href="#Docker-Redis-cli로-cluster-설정하기" class="headerlink" title="Docker Redis-cli로 cluster 설정하기"></a>Docker Redis-cli로 cluster 설정하기</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it \                                  </span><br><span class="line">                --<span class="built_in">rm</span> \ </span><br><span class="line">                --net host \ </span><br><span class="line">                redis:5.0.0-alpine redis-cli \</span><br><span class="line">                -a <span class="string">&quot;&lt;password&gt;&quot;</span></span><br><span class="line">                --cluster create host:port host:port host:port  \  //master host&amp;port</span><br><span class="line">                 host:port host:port host:port \ //slave host&amp;port</span><br><span class="line">                --cluster-replicas 1 </span><br></pre></td></tr></table></figure>

<ul>
<li>–cluster : cluster mode 명령어 수행</li>
<li>create : cluster 생성 명령</li>
<li>–cluster-replicas 1 : Redis Replication 명령, Master node 1개당 Slave node 1개를 의미</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/03/2018-12-03-docker-10/">Docker기반 Redis 구축하기 - (10) Redis Cluster Mode 설정하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>이전 장 까지 했던 Redis 구조는 <code>Redis Replication + Redis Sentinel</code>을 이용한 failover 기능을 구성하고 있었습니다. Spring Application에서 Jedis를 이용하여 Application sharding을 구성하여 사용을 하였습니다. 이렇게 Redis를 잘 사용하나 싶었지만, 최근 Spring Cache Abstraction에 대해 공부했었고, Redis Replication + Sharding + Failover를 사용하면서 <strong>Spring-Data-Redis를 사용할 방법이 없을까?</strong> 라는 생각을 하게 되었습니다.</p>
<p>맨 처음에 회사에서 Spring + Redis연동을 할 때 당연히 Spring-Data-Redis를 염두하고 시작을 했었지만, 어느 블로그에서 <strong>Spring-Data-Redis는 Sharding을 지원하지 않는다!</strong> 라는 절망적인 얘기를 보고 여태까지 Docker를 이용해 설치한 방식에서 Jedis를 이용한 Sharding을 이용하고 있었습니다.</p>
<p>그 이후, Redis 관련 문서를 쭉 보던 중.. Redis 공식 홈페이지에서 <code>Redis Cluster Mode</code>에 대한 내용을 보게 되었습니다.<br>그 내용을 요약하자면</p>
<ul>
<li>Redis3 버전 부터 Redis는 <code>Cluster Mode</code>를 지원한다.</li>
<li>Cluster Mode에서는 Redis Sentinel의 도움없이 <code>Cluster 자체적으로 Failover를 진행</code>한다.</li>
<li>Cluster Mode에서는 Master-Slave 노드 구조를 가질 수 있고, <code>노드 간 Replication을 지원</code>한다.</li>
<li>Cluster Mode에서는 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행<br><code>Auto Sharding을 지원</code>한다 (이야!!!!!!!!!!!!)</li>
<li>Application Sharding이 필요없기 때문에, <code>Spring-Data-Redis 사용이 가능하다.</code><br>(사실은 이 목적 때문에 Cluster Mode 설치를 해보게 되었습니다.)</li>
</ul>
<h1 id="기존에-설치한-Redis-구조와-다른-점은"><a href="#기존에-설치한-Redis-구조와-다른-점은" class="headerlink" title="기존에 설치한 Redis 구조와 다른 점은?"></a>기존에 설치한 Redis 구조와 다른 점은?</h1><h2 id="이전-장까지-설치-했던-Redis-구조"><a href="#이전-장까지-설치-했던-Redis-구조" class="headerlink" title="이전 장까지 설치 했던 Redis 구조"></a>이전 장까지 설치 했던 Redis 구조</h2><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p>
<ul>
<li>Master - Slave -Slave 구조</li>
<li>Redis Sentinel을 이용한 Master 감시 + Fail over 기능 지원</li>
<li>HAProxy를 이용한 Master &#x2F; Slave 접근 Port 분리</li>
</ul>
<h2 id="새롭게-구성한-Redis-Cluster"><a href="#새롭게-구성한-Redis-Cluster" class="headerlink" title="새롭게 구성한 Redis Cluster"></a>새롭게 구성한 Redis Cluster</h2><p><img src="./new-redis-cluster.PNG" alt="new-redis-cluster"></p>
<ul>
<li><p>HAProxy는 5000번 포트만 사용하도록 축소 5001~5005는 불필요하기 때문</p>
<ul>
<li>앞으로는 무조건 Master에만 통신</li>
<li>어떤 Node와 통신하여 데이터를 set하거나 get 할 수 있음 (Cluster Mode 지원)</li>
<li>어떤 Node에 set하더라도 자동으로 Sharding</li>
</ul>
</li>
<li><p>감시자 역할의 Sentinel 제거 </p>
<ul>
<li>Cluster Mode에서는 Redis Node끼리 감시하며 Fail over가 가능합니다.</li>
</ul>
</li>
<li><p>Slave 갯수도 한개로 축소</p>
</li>
</ul>
<h1 id="Cluster-Mode에서-지원하는-기능"><a href="#Cluster-Mode에서-지원하는-기능" class="headerlink" title="Cluster Mode에서 지원하는 기능"></a>Cluster Mode에서 지원하는 기능</h1><h2 id="Fail-Over"><a href="#Fail-Over" class="headerlink" title="Fail Over"></a>Fail Over</h2><p><img src="./new-redis-cluster2.PNG" alt="new-redis-cluster2"></p>
<ul>
<li>Redis Cluster Mode에서는 기존의 Sentinel을 별도로 설치하여 감시자 역할을 하는 것에서 벗어나 Cluster 자체적으로 Node들을 감시하고 Failover를 수행 할 수 있습니다.</li>
<li>Redis Cluster Mode를 사용하기 위해서는 각 Redis Node 별로 2개의 port가 열려 있어야 합니다.<ul>
<li>6379, 6380 default - Redis 서버 접속 포트</li>
<li>16379, 16380 default  <code>(접속 포트 + 10000)</code> - Redis Cluster Bus</li>
</ul>
</li>
<li>Cluster Bus를 이용해 Redis Cluster는 각 노드를 감시하고 서버 다운 시 또는 Connection 유실 시 Fail over를 수행합니다.</li>
<li>Cluster Bus는 노드 간 데이터 교환에 대해 다른 바이너리 프로토콜을 사용합니다.</li>
<li>이 프로토콜은 대역폭과 처리 시간을 적게 사용하여 노드 간에 정보를 교환하는 데 더 적합합니다.</li>
</ul>
<h2 id="Auto-Sharding"><a href="#Auto-Sharding" class="headerlink" title="Auto Sharding"></a>Auto Sharding</h2><ul>
<li>Redis Cluster Mode에서는 자동으로 Cluster Node에 대한 자동 샤딩을 제공합니다.</li>
<li>Redis Cluster에는 16384개의 slot이 있으며, slot에 대한 구간 별로 샤딩이 가능합니다.</li>
<li>slot을 계산하기 위해 redis key의 HashCode에 대해 CRC16의 16384 modules (key%16384) 연산을 실행합니다.<ul>
<li>[0-5500] 까지는 1번 Redis Node에 저장</li>
<li>[5501-11000] 까지는 2번 Redis Node에 저장</li>
<li>[11001-16384] 까지는 3번 Redis Node에 저장</li>
<li>Redis Node가 scale out 되는 경우 Master Node 수를 나눈 만큼 대역이 할당</li>
</ul>
</li>
</ul>
<h2 id="Redis-cli를-이용한-cluster-명령"><a href="#Redis-cli를-이용한-cluster-명령" class="headerlink" title="Redis-cli를 이용한 cluster 명령"></a>Redis-cli를 이용한 cluster 명령</h2><p>Redis 5버전에 포함된 redis-cli 버전 부터 cluster 옵션이 추가 되었습니다.<br>Redis 4버전 이하에 대해서는 별도로 Ruby 기반의 프로그램을 설치해야 되서 번거로워서, Redis 5버전으로 설치를 해보았습니다. (성능도 더 좋을라나?ㅎ)</p>
<h3 id="Redis-Cluster-생성"><a href="#Redis-Cluster-생성" class="headerlink" title="Redis Cluster 생성"></a>Redis Cluster 생성</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.137.101:6379 192.168.137.102:6379 192.168.137.103:6379 \</span><br><span class="line">192.168.137.102:6380 192.168.137.103:6380 192.168.137.101:6380 \</span><br><span class="line">--cluster-replicas 1</span><br></pre></td></tr></table></figure>
<ul>
<li>Redis Cluster를 생성하기 위해서는 Master Node가 최소 3개 이상 필요합니다.</li>
<li>맨 처음 등록하는 3개의 노드가 Master Node</li>
<li><code>--cluster-replicas 1</code> 의 의미는 각 Slave Node가 1개임을 의미합니다.</li>
<li>6개의 노드가 등록 되었다면 처음 3개는 Master, 뒤의 3개는 Slave가 됩니다</li>
<li>Slave는 선언된 순서 대로 Master의 Slave로 등록 됩니다<ul>
<li>192.168.137.101:6379 -&gt; 192.168.137.102:6380</li>
<li>192.168.137.102:6379 -&gt; 192.168.137.103:6380</li>
<li>192.168.137.103:6379 -&gt; 192.168.137.101:6380</li>
</ul>
</li>
</ul>
<p><img src="./cluster-setting.PNG" alt="cluster-setting"></p>
<p><img src="./cluster-setting2.PNG" alt="cluster-setting2"></p>
<p>redis-cli에 접속하여 cluster nodes 명령어로 cluster를 구성하는 nodes에 대한 정보를 조회해 보았습니다.</p>
<p><img src="./cluster-nodes.png" alt="cluster-nodes"></p>
<h3 id="Redis-Node-ADD-x2F-REMOVE"><a href="#Redis-Node-ADD-x2F-REMOVE" class="headerlink" title="Redis Node ADD &#x2F; REMOVE"></a>Redis Node ADD &#x2F; REMOVE</h3><p>새로운 노드를 추가하는 과정은 기본적으로 2가지입니다.</p>
<ul>
<li>새로운 Master를 추가하는 경우</li>
<li>새로운 Slave를 추가하는 경우</li>
</ul>
<h3 id="Master-추가"><a href="#Master-추가" class="headerlink" title="Master 추가"></a>Master 추가</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6379 192.168.137.101:6379</span><br></pre></td></tr></table></figure>
<ul>
<li>위 명령은 cluster에 새로운 노드를 추가하는 명령어입니다.</li>
<li>192.168.137.101:6379 구성 된 Cluster에 192.168.137.104:6379 추가한다는 명령어입니다.</li>
<li>cluster를 지정할 때는 master node를 아무거나 지정하면 됩니다. (192.168.137.101~103:6379)</li>
<li>여기까지 했을 때는 Cluster에 일원이 되어 Cluster로 묶여는지나, <code>실제로 데이터는 저장 되지 않습니다.</code></li>
<li>hash slot이 할당 되지 않았기 때문에 데이터는 저장되지 않습니다.</li>
<li><code>re-sharding</code>을 통해 slot의 대역을 할당 받아야 합니다.</li>
</ul>
<h3 id="Slave-추가"><a href="#Slave-추가" class="headerlink" title="Slave 추가"></a>Slave 추가</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave</span><br></pre></td></tr></table></figure>
<ul>
<li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li>
<li>이 경우에는 새롭게 추가된 노드를 <code>복제본의 수가 적은 마스터</code> 나 임의의 마스터에 대한 Slave로 추가됩니다.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.137.104:6380 192.168.137.101:6379 --cluster-slave\</span><br><span class="line">--cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e1</span><br></pre></td></tr></table></figure>
<ul>
<li>위 명령은 Redis cluster에 slave를 추가하는 명령어입니다.</li>
<li>이 경우에는 master node를 지정하기 때문에 특정 master-id에 해당하는 master node의 slave로 추가됩니다.</li>
</ul>
<h2 id="Node-제거"><a href="#Node-제거" class="headerlink" title="Node 제거"></a>Node 제거</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.137.101:6379 `&lt;node-id&gt;`</span><br><span class="line">redis-cli --cluster del-node 192.168.137.101:6379</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure>

<ul>
<li>위 명령은 Redis Cluster의 node를 제거하는 명령어입니다.</li>
<li>Redis Cluster에 포함된 아무 node를 적어준다 <code>192.168.137.101:6379 는 Redis Cluster 노드 중 하나</code></li>
<li>node-id는 삭제하고자 하는 node의 id입니다.</li>
<li>node-id는 cluster nodes 명령어를 통해 검색하여 적어줍니다.</li>
<li>Slave는 막 지울 수 있습니다!</li>
<li>하지만 <strong>Master는 노드에 저장된 내용이 하나도 없어야 삭제가 가능합니다.</strong></li>
<li>지울 수 있는 대안으로는 수동으로 failover를 하여 slave로 만든 다음에 삭제를 하는 방법이 있습니다.</li>
</ul>
<h3 id="Re-sharding"><a href="#Re-sharding" class="headerlink" title="Re-sharding"></a>Re-sharding</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.137.101:6379</span><br></pre></td></tr></table></figure>

<ul>
<li>위 명령은 현재 cluster에 대한 reshard를 수행하는 명령어입니다.</li>
<li>cluster내의 master node 아무거나 써주면 자동으로 cluster node를 스캔하여 reshard를 수행합니다.</li>
<li>resharding 중에도 무중단으로 redis를 사용할 수 있습니다.</li>
<li>하지만 resharding을 <strong>수행하는 key에 대해서는 lock이 걸립니다.</strong></li>
<li>만약 resharding 대상이 많은 경우에는 redis 서버가 중지되었다가 다시 시작 될 수 있습니다.</li>
</ul>
<h1 id="Redis-설치"><a href="#Redis-설치" class="headerlink" title="Redis 설치"></a>Redis 설치</h1><h2 id="Docker-설정하기"><a href="#Docker-설정하기" class="headerlink" title="Docker 설정하기"></a>Docker 설정하기</h2><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">redis-master:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">      <span class="attr">build:</span></span><br><span class="line">         <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">         <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=&lt;password&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6379</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../new_redis-data/redis1:/data&quot;</span></span><br><span class="line">      <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">redis-slave:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">      <span class="attr">build:</span></span><br><span class="line">         <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">         <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=&lt;password&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../new_redis-data/redis2:/data&quot;</span></span><br><span class="line">      <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<ul>
<li>redis-cli의 cluster option을 사용하기 위해 redis:5.0-alpine 버전을 사용하였습니다.</li>
<li>redis:5.0.0이 RELEASE 버전이지만, Dockerfile에서 sed 명령어 사용 시, <code>Permission denied</code>가 발생하는 버그가 있습니다.</li>
<li>network_mode 는 <code>host</code>로 설정. <code>Docker Redis는 NAT에 대한 지원을 하지 않습니다.</code></li>
<li>외부 볼륨 연동을 위해 ..&#x2F;..&#x2F;new_redis-data&#x2F;master 폴더와 docker container 내의 &#x2F;data 폴더를 연동하였습니다.</li>
<li>container down 시 항상 재시작 하도록 restart policy를 always로 설정 하였습니다.</li>
</ul>
<h3 id="docker-entrypoint-sh"><a href="#docker-entrypoint-sh" class="headerlink" title="docker-entrypoint.sh"></a>docker-entrypoint.sh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment">## from redis-5</span></span><br><span class="line">sed -i <span class="string">&quot;s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span> 127.0.0.1/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/port 6379/port <span class="variable">$CLIENTPORT</span>/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# requirepass foobared/requirepass <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# masterauth &lt;master-password&gt;/masterauth <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# cluster-enabled yes/cluster-enabled yes/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# cluster-config-file nodes-6379.conf/cluster-config-file nodes.conf/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line">sed -i <span class="string">&quot;s/# cluster-node-timeout 15000/cluster-node-timeout 5000/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;1#-&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;1%.conf&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">set</span> -- redis-server <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">chown</span> -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sed명령어를 통해 container내의 redis.conf파일을 치환<br>   <code>치환자에 대한 설정은 docker-compose.yml &gt; environment에 등록</code><ul>
<li>bind 옵션에 대해 CLINET IP를 설정</li>
<li>port도 기본 6379 port에서 6379, 6380으로 치환하였습니다.</li>
<li>requirepass도 설정</li>
<li>masterauth도 requirepass와 동일하게 설정</li>
<li>cluster-mode를 사용하기 위해 <code>cluster-enable yes</code>로 설정</li>
<li>cluster에 대한 로그를 볼 수 있도록 <code>cluster-config-file nodes.conf</code> conf 파일 지정 (여기에 로그 생성)</li>
<li>cluster failover를 위해 <code>cluster-node-timeout</code>을 5초로 지정</li>
</ul>
</li>
</ul>
<h1 id="Failover-Test"><a href="#Failover-Test" class="headerlink" title="Failover Test"></a>Failover Test</h1><p>테스트를 위해 192.168.137.101:6379 (master1)에 대한 docker container를 죽여보았습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 030bb02a246e</span><br></pre></td></tr></table></figure>

<p><img src="./master-down.png" alt="master-down"></p>
<ul>
<li>docker ps -a 명령으로 볼 때 192.168.137.101:6379 (master1)에 대한 docker container가 다운!!</li>
</ul>
<p><img src="./failover-1.png" alt="failover-1"></p>
<ul>
<li><p>5초 정도 지나니 무슨 로그가 올라왔습니다. epoch vote라는 로그를 보아하니 새로운 마스터를 선출하였습니다.</p>
</li>
<li><p>redis-cli를 통해 <code>cluster nodes</code>를 검색해 보니 <code>192.168.137.101:6379 (master1)</code>의 slave였던 <code>192.168.137.103:6380 (slave1)</code> 가 새로운 master로 promote 되었습니다.</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 030bb02a246e</span><br></pre></td></tr></table></figure>
<ul>
<li>docker start 명령으로 다시 container를 살려보았습니다.</li>
</ul>
<p><img src="./failover2.png" alt="failover2"></p>
<ul>
<li>기존의 master는 slave로 편입되어 정상적인 cluster가 작동하고 있습니다.</li>
</ul>
<h1 id="Sharding-Test"><a href="#Sharding-Test" class="headerlink" title="Sharding Test"></a>Sharding Test</h1><p><img src="./cluster-keys-command.PNG" alt="cluster-keys-command"></p>
<ul>
<li>redis-cli를 통해 foo1~foo10까지 key를 만들어 set해 보았습니다.</li>
<li>set할때 마다 16384 modules 연산을 통해 slot별로 sharding이 되는 모습입니다.</li>
<li>각 redis-cli에서 keys * 명령을 통해 조회 해보면 고르게 sharding이 되어있음을 확인 할 수 있습니다.</li>
</ul>
<h1 id="Node-ADD-x2F-REMOVE"><a href="#Node-ADD-x2F-REMOVE" class="headerlink" title="Node ADD&#x2F;REMOVE"></a>Node ADD&#x2F;REMOVE</h1><p><img src="./cluster-add.PNG" alt="cluster-add"></p>
<ul>
<li>신규 Master node (192.168.137.104:6379)를 새로이 추가해 보았습니다.</li>
</ul>
<p><img src="./cluster-add-node-slave.PNG" alt="cluster-add-node-slave"><br><img src="./slave-add-result.png" alt="slave-add-result"></p>
<ul>
<li>신규 Slave node (192.168.137.104:6380)를 새로이 추가해 보았습니다.</li>
<li>신규 Master node (192.168.137.104:6379)의 slave로 추가해보았다.</li>
<li>정상적으로 모두 등록 되었다.</li>
</ul>
<p><img src="./slave-del.png" alt="slave-del"></p>
<ul>
<li>slave를 삭제해 보았습니다.</li>
</ul>
<p><img src="./slave-del-result.png" alt="slave-del-result"></p>
<ul>
<li>slave가 정상적으로 삭제 되었습니다.</li>
</ul>
<p><img src="./master-del-fail.png" alt="master-del-fail"></p>
<ul>
<li>master 삭제를 시도해 보았습니다.</li>
<li>slot이 비어있지 않아 삭제가 불가능 했습니다.</li>
<li>이런 경우 reshard를 통해 slot을 비워준뒤에 삭제 해야합니다.</li>
</ul>
<p><img src="./sub-reshard.PNG" alt="sub-reshard"></p>
<ul>
<li>reshard 명령을 다시 실행 합니다.</li>
<li><code>What is the receiving node ID?</code> 라는 질문에 192.168.137.101:6379 node-id를 지정합니다.</li>
<li><code>Source node</code> 항목에는 우리가 삭제할 192.168.137.104:6379 node-id를 지정합니다.</li>
<li><code>source node</code> 두번째 항목에는 done을 입력하여 Source node 항목을 모두 입력하였음을 선언해 줍니다.</li>
</ul>
<p><img src="./master-del-success.png" alt="master-del-success"></p>
<ul>
<li>다시 master를 삭제하니 정상적으로 삭제가 됩니다.</li>
</ul>
<h1 id="Re-Sharding-Test"><a href="#Re-Sharding-Test" class="headerlink" title="Re-Sharding Test"></a>Re-Sharding Test</h1><p><img src="./reshard-test-1-3831920.PNG" alt="reshard-test-1"></p>
<ul>
<li>새롭게 추가한 노드에 reshard를 해보았습니다.</li>
<li>4000개정도를 새로이 옮긴다고 조건을 주고 Resharding을 실행 해보았습니다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="./reshard-test-2-3832564.PNG" alt="reshard-test-2"></p>
<p><img src="./reshard-test-3.PNG" alt="reshard-test-3"></p>
<ul>
<li>정상적으로 resharding이 되어 데이터가 4개의 node에 고르게 분포 되었습니다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/03/2018-12-03-redis-stats/">Docker기반 Redis 구축하기 - (9) Redis-Stats을 이용한 모니터링</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="Redis-stats"><a href="#Redis-stats" class="headerlink" title="Redis-stats"></a>Redis-stats</h1><p>Redis-stat은 대표적인 <code>오픈소스 Redis 모니터링 도구</code>입니다.</p>
<p>Ruby 기반으로 동작하는 프로그램이며, Ruby만 설치되어 있다면 설치가 간편하고 Web 또는 Console로 Redis 서버를 모니터링 할 수 있습니다.<br>비슷한 모니터링 도구로 Redmon, RedisLive등이 있지만.. Redis 4이상 버전을 아직 지원하지 않아서 Redis-stat으로 설치 해보게 되었습니다.</p>
<h1 id="Redis-stats-설치하기"><a href="#Redis-stats-설치하기" class="headerlink" title="Redis-stats 설치하기"></a>Redis-stats 설치하기</h1><h2 id="Install-Dependency"><a href="#Install-Dependency" class="headerlink" title="Install Dependency"></a>Install Dependency</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel openssl-devel make</span><br><span class="line">yum install -y bzip2 autoconf automake libtool bison iconv-devel sqlite-devel libyaml-devel libffi-devel</span><br></pre></td></tr></table></figure>



<h2 id="Install-RVM-Ruby-Version-Manager"><a href="#Install-RVM-Ruby-Version-Manager" class="headerlink" title="Install RVM (Ruby Version Manager)"></a>Install RVM (Ruby Version Manager)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://rvm.io/mpapis.asc | gpg --import</span><br><span class="line">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>



<h2 id="Setup-RVM-Environment"><a href="#Setup-RVM-Environment" class="headerlink" title="Setup RVM Environment"></a>Setup RVM Environment</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile.d/rvm.sh</span><br><span class="line">rvm reload</span><br></pre></td></tr></table></figure>



<h2 id="Install-Ruby-2-3-3"><a href="#Install-Ruby-2-3-3" class="headerlink" title="Install Ruby 2.3.3"></a>Install Ruby 2.3.3</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install 2.3.3</span><br></pre></td></tr></table></figure>



<h2 id="Set-Default-Ruby-Version"><a href="#Set-Default-Ruby-Version" class="headerlink" title="Set Default Ruby Version"></a>Set Default Ruby Version</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rvm list</span><br><span class="line">rvm use 2.3.3 --default</span><br></pre></td></tr></table></figure>



<h2 id="Setup-Redis-stat"><a href="#Setup-Redis-stat" class="headerlink" title="Setup Redis-stat"></a>Setup Redis-stat</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis-stat</span><br></pre></td></tr></table></figure>



<h1 id="Redis-stat-실행하기"><a href="#Redis-stat-실행하기" class="headerlink" title="Redis-stat 실행하기"></a>Redis-stat 실행하기</h1><p>Redis-stat은 Web에서 조회하는 방법과 Console에서 조회하는 방법이 있습니다.<br>두 가지 형태의 모니터링 방법과 속성에 대해 알아보겠습니다.</p>
<h2 id="Redis-stat-옵션"><a href="#Redis-stat-옵션" class="headerlink" title="Redis-stat 옵션"></a>Redis-stat 옵션</h2><table>
<thead>
<tr>
<th><strong>명령어</strong></th>
<th><strong>설명</strong></th>
<th><strong>비고</strong></th>
</tr>
</thead>
<tbody><tr>
<td>redis-stat 1</td>
<td>localhost:6379 1초 간격으로 조회</td>
<td></td>
</tr>
<tr>
<td>redis-stat 1 10</td>
<td>localhost:6379 1초 간격으로 10회 조회</td>
<td></td>
</tr>
<tr>
<td>redis-stat –verbose</td>
<td>localhost:6379 2초 간격으로 보여주기</td>
<td></td>
</tr>
<tr>
<td>redis-stat 192.168.0.2:6379 192.168.0.2:6380 5</td>
<td>192.168.0.2:6379 192.168.0.2:6380서버를 5초 간격으로 보여주기</td>
<td></td>
</tr>
<tr>
<td>redis-stat –csv&#x3D;&#x2F;temp&#x2F;redis-log.csv</td>
<td>csv파일 남기기</td>
<td></td>
</tr>
<tr>
<td>redis-stat –daemon –server 8888</td>
<td>daemon 모드로 실행 port 8888번으로 접속 시, Web Monitoring mode로 작동</td>
<td>daemon과 server는 반드시 같이 사용해야하는 옵션</td>
</tr>
<tr>
<td>redis-stat -a (–auth) password</td>
<td>-a 또는 –auth 옵션을 통해 requirepass 비밀번호 설정</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Redis-stat-Console-Monitoring"><a href="#Redis-stat-Console-Monitoring" class="headerlink" title="Redis-stat (Console Monitoring)"></a>Redis-stat (Console Monitoring)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class="line">redis-stat 1 -a password1234 \</span><br><span class="line">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381</span><br></pre></td></tr></table></figure>

<p><img src="./redis-stat-1.PNG" alt="redis-stat-1"></p>
<h2 id="Redis-stat-Web-Monitoring"><a href="#Redis-stat-Web-Monitoring" class="headerlink" title="Redis-stat (Web Monitoring)"></a>Redis-stat (Web Monitoring)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># CentOs 방화벽 포트 open</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port 8888/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"> </span><br><span class="line"><span class="comment">#192.168.137.101 서버의 6379~6381 포트 정보를 조회</span></span><br><span class="line">redis-stat 1 -a &lt;requirepass&gt; \</span><br><span class="line">192.168.137.101:6379 192.168.137.101:6380 192.168.137.101:6381 \</span><br><span class="line">--daemon --server=8888</span><br></pre></td></tr></table></figure>



<h2 id="192-168-137-104-8888-서버로-접속"><a href="#192-168-137-104-8888-서버로-접속" class="headerlink" title="192.168.137.104:8888 서버로 접속"></a>192.168.137.104:8888 서버로 접속</h2><p><img src="./redis-stat-web.PNG" alt="redis-stat-web"></p>
<p><img src="./redis-stat-web2.PNG" alt="redis-stat-web2"></p>
<h1 id="아쉬운-점"><a href="#아쉬운-점" class="headerlink" title="아쉬운 점"></a>아쉬운 점</h1><ol>
<li>그 당시의 모니터링만 가능하다. (별도 저장소가 없기 때문) -&gt; 이전 로그를 보기 위해선 CSV 파일을 남기는 것이 최선</li>
<li>보고자 하는 정보가 적다. 기본적으로 메모리 사용량, Client 수 Key Size정도는 제공을 하지만 다른 툴에서는 더 많은 정보가 제공되는 것 같다.</li>
</ol>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/junegunn/redis-stat">https://github.com/junegunn/redis-stat</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/02/2018-12-02-docker-8/">Docker기반 Redis 구축하기 - (8) HAProxy를 이용한 분산처리 환경 구축하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-02</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="HAProxy란"><a href="#HAProxy란" class="headerlink" title="HAProxy란?"></a>HAProxy란?</h1><p>HAProxy는 기존의 하드웨어 스위치(L4&#x2F;L7)을 대체하는 소프트웨어 로드밸런서입니다.<br>로드 밸런싱이란 부하 분산을 위해서 가상IP를 통해 여러서버에 접속하도록 트래픽을 분배해 주는 기능을 의미합니다.</p>
<h1 id="Redis-Cluster에-HAProxy가-필요한-이유"><a href="#Redis-Cluster에-HAProxy가-필요한-이유" class="headerlink" title="Redis-Cluster에 HAProxy가 필요한 이유"></a>Redis-Cluster에 HAProxy가 필요한 이유</h1><p>Redis Cluster에서는 Failover가 일어날 수 있습니다.</p>
<p>처음에 1번이 Master였다가, 2번이 Master가 되고, 3번이 Master가 될 수 있습니다.<br>하지만 Redis Cluster를 사용하는 Application에서 항상 바뀌는 Master의 포트정보를 찾는것은 매우 비용을 낭비하는 행위라 볼 수 있습니다.</p>
<p>따라서 HAProxy에서 Health check를 하면서 실시간으로 Master를 찾아 신호를 보내줄 수 있기 때문에 HAProxy를 Redis-Cluster에 접목하였습니다.</p>
<h1 id="다시-한번-보는-Redis-Cluster-구성도"><a href="#다시-한번-보는-Redis-Cluster-구성도" class="headerlink" title="다시 한번 보는 Redis Cluster 구성도"></a>다시 한번 보는 Redis Cluster 구성도</h1><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p>
<p>HAProxy Port를 6개를 지정합니다. (각각 1개는 Master Port, Slave Port라고 가정하고 (1(master)+1(slave)) x 3 (서버대수))</p>
<p>5000, 5002, 5004번 Port는 각 서버의 Master Redis를 체크합니다.<br>따라서 5000, 5002, 5004으로 들어온 요청은 각각의 서버의 Master Redis에 전달 됩니다.</p>
<p>다음으로 5001, 5003, 5005번 Port는 각 서버의 Slave Redis를 체크합니다.<br>따라서 5001, 5003, 5005으로 들어온 요청은 각각의 서버의 Slave Redis들에게 전달됩니다. (HAProxy에는 여러 서버에 대한 분배방식을 설정 할 수 있는데 고루게 요청할 수 있도록 RoundRobin 방식으로 설정하였습니다)</p>
<h1 id="HAProxy-설치방법"><a href="#HAProxy-설치방법" class="headerlink" title="HAProxy 설치방법"></a>HAProxy 설치방법</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 관련 모듈을 yum으로 설치한다.</span></span><br><span class="line">yum install gcc gcc-c++ pcre-devel openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># wget명령어도 haproxy 다운로드</span></span><br><span class="line">wget http://www.haproxy.org/download/1.8/src/haproxy-1.8.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 압축을 풀어준다.</span></span><br><span class="line">tar zxvf haproxy-1.8.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 디렉토리 이동</span></span><br><span class="line"><span class="built_in">cd</span> haproxy-1.8.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># c파일을 컴파일 해준다. https 사용이 필요한 경우 USE_OPENSSL=1 설정 추가</span></span><br><span class="line">make TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># /usr/local/haproxy 디렉토리에 설치</span></span><br><span class="line">make PREFIX=/usr/local/haproxy DESTDIR= install</span><br></pre></td></tr></table></figure>



<h1 id="haproxy-cfg-파일-작성"><a href="#haproxy-cfg-파일-작성" class="headerlink" title="haproxy.cfg 파일 작성"></a>haproxy.cfg 파일 작성</h1><p>haproxy.cfg 파일을 작성 할 때는 크게 2가지 관점으로 작성합니다.</p>
<ul>
<li>frontend : haproxy에서 사용할 포트 설정, 포트로 신호가 왔을 시 실행할 backend 연결</li>
<li>backend : frontend로 부터 온 신호를 바탕으로 연결가능한 서버에 트래픽을 분배</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">global</span><br><span class="line">  <span class="built_in">log</span> 127.0.0.1 local0</span><br><span class="line">  <span class="built_in">log</span> 127.0.0.1 local1 notice</span><br><span class="line"> </span><br><span class="line">defaults REDIS</span><br><span class="line">mode tcp</span><br><span class="line"><span class="built_in">timeout</span> connect 4s</span><br><span class="line"><span class="built_in">timeout</span> server 15s</span><br><span class="line"><span class="built_in">timeout</span> client 15s</span><br><span class="line"><span class="comment"># timeout tunnel 365d</span></span><br><span class="line"> </span><br><span class="line">frontend front_redis_master1</span><br><span class="line"> <span class="built_in">bind</span> *:5000 name redis                 <span class="comment">#5000번 포트에 대한 bind 정보입니다.</span></span><br><span class="line"> default_backend back_redis_master1     <span class="comment">#5000번 포트로 신호가 들어오면 backend를 실행</span></span><br><span class="line"> </span><br><span class="line">backend back_redis_master1</span><br><span class="line"> option tcp-check                       <span class="comment">#tcp-check를 통해 접근가능한 서버 필터링</span></span><br><span class="line"> tcp-check send AUTH\ password1234\r\n  <span class="comment">#비밀번호 password1234를 입력하고 Redis 서버에 접속합니다.</span></span><br><span class="line"> tcp-check expect string +OK            <span class="comment">#OK가 왔는지?</span></span><br><span class="line"> tcp-check send PING\r\n                <span class="comment">#PING을 날려 신호를 점검합니다.</span></span><br><span class="line"> tcp-check expect string +PONG          <span class="comment">#PONG이라는 응답이 왔는지?</span></span><br><span class="line"> tcp-check send info\ replication\r\n   <span class="comment">#info replication 명령을 날려 Redis에 대한 정보를 받아옵니다.</span></span><br><span class="line"> tcp-check expect string role:master    <span class="comment">#role이 master인지 확인 합니다.</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#repl_backlog_active의 값이 1인지 확인합니다 </span></span><br><span class="line"> <span class="comment">#이 조건을 추가한 이유는 Failover간 잠시의 시간동안 Master가 2대가 되는데 그것을 방지 하기 위함입니다.</span></span><br><span class="line"> <span class="comment">#(진짜 Master Redis에만 1, slave는 0)</span></span><br><span class="line"> tcp-check expect string repl_backlog_active:1 </span><br><span class="line"> tcp-check send QUIT\r\n                <span class="comment">#QUIT 명령을 전송</span></span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> server redis1 192.168.137.101:6379 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis2 192.168.137.101:6380 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis3 192.168.137.101:6381 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> </span><br><span class="line">frontend front_redis_slave1</span><br><span class="line"><span class="built_in">bind</span> *:5001 name redis                <span class="comment">#5001번 포트에 대한 bind 정보입니다.</span></span><br><span class="line">default_backend back_redis_slave1</span><br><span class="line"> </span><br><span class="line">backend back_redis_slave1</span><br><span class="line"> balance roundrobin                   <span class="comment">#라운드 로빈 방식으로 분배</span></span><br><span class="line"> option tcp-check</span><br><span class="line"> tcp-check send AUTH\ password1234\r\n        </span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> tcp-check send PING\r\n              </span><br><span class="line"> tcp-check expect string +PONG</span><br><span class="line"> tcp-check send info\ replication\r\n </span><br><span class="line"> tcp-check expect string role:slave   <span class="comment">#role key가 slave인지 확인 합니다.</span></span><br><span class="line"> tcp-check send QUIT\r\n</span><br><span class="line"> tcp-check expect string +OK</span><br><span class="line"> server redis1 192.168.137.101:6379 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis2 192.168.137.101:6380 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> server redis3 192.168.137.101:6381 check inter 1s  <span class="comment">#1초 단위로 해당 ip의 port로 체크합니다.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Listen on all IP&#x27;s on port 9000 //9000 포트로 접근 시, Web Console에 진입할 수 있습니다. </span></span><br><span class="line">listen stats</span><br><span class="line">   <span class="built_in">bind</span> 0.0.0.0:9000 </span><br><span class="line">   mode http</span><br><span class="line">   balance</span><br><span class="line">   <span class="built_in">timeout</span> client 5000</span><br><span class="line">   <span class="built_in">timeout</span> connect 4000</span><br><span class="line">   <span class="built_in">timeout</span> server 30000</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#This is the virtual URL to access the stats page</span></span><br><span class="line">   stats uri /haproxy_stats //URL주소는 ip:9000/haproxy_stats입니다.</span><br><span class="line">   <span class="comment">#Authentication realm. This can be set to anything. Escape space characters with a backslash.</span></span><br><span class="line">   stats realm HAProxy\ Statistics</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#The user/pass you want to use. Change this password!</span></span><br><span class="line">   stats auth admin:1234 <span class="comment">#Web Console에 접근하는 계정/암호 설정</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">#This allows you to take down and bring up back end servers.</span></span><br><span class="line">   <span class="comment">#This will produce an error on older versions of HAProxy.</span></span><br><span class="line">   stats admin <span class="keyword">if</span> TRUE</span><br></pre></td></tr></table></figure>

<p>위의 내용에서는 일단 하나의 Master-Slave에 대한 설정값만 있습니다.<br>여태까지 설치 내용에서는 Master-Slave 구성이 3세트이기 때문에 실제 haproxy.cfg를 작성 할 경우에는<br>5002~5005번 포트를 사용하는 설정에 대해서도 추가해야 합니다.</p>
<h1 id="HAProxy-Web-Console-확인하기"><a href="#HAProxy-Web-Console-확인하기" class="headerlink" title="HAProxy Web Console 확인하기"></a>HAProxy Web Console 확인하기</h1><p><img src="./haproxy1.PNG" alt="haproxy1"></p>
<p><strong>haproxy-server-ip:9000</strong> 으로 접속하였습니다<br>현재 192.168.137.101 서버에는 6379, 6380, 6381 포트를 사용하는 Redis 노드가 3개가 동작하고 있습니다.<br>현재 master 역할을 수행하는 것은 6380 포트를 사용하는 redis2 노드입니다.<br>따라서 <strong>haproxy-server-ip:5000</strong> 으로 접속하게 되면 redis2 노드에 신호가 분배되어 Redis master서버에 대한 명령을 실행 할 수 있습니다.</p>
<p>현재 slave 역할을 수행하는 것은 6379, 6381포트를 사용하는 redis1, redis3노드 입니다.<br>따라서 <strong>haproxy-server-ip:5001</strong>으로 접속하게 되면 RoundRobin 방식으로 redis1, redis3 노드에 신호가 분배되어 Redis slave 서버에 대한 명령을 실행 할 수 있습니다</p>
<blockquote>
<p><strong>HAProxy를 구성한 이유</strong></p>
<p>Application에서 Redis를 사용하면서, Master에만 데이터를 입력하고, Slave에서만 데이터를 조회하려는 행위를 많이 하게 됩니다. 아무래도 Redis서버에 대한 부하를 줄여주고자 이러한 행위를 하게 되는데, Haproxy를 설정 해 두면, Application Server에서 failover로 인해 변하는 master&#x2F;slave 포트에 대한 걱정을 할 필요가 없습니다.<br>HAProxy에서 알아서 tcp-check를 통해 master&#x2F;slave를 정해주기 때문입니다.</p>
</blockquote>
<h1 id="Failover-Test"><a href="#Failover-Test" class="headerlink" title="Failover Test"></a>Failover Test</h1><p>Sentinel 테스트와 동일하게 Master를 죽여보도록 하겠습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;master-node-id&gt;</span><br></pre></td></tr></table></figure>

<p><img src="./haproxy2.PNG" alt="haproxy2"></p>
<p>Master node를 죽이니, 5000번 포트에서는 더이상 master로 갈 수 있는 서버가 없다고 나옵니다.<br>(<strong>이 때 순단을 최소화 하려면 failover 시간과, HAProxy tcp-check 시간을 최소로 줄여야 합니다.</strong>)</p>
<p><img src="./haproxy3.PNG" alt="haproxy3"></p>
<p>잠시 시간이 지나고 Redis Failover가 진행됩니다. 진행이 완료되면, HAProxy에서도 tcp-check가 이루어집니다.</p>
<p><img src="./haproxy4.PNG" alt="haproxy4"></p>
<p>tcp-check가 끝나고 redis1 노드가 master로 선출되어, 5000번 포트로 접근 시, redis1 노드로 분산되게 됩니다.</p>
<p>다시, 죽었던 redis2 노드를 살려보겠습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;redis2_node_id&gt;</span><br></pre></td></tr></table></figure>



<p><img src="./haproxy5.PNG" alt="haproxy5"></p>
<p>redis2 노드가 다시 살아나고, sentinel에서도 role-change 작업이 이루어집니다.<br>곧이어, HAProxy에서도 tcp-check를 통해 redis2노드가 slave가 되었음을 확인하고 5001 포트에서 분배가능한 서버로 분류됩니다.</p>
<p><img src="./haproxy6.PNG" alt="haproxy6"></p>
<p>이와 같이 Application Server에서는 무조건 master port는 5000번, slave port는 5001번 이라고만 알고 있으면 Redis서버에서 failover가 진행되더라도, 설정을 바꿀 필요없이 사용이 가능합니다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="http://blog.whitelife.co.kr/321">http://blog.whitelife.co.kr/321</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/02/2018-12-02-docker-7/">Docker기반 Redis 구축하기 - (7) Docker를 이용한 Redis Sentinel 설치하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-02</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="Redis-Sentinel이란"><a href="#Redis-Sentinel이란" class="headerlink" title="Redis Sentinel이란?"></a>Redis Sentinel이란?</h1><p>Redis Cluster 운영환경에서 Master-Slave 관계를 가진 Redis가 있습니다.<br>시스템 오류나 알수 없는 원인으로 인해 Master Redis가 down되어 연결이 중단 되면, 사용자나 Application에서는 Redis Master를 통해 데이터를 등록 할 수 없게 됩니다.<br>이런 경우 Slave Redis를 Master Redis로 승격시켜 시스템이 정상적으로 운영 될 수 있도록 해야 합니다.</p>
<p>이 때 사용하는 게 Redis Sentinel입니다.<br>Sentinel은 Master Redis의 상태를 감시합니다. 그러다가 Master Redis가 Down이 되어버리면, Sentinel들은 Slave Redis들 중에 어떤 Redis 서버를 Master로 승격시킬지 투표하게 됩니다.<br>Slave Redis 중 Sentinel의 투표를 더 많이 받은 Redis Server가 Master Redis로 승격됩니다.<br>이후 장애를 해결한 원래 Master Redis는 재시작 시, 현재 Master Redis의 Slave Redis로 시작되게 됩니다.</p>
<p>이와같이, Redis Sentinel은 Redis Cluster 환경에서의 Failover를 자동으로 해주는 Redis의 한 Mode입니다.</p>
<h1 id="Role-Change-원리"><a href="#Role-Change-원리" class="headerlink" title="Role Change 원리"></a>Role Change 원리</h1><p><img src="./Redis-failover-1.PNG" alt="Redis-failover-1"></p>
<p>위의 상황은 6379 포트를 사용하는 Master Redis가 Down된 상황입니다.<br>Sentinel들은 일제히 Master Redis를 감시하다가 Down된 상황을 인지하고<br>2번째 그림처럼 Slave Redis들 중 어떤 Redis 서버를 Master Redis로 승격할 지 투표로 정하게 됩니다.<br>여기서 중요한 건 Redis Sentinel의 노드 갯수는 <code>항상 홀수로 설정</code>해야 합니다. (짝수 인 경우 1:1, 2:2 상황이 되어 어떤 Redis Server를 승격 시킬지 알 수 없기 때문입니다.)<br>위의 예제에서는 15485 번 포트를 사용하는 Slave Redis가 2대1로 선택되었습니다.<br>Sentinel은 바로 redis.conf 파일을 조작하여 Slave Redis를 Master Redis로 변경합니다.<br>그리고 자기 자신의 sentinel.conf 정보를 조작하여 감시하는 Redis 서버 정보를 update 합니다.<br>이후 Down되었던 기존의 Master Redis의 장애가 처리되어 Restart되는 경우를 보도록 하겠습니다. </p>
<p><img src="./Redis-failover-2.PNG" alt="Redis-failover-2"></p>
<p>Sentinel은 Down되었던 Master 정보를 메모리에 저장하고 있습니다.<br>이후 Down되었던 Master Redis가 장애를 처리하고 다시 시작 되는 경우, Master Redis의 redis.conf 파일을 조작하여<br>현재 Master Redis의 Slave로 설정합니다.</p>
<blockquote>
<p>이 경우 Sentinel의 설정 값이 따라 다르지만,<br>일시적으로 Master Redis가 2대가 됩니다.<br>만약에 Down 되었다가 Restart된 Redis에 Data가 저장되는 경우, Slave Redis로 전환되면서 Master의 rdb파일을 바탕으로 Data를 Update하기 때문에 데이터가 사라지는 상황이 오게 됩니다.<br>따라서 Down 되었다가 살아나는 Redis에 접근 하지 못하도록 막아야 합니다. </p>
</blockquote>
<h1 id="Redis-Sentinel-설치하기"><a href="#Redis-Sentinel-설치하기" class="headerlink" title="Redis Sentinel 설치하기"></a>Redis Sentinel 설치하기</h1><p>Docker, Docker-Compose, git은 Redis Cluster를 설치하며 설치 했다고 가정하겠습니다.</p>
<h2 id="Redis-Sentinel-파일-다운로드"><a href="#Redis-Sentinel-파일-다운로드" class="headerlink" title="Redis Sentinel 파일 다운로드"></a>Redis Sentinel 파일 다운로드</h2><p>기존에 github에 올려둔 Sentienel 설정파일을 다운로드 합니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /home/redis/redis-sentinel <span class="comment">#Redis-sentinel home 생성</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis</span><br><span class="line"><span class="built_in">mkdir</span> -p ./sentinel-data/sentinel1   <span class="comment">#외부 log파일 볼륨 설정</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ./sentinel-data/sentinel2</span><br><span class="line"><span class="built_in">mkdir</span> -p ./sentinel-data/sentinel3</span><br><span class="line"> </span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">&quot;https://github.com/jaehun2841/redis-sentinel-on-docker.git&quot;</span></span><br><span class="line">git pull origin master <span class="comment">#github에서 sentinel 설정 파일 다운로드</span></span><br></pre></td></tr></table></figure>



<h2 id="Redis-sentinel-Build"><a href="#Redis-sentinel-Build" class="headerlink" title="Redis sentinel Build"></a>Redis sentinel Build</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/redis/redis-sentinel</span><br><span class="line">docker-compose -f conf/sentinel-docker-compose.yml up --build -d </span><br></pre></td></tr></table></figure>



<h1 id="Redis-Sentinel-생성을-위한-docker-compose-yml파일"><a href="#Redis-Sentinel-생성을-위한-docker-compose-yml파일" class="headerlink" title="Redis Sentinel 생성을 위한 docker-compose.yml파일"></a>Redis Sentinel 생성을 위한 docker-compose.yml파일</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-sentinel1:</span>                        <span class="comment">#Sentinel Container명</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span>  <span class="comment">#redis-sentinel 이미지를 바탕으로 빌드합니다.</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span>                        <span class="comment">#Dockerfile context 설정</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>             <span class="comment">#Dockerfile명 설정 (Default는 Dockerfile로 된 파일명을 찾습니다.)</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span>                         <span class="comment">#Container에서 사용할 환경 변수 설정</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=26379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span>                   <span class="comment">#Sentinel의 mymaster port를 적어줍니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">QUORUM=2</span>                          <span class="comment">#QUORUM 값은 Sentinel들이 투표했을때 득표수가 2 이상인 Redis에 대해 Master로 승격할 수 있도록 하는 조건 값입니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span>          <span class="comment">#Redis master node down 후 3초 이후 failover 시작</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../sentinel-data/sentinel1:/redis&quot;</span>  <span class="comment">#Container 외부 볼륨 설정</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span>                         <span class="comment">#restart policy Container가 중지되거나 down되는 경우 무조건 다시 시작합니다.</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-sentinel2:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=26380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">QUORUM=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../sentinel-data/sentinel2:/redis&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-sentinel3:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">lgatica/redis-sentinel:4.0.2</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=26381</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">QUORUM=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DOWN_AFTER_MILLISEC=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FAILOVER_TIMEOUT=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../../sentinel-data/sentinel3:/redis&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>



<h1 id="Redis-Sentinel-이미지-생성을-위한-Dockerfile-작성"><a href="#Redis-Sentinel-이미지-생성을-위한-Dockerfile-작성" class="headerlink" title="Redis Sentinel 이미지 생성을 위한 Dockerfile 작성"></a>Redis Sentinel 이미지 생성을 위한 Dockerfile 작성</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis-sentinel 이미지 기반으로 빌드합니다.</span></span><br><span class="line">FROM lgatica/redis-sentinel:4.0.2   </span><br><span class="line"> </span><br><span class="line">MAINTAINER Carrey </span><br><span class="line"> </span><br><span class="line"><span class="comment">## Copy Redis File</span></span><br><span class="line"><span class="comment">## 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 한다.</span></span><br><span class="line"><span class="comment"># 기존 container의 sentinel-entrypoint.sh 삭제합니다.</span></span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/bin/sentinel-entrypoint.sh         </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel 설정이 담긴 sentinel.conf 파일 복사합니다.</span></span><br><span class="line">ADD sentinel.conf /usr/local/bin/sentinel.conf                          </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel container 시작 시, 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class="line">ADD sentinel-entrypoint.sh /usr/local/bin/sentinel-entrypoint.sh         </span><br><span class="line"> </span><br><span class="line"><span class="comment">## change access authority</span></span><br><span class="line"><span class="comment"># 복사한 파일에 대한 권한을 변경합니다. (Permission Denied 문제)</span></span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /usr/local/bin/sentinel.conf                               </span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /usr/local/bin/sentinel-entrypoint.sh</span><br><span class="line">RUN <span class="built_in">chown</span> redis:redis /usr/local/bin/sentinel.conf</span><br><span class="line">RUN <span class="built_in">chown</span> redis:redis /usr/local/bin/sentinel-entrypoint.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis Container에 대한 Port를 지정합니다. (host 모드이기 때문에 외부 노출)</span></span><br><span class="line">EXPOSE <span class="variable">$CLIENTPORT</span>                                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/usr/local/bin/sentinel-entrypoint.sh&quot;</span>]        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Container 빌드가 완료되고 Sentinel Server를 실행시킵니다. </span></span><br><span class="line"><span class="comment"># conf 파일 뿐만 아니라 --sentinel 옵션을 추가하여 Redis가 Sentinel 모드로 실행 되도록 합니다.</span></span><br><span class="line"><span class="comment"># Sentinel 또한 Redis Server이지만, Sentinel 설정을 하여 실행 시키는 것 뿐입니다.</span></span><br><span class="line">CMD [ <span class="string">&quot;redis-server&quot;</span>,<span class="string">&quot;/usr/local/bin/sentinel.conf&quot;</span>, <span class="string">&quot;--sentinel&quot;</span> ]                          </span><br></pre></td></tr></table></figure>



<h1 id="Redis-Sentinel-설정"><a href="#Redis-Sentinel-설정" class="headerlink" title="Redis Sentinel 설정"></a>Redis Sentinel 설정</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"> </span><br><span class="line"><span class="comment"># bind 127.0.0.1 문자열을 각 이미지에서 설정한 $CLIENTHOST 값으로 변경합니다. </span></span><br><span class="line"><span class="comment"># $CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span>/g&quot;</span> /usr/local/bin/sentinel.conf      </span><br><span class="line">         </span><br><span class="line"><span class="comment"># port 6379 문자열을 각 이미지에서 설정한 $CLIENTPORT 값으로 변경합니다. </span></span><br><span class="line"><span class="comment"># Sentinel 이미지 별로 port다르게 설정</span></span><br><span class="line">sed -i <span class="string">&quot;s/port 6379/port <span class="variable">$CLIENTPORT</span>/g&quot;</span> /usr/local/bin/sentinel.conf  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># sentinel에 대한 mymaster를 설정하는 부분입니다. </span></span><br><span class="line"><span class="comment"># 실제 Master Redis의 ip와 port를 설정하고 QUORUM 값을 설정합니다.</span></span><br><span class="line"><span class="comment"># QUORUM 값은 Slave-&gt;Master Role Change 시, slave redis가 받아야 하는 최소 투표 수 입니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/sentinel monitor mymaster 127.0.0.1 6379 2/sentinel monitor mymaster <span class="variable">$MASTERHOST</span> <span class="variable">$MASTERPORT</span> <span class="variable">$QUORUM</span>/g&quot;</span> /usr/local/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis server가 다운되고 후처리 실행 시간 까지 걸리는 시간을 지정합니다. </span></span><br><span class="line"><span class="comment"># ex)3000 -&gt; 3000 밀리세컨드 -&gt; 3초</span></span><br><span class="line">sed -i <span class="string">&quot;s/sentinel down-after-milliseconds mymaster 30000/sentinel down-after-milliseconds mymaster <span class="variable">$DOWN_AFTER_MILLISEC</span>/g&quot;</span> /usr/local/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Redis failover timeout 시간을 설정 합니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/sentinel failover-timeout mymaster 180000/sentinel failover-timeout mymaster <span class="variable">$FAILOVER_TIMEOUT</span>/g&quot;</span> /usr/local/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># sentinel이 master redis에 접근할 때 인증하는 비밀번호를 설정합니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd/sentinel auth-pass mymaster <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/sentinel.conf</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;1#-&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;1%.conf&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">set</span> -- redis-server <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">chown</span> -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="Redis-Sentinel-실행-결과"><a href="#Redis-Sentinel-실행-결과" class="headerlink" title="Redis Sentinel 실행 결과"></a>Redis Sentinel 실행 결과</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f conf/sentinel-docker-compose.yml up --build -d </span><br></pre></td></tr></table></figure>



<p><img src="./redis-sentinel-log.PNG" alt="redis-sentinel-log"></p>
<p>sentinel 1<del>3 까지의 로그를 모아보았습니다.<br>테스트용 port인 (6379</del>6381) 에 대한 master&#x2F;slave 정보를 가지고 있는것을 볼수 있습니다.</p>
<p>로그처럼</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel2_1  | 1:X 02 Dec 10:06:24.082 # +monitor master mymaster 192.168.137.101 6379 quorum 2</span><br></pre></td></tr></table></figure>
<p>sentinel이 자신의 마스터에 대한 정보를 가지고 모니터 하며 quorum 2를 가지고 있는 것을 볼 수 있습니다.</p>
<h1 id="Failover-Test"><a href="#Failover-Test" class="headerlink" title="Failover Test"></a>Failover Test</h1><p>자, Failover를 구성 했으니 실제로 Master를 한번 죽여보도록 해보겠습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;master_node_id&gt; <span class="comment"># Redis Master Container를 중지</span></span><br></pre></td></tr></table></figure>

<p><img src="./redis-failover-log.PNG" alt="redis-failover-log"></p>
<p>맨 처음 로그를 살펴보면 각 sentinel 노드에서 sdown 시그널을 발생시키고 있습니다.</p>
<p>중간정도 줄을 보면</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+odown master mymaster 192.168.137.101 6379 <span class="comment">#quorum 3/2</span></span><br></pre></td></tr></table></figure>

<p>라는 로그가 나오게 되는데 3개의 sentinel에서 모두 sdown으로 인지하게 되는것입니다.<br>3&#x2F;2의 뜻은  2개 노드에서 sdown이 발생 했을 때, odown 판정을 내린다는 다수결 투표 숫자입니다.<br>그런데 3개의 노드가 모두 투표를 하여 과반수 이상이 되었으므로 192.168.137.101 6379인 Redis 노드는 odown상태가 되었습니다.</p>
<p>그 바로 다음 줄 부터 failover 작업이 시작됩니다.<br>위의 예제에서는 6380 포트를 사용하는 redis노드가 새로운 마스터로 선출 되었습니다.<br>따라서 6380 포트를 사용하는 redis노드는 master로 role-change가 되면서 master 노드로써 역할을 수행하게 됩니다.</p>
<p>이렇게 Redis Sentinel을 이용하여 master node를 감시하며, 장애 상황에 대한 failover를 지원하고 있습니다.</p>
<h2 id="sdown-vs-odown"><a href="#sdown-vs-odown" class="headerlink" title="sdown vs odown"></a>sdown vs odown</h2><p>Sentinel에서 down을 판단하는 방법은 <code>sdown</code>과 <code>odown</code>으로 이루어집니다.<br>failover 시 Master가 죽었다는 걸 판단하기 위해서는 <code>다수결의 원칙</code>이 적용됩니다. (그래서 Sentinel노드 갯수를 홀수로 설정하는 이유입니다.)</p>
<p>먼저, Master가 죽게 되면 Sentinel은 자신이 감시하고 있는 Master가 죽었다고 sdown 시그널을 표현합니다 (<code>Subjective Down</code> 이라 합니다.)<br>sdown은 단지 Master와 Sentinel 자기 자신이 연결이 되지 않음을 의미합니다.</p>
<p>위에서 보듯이 Master가 죽었으니 다른 Sentinel들도 연결이 끊어졌다고 sdown 시그널을 보냅니다.<br>그렇게 되면 다수결에 원칙에 따라 quorum값 만큼의 sdown이 발생하면 sentinel은 odown 시그널을 보냅니다. (<code>Objective Down</code>이라 합니다.)</p>
<p>odown은 다수결에 의해서 명시적으로 Master가 Down되었다고 선포하는 것과 같습니다.<br>그렇게 되면 Sentinel들은 다음 Master를 선출하기 위해 남아있는 Slave Redis들에게 투표를 하게 됩니다.<br>다수결의 원칙으로 더 많은 투표수를 받은 Slave가 Master로 선출되게 됩니다.</p>
<h2 id="중단되었던-6379-포트를-사용하는-Redis-노드가-살아나면"><a href="#중단되었던-6379-포트를-사용하는-Redis-노드가-살아나면" class="headerlink" title="중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?"></a>중단되었던 6379 포트를 사용하는 Redis 노드가 살아나면?</h2><p>아까 stop했던 container를 다시 살려보겠습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;redis1_node_id&gt;</span><br></pre></td></tr></table></figure>

<p><img src="./redis-failover-3-3748019.PNG" alt="redis-failover-3"></p>
<p>3번째 줄부터 보시면, sentinel에서 <code>-sdown</code> 로그를 찍어주고 있습니다.<br>sentinel에서 연결되지 않았던 6379번 노드에 대해 정상적으로 커넥션이 맺어지고 있기 때문입니다.<br>중간 줄 부터 보게 되면다른 sentinel 노드에서도 <code>-sdown</code> 로그를 찍어주며 6379번 노드에 대한 부활을 알려주고 있습니다.</p>
<p>그런 다음에 <code>+convert-to-slave</code> 로그를 보면, 기존의 6379번 노드는 원래 master role을 수행 하던 Redis 노드였습니다.<br>하지만 현재 sentinel에 대한 mymaster는 6380번 노드이기 때문에 6379번 노드는 master role을 수행 할 수 없습니다.</p>
<p>따라서  <code>+role-change</code> 명령을 통해  기존에 master role -&gt; slave role로 변경되어야 합니다.<br>그리고 현재 master role 권한이 있는 6380번 노드의 slave으로 편입되게 됩니다.<br>redis-cli를 통해 6379번 노드에 접속하여 <code>info replication</code> 명령을 날려보았습니다.</p>
<p><img src="./redis-failover-4.PNG" alt="redis-failover-4"></p>
<p>현재 role은 <code>slave</code> 이며, 6380번 노드를 master로 설정하고 있습니다.</p>
<blockquote>
<p><strong>왜 기존의 master가 살아나면, slave로 전환하여 사용해야 할까?</strong></p>
<p>이유는 간단합니다.<br>Redis Master-Slave간 데이터 Replication을 이해 하면 쉽게 이해 할 수 있습니다<br>Redis의 데이터 Replication은 dump.rdb파일을 통해 이루어지는데,<br>master노드 만 dump.rdb파일에 데이터를 write 할 수 있습니다.<br>slave노드에서는 dump.rdb파일을 읽어서 데이터 replication을 하게 되는데,<br>만약 기존의 master의 role이 유지된다면, dump.rdb파일을 조작하여 기존의 master가 다운된 시간 동안<br>들어온 데이터가 삭제될 수 있습니다.<br>그렇게 때문에 데이터 정합성을 위해 기존의 master는 slave로 role이 전환되어야 합니다.</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/01/2018-12-01-docker-6/">Docker기반 Redis 구축하기 - (6) Docker를 이용한 Redis Cluster 설치하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="Redis-Cluster-구성도"><a href="#Redis-Cluster-구성도" class="headerlink" title="Redis Cluster 구성도"></a>Redis Cluster 구성도</h1><p><img src="./Redis-Cluster-archi.PNG" alt="Redis-Cluster-archi"></p>
<p>간단하게 정리하면.</p>
<ul>
<li>각 서버 별로 Redis 3대를 설치. Master 1개, Slave 2개로 구성하여 Replication을 지원할 수 있도록 Cluster를 구성하였습니다.</li>
<li>각 서버 별로 Sentinel 3대를 설치. 양대비 원리에 맞추어 홀수개로 설정 하였습니다.</li>
<li>각각의 서버의 Sentinel 3대가 서버의 Master Redis를 감시합니다. (Failover 대기)</li>
<li>Redis Cluster를 서버 3대에 설치. Data Sharding을 하기 위해 저장소를 3개로 분리하였습니다.</li>
<li>HAProxy로 분산 처리 구축. 5000, 5002, 5004번 포트는 각 서버의 Master Redis를 바라봅니다.</li>
<li>5001, 5003, 5005번 포트는 각 서버의 Slave Redis 2대씩 바라봅니다.</li>
</ul>
<p>지금부터 Redis Cluster를 어떻게 설치 하였는지 설치 과정에 대해 알아보도록 하겠습니다.</p>
<h1 id="Docker를-이용한-Redis-Cluster-설치"><a href="#Docker를-이용한-Redis-Cluster-설치" class="headerlink" title="Docker를 이용한 Redis Cluster 설치"></a>Docker를 이용한 Redis Cluster 설치</h1><p>Redis-Cluster를 설치하는 순서는 아래와 같습니다. (CentOS 7기준으로 설치 하였습니다.)</p>
<ul>
<li>Git 설치 (미리 올려둔 Docker file들을 다운받기 위함)</li>
<li>Docker 설치</li>
<li>Docker-Compose 설치</li>
<li>Docker Build</li>
</ul>
<h2 id="Git-설치-Docker-file-다운로드"><a href="#Git-설치-Docker-file-다운로드" class="headerlink" title="Git 설치 + Docker file 다운로드"></a>Git 설치 + Docker file 다운로드</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git설치</span></span><br><span class="line">yum -y install git</span><br><span class="line">git --version <span class="comment"># git 버전 확인</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Redis-Cluster 디렉터리 생성</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Redis-Cluster-Home 이동</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#아래 디렉터리들은 각 Redis Container의 외부볼륨으로 설정하기 위해 생성하였습니다.</span></span><br><span class="line"><span class="comment">#==&gt; Container 외부 볼륨을 설정해야 Redis Container가 삭제되더라도 Data가 보존됩니다.</span></span><br><span class="line"><span class="comment">#===&gt; dump.rdb 파일이 생성되는 장소</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ./redis-data/redis1</span><br><span class="line"><span class="built_in">mkdir</span> -p ./redis-data/redis2</span><br><span class="line"><span class="built_in">mkdir</span> -p ./redis-data/redis3</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Docker file Download</span></span><br><span class="line"><span class="comment">#설치파일을 다운받습니다.</span></span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">&quot;https://github.com/jaehun2841/redis-cluster-on-docker.git&quot;</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>



<h2 id="Docker-설치"><a href="#Docker-설치" class="headerlink" title="Docker 설치"></a>Docker 설치</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 설치</span></span><br><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line"> </span><br><span class="line"><span class="comment">#docker 설치 후 docker 시작</span></span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<p>Docker를 yum으로도 설치가 가능하지만 버전이 낮아 Docker-compose를 설치 할 수 없습니다.<br>차후에 update까지 필요하니 위 url에서 제공하는 shell script를 실행하여 설치하도록 합니다.<br><strong>※ 위 Script는 sudo 명령 또는 root 권한을 필요로 합니다.</strong></p>
<p>Docker 설치 내용은 2장에서 기술한 내용을 참고하시길 바랍니다.</p>
<h2 id="Docker-Compose-설치"><a href="#Docker-Compose-설치" class="headerlink" title="Docker-Compose 설치"></a>Docker-Compose 설치</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 공식 github에서 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>Docker-Compose 설치 내용은 4장에서 기술한 내용을 참고하시길 바랍니다.</p>
<h2 id="Docker-build"><a href="#Docker-build" class="headerlink" title="Docker build"></a>Docker build</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cluster home 이동</span></span><br><span class="line"><span class="built_in">cd</span> /home/redis/redis-cluster</span><br><span class="line"> </span><br><span class="line"><span class="comment">#docker build</span></span><br><span class="line">docker-compose -f conf/docker-compose.yml up --build -d</span><br></pre></td></tr></table></figure>

<ul>
<li>-f 옵션으로 docker-compose.yml 파일을 설정합니다.<br>(docker-compose.yml 파일은 github redis-cluster 설치파일을 받을때 다운 받았습니다. )</li>
<li>up 명령으로 docker container를 실행합니다.</li>
<li>–build 옵션으로 build후 container를 실행합니다.</li>
<li>-d 옵션으로 background로 실행되도록 합니다.<br>(-d 옵션을 빼면 redis의 로그가….나오며 exit하는 순간 container가 stop됩니다.)</li>
</ul>
<h1 id="Redis-Cluster를-빌드하기-위한-docker-compose-yml-파일"><a href="#Redis-Cluster를-빌드하기-위한-docker-compose-yml-파일" class="headerlink" title="Redis Cluster를 빌드하기 위한 docker-compose.yml 파일"></a>Redis Cluster를 빌드하기 위한 docker-compose.yml 파일</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-master:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span>   <span class="comment"># image 옵션으로 redis공식이미지를 기반으로 생성합니다.</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span>             <span class="comment"># build file에 대한 context를 지정</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>  <span class="comment">#dockerfile명을 지정합니다. (Default는 &quot;Dockerfile&quot; 파일명을 가진 파일을 실행합니다.)</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span>      <span class="comment"># Image가 Container가 되었을때 network모드를 host모드로 설정합니다 (docker0 인터페이스를 사용하지 않고 Host OS의 eth0 인터페이스 사용)</span></span><br><span class="line">     <span class="string">environment:</span>              <span class="comment"># Container 내부에서 사용 할 환경변수를 설정합니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=</span></span><br><span class="line">     <span class="string">volumes:</span>  <span class="comment"># Host OS의 디렉터리와 Container내의 디렉터리와 연동합니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../redis-data/redis1:/data&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-slave1:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../redis-data/redis2:/data&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">redis-slave2:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">     <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=password1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6381</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.137.101</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.137.101</span> </span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;../redis-data/redis3:/data&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Redis Container의 Network모드가 Host인 이유</strong><br>Redis 공식 홈페이지의 cluster-tutorial에서 발췌한 내용입니다.</p>
<blockquote>
<p>Redis Cluster and Docker</p>
<p>Currently Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.<br>Docker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.<br>This is useful in order to run multiple containers using the same ports, at the same time, in the same server.<br><code>In order to make Docker compatible with Redis Cluster you need to use the host networking mode of Docker.</code> Please check the –net&#x3D;host option in the Docker documentation for more information.</p>
</blockquote>
<p>Redis Cluster에서는 NAT환경과 IP주소 또는 TCP포트가 재 매핑되는 환경을 지원하지 않는다고 합니다.<br>따라서 Docker에서 Redis Cluster를 호환되게 하기 위해서는 Host 모드로 사용할 것을 권고하고 있습니다.</p>
</blockquote>
<h1 id="Redis-Container-생성을-위한-Dockerfile-작성"><a href="#Redis-Container-생성을-위한-Dockerfile-작성" class="headerlink" title="Redis Container 생성을 위한 Dockerfile 작성"></a>Redis Container 생성을 위한 Dockerfile 작성</h1><p>Docker-Compose build를 사용하면서 Dockerfile에는 Redis Container를 구성하는 공통적인 로직을 담았습니다.<br>주로 내부에서 file을 생성하거나 Host OS의 파일을 Container가 생성하는 시점에 복사하기 위한 로직이 주로 들어있습니다.<br>그리고 접근권한이 막혀 파일이 실행되지 않는 문제를 해결하기 위해 접근권한을 변경하였습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FROM redis:5.0-alpine //redis 이미지를 기반으로 빌드됨을 의미합니다.</span><br><span class="line"> </span><br><span class="line">MAINTAINER Carrey (jaehun2841@gmail.com)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Copy Redis File</span></span><br><span class="line"><span class="comment"># 복사/추가 하는파일의 Container내 경로는 항상 절대경로로 작성하여야 합니다.</span></span><br><span class="line"><span class="comment"># 기존의 docker-entryporint.sh 파일을 삭제합니다.</span></span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/bin/docker-entrypoint.sh  </span><br><span class="line"><span class="comment"># 공통적으로 적용할 redis.conf 파일을 복사합니다.</span></span><br><span class="line">ADD redis.conf /usr/local/bin/redis.conf    </span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행 시킬 docker-entrypoint.sh 파일을 복사합니다.</span></span><br><span class="line">ADD docker-entrypoint.sh /usr/local/bin        </span><br><span class="line"> </span><br><span class="line"><span class="comment">## change access authority</span></span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /usr/local/bin/redis.conf</span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /usr/local/bin/docker-entrypoint.sh</span><br><span class="line"> </span><br><span class="line">RUN <span class="built_in">chown</span> redis:redis /usr/local/bin/redis.conf</span><br><span class="line">RUN <span class="built_in">chown</span> redis:redis /usr/local/bin/docker-entrypoint.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#Redis Container에 대한 Port를 지정합니다. (내부포트이며 외부노출은 안됨)</span></span><br><span class="line">EXPOSE <span class="variable">$CLIENTPORT</span> <span class="comment">#CLIENTPORT에 대한 값은 docker-compose.yml에 정의되어 있습니다.          </span></span><br><span class="line"><span class="comment"># Container가 생성, 시작하는 시점에 실행됩니다.</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/usr/local/bin/docker-entrypoint.sh&quot;</span>] </span><br><span class="line"><span class="comment"># Container 빌드가 완료되고 Redis Server를 실행시킵니다.</span></span><br><span class="line">CMD [ <span class="string">&quot;redis-server&quot;</span>,<span class="string">&quot;/usr/local/bin/redis.conf&quot;</span> ] </span><br></pre></td></tr></table></figure>



<h1 id="Redis-Cluster-설정"><a href="#Redis-Cluster-설정" class="headerlink" title="Redis Cluster 설정"></a>Redis Cluster 설정</h1><p>Redis Cluster에 대한 Replication 설정에 대해 알아보겠습니다.</p>
<p>설정 방법은 redis.conf 파일을 각 Container로 복사하여 공통적인 설정을 하였습니다.<br>각 redis.conf 파일에 대한 변경사항은 <code>docker-entrypoint.sh</code> 파일을 통해 redis.conf 파일 정보를 replace하였습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"> </span><br><span class="line"><span class="comment">## from redis-5.0</span></span><br><span class="line"><span class="comment"># Redis서버에 접근가능한 Host를 설정합니다.</span></span><br><span class="line">sed -i <span class="string">&quot;s/bind 127.0.0.1/bind <span class="variable">$CLIENTHOST</span> 127.0.0.1/g&quot;</span> /usr/local/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">### redis port inside redis.conf</span></span><br><span class="line"><span class="comment">#redis.conf 파일의 port 6379 문자열을 port $CLINETPORT로 변경합니다. </span></span><br><span class="line"><span class="comment">#($CLIENTPORT는 docker-compose.yml파일의 Environment에서 지정하였습니다.)</span></span><br><span class="line">sed -i <span class="string">&quot;s/port 6379/port <span class="variable">$CLIENTPORT</span>/g&quot;</span> /usr/local/bin/redis.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># requirepass foobared 문자열을 requirepass $REQUIREPASS로 변경하였습니다. </span></span><br><span class="line"><span class="comment">#(Redis 접속 시 비밀번호를 설정하였습니다.)</span></span><br><span class="line">sed -i <span class="string">&quot;s/# requirepass foobared/requirepass <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/redis.conf          </span><br><span class="line">sed -i <span class="string">&quot;s/# masterauth &lt;master-password&gt;/masterauth <span class="variable">$REQUIREPASS</span>/g&quot;</span> /usr/local/bin/redis.conf   </span><br><span class="line"></span><br><span class="line"><span class="comment">### slaveof &lt;masterip&gt; &lt;masterport&gt; =&gt; slaveof $MASTERHOST $MASTERPORT</span></span><br><span class="line"><span class="comment"># $MASTERPORT가 공백이 아닌 Container에 대해 slaveof 설정을 통해 Master-Slave 설정을 합니다.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$MASTERPORT</span>&quot;</span> != <span class="string">&quot;&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    sed -i <span class="string">&quot;s/# slaveof &lt;masterip&gt; &lt;masterport&gt;/slaveof <span class="variable">$MASTERHOST</span> <span class="variable">$MASTERPORT</span>/g&quot;</span> /usr/local/bin/redis.conf  </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;1#-&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;1%.conf&#125;</span>&quot;</span> != <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">set</span> -- redis-server <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">chown</span> -R redis .</span><br><span class="line">    <span class="built_in">exec</span> su-exec redis <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="Redis-Cluster-실행-결과"><a href="#Redis-Cluster-실행-결과" class="headerlink" title="Redis Cluster 실행 결과"></a>Redis Cluster 실행 결과</h1><p>Redis.log<br><img src="./redis-replication-3746317.PNG" alt="redis-replication"></p>
<p>로그에서 0 clients connected (2 slaves) 라는 로그가 보입니다.<br>Redis에 접속한 클라이언트 수는 0 client이며<br>2개의 slave redis와 연결하고 있습니다.</p>
<p>중간부분 로그에서 로그를 보면 slave로 설정한 Redis와 연동이 되는 것을 확인 할 수 있습니다.</p>
<p>redis-cli &gt; info replication<br><img src="./redis-replication2-3746337.PNG" alt="redis-replication2"></p>
<p>redis-cli에서 info replication 명령을 실행하였을 때, 조회되는 내용입니다.<br>slave0, slave1에 대한 참조를 가지고 있는 것을 확인 할 수 있습니다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/01/2018-12-01-docker-5/">Docker기반 Redis 구축하기 - (5) Docker Network구조</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="Docker-Network-모드"><a href="#Docker-Network-모드" class="headerlink" title="Docker Network 모드"></a>Docker Network 모드</h1><p>Docker에서 제공하는 Network 모드는 총 4개 입니다.<br>(추가적으로 2개의 모드가 더 있습니다. Overlay, Macvlan 모드가 있지만 Docker Swarm과 관련된 내용이므로 이번 장에서는 기술 하지 않겠습니다.)</p>
<ul>
<li>Bridge 모드</li>
<li>Container 모드 (이것도 Bridge 모드의 일종)</li>
<li>Host 모드</li>
<li>none 모드</li>
</ul>
<p>이번 장에서는 위 Network 모드에 대해 알아보도록 하겠습니다.</p>
<h1 id="Bridge-모드"><a href="#Bridge-모드" class="headerlink" title="Bridge 모드"></a>Bridge 모드</h1><p>Docker에서 network 설정을 별도로 하지 않으면 Default로 작용하는 모드입니다.<br>Docker가 설치되면 docker0라는 네트워크 인터페이스가 생성됩니다. (Virtual Interface)</p>
<p><img src="./docker-bridge-mode.png" alt="docker-bridge-mode"></p>
<p>위는 docker0 인터페이스를 바탕으로 각 Container와 Bridge 형식으로 엮어진 모습입니다.</p>
<p><img src="./docker-bridge-2.PNG" alt="docker-bridge-2"></p>
<p>Host OS에서 network interface를 검색해 보면 docker0라는 virtual interface를 확인할 수 있습니다.</p>
<blockquote>
<p><strong>docker0 interface의 특징</strong></p>
<ul>
<li>IP는 자동으로 172.17.0.1로 설정</li>
<li>IP는 DHCP로 할당받는 것이 아닌 Docker 내부로직에 의해 결정</li>
<li>docker0는 virtual ethernet bridge</li>
<li>L2 통신 기반</li>
</ul>
</blockquote>
<p><code>&quot;docker bridge 모드는 같은 host 내에서만 사용 가능하다.&quot;</code> 라는 제약이 있다.<br>즉, 다른 host(다른서버)와의 docker와는 통신이 불가능합니다.<br>왜냐하면 다른 서버가 docker0 인터페이스의 외부에 있기 때문에 그렇습니다.</p>
<h1 id="docker0-interface와-Container의-연결-방식"><a href="#docker0-interface와-Container의-연결-방식" class="headerlink" title="docker0 interface와 Container의 연결 방식"></a>docker0 interface와 Container의 연결 방식</h1><p><img src="./docker0-interface.PNG" alt="docker0-interface"></p>
<p>위 이미지를 보면, 현재 Docker를 이용하여 redis와 nginx를 설치한 상태입니다.<br>두 번째 명령을 보면 brctl명령으로 docker0 interface에 연결된 interfaces가 2개 보입니다.</p>
<ul>
<li>veth062947b</li>
<li>veth3b5bdll</li>
</ul>
<p>container 2개가 bridge 방식으로 연결 되어 있기 때문에 veth~하는 interface가 생성되어있습니다.<br>위에 그림에서 보듯이 veth와 각 container 내부의 eth0 interface와 연결되어 있습니다.</p>
<p><img src="./ip.PNG" alt="ip"></p>
<p>Redis Container에 대해 docker inspect 명령을 날려보았습니다.<br>네트워크 설정 부분이 아래에 나오는데 Network 부분을 보시면 Gateway는 172.17.0.1이라 되어 있습니다.<br>이 ip 주소는 docker0 interface의 ip주소입니다.<br>따라서 docker0의 bridge로 연결되어 172.17.0.2라는 내부 ip를 가진 Container로 생성된 것입니다.</p>
<h1 id="Container-모드-이것도-Bridge-모드의-일부"><a href="#Container-모드-이것도-Bridge-모드의-일부" class="headerlink" title="Container 모드 (이것도 Bridge 모드의 일부)"></a>Container 모드 (이것도 Bridge 모드의 일부)</h1><p>Container 모드는 다른 Container의 네트워크 리소스를 같이 쓰는? 개념입니다.</p>
<p>먼저 httpd를 설치하고..<br>그다음에 redis를 설치하여 httpd의 container 정보를 가지고 net설정을 해주었습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d httpd</span><br><span class="line">docker run -d --net=container:(httpd의 containerId) redis</span><br></pre></td></tr></table></figure>

<p><img src="./httpd.PNG" alt="httpd"></p>
<p>위 이미지(httpd에 대한 정보)를 보면 docker0 interface를 이용하고 bridge 모드로 설정되어 있습니다.</p>
<p><img src="./redis1.PNG" alt="redis1"></p>
<p>하지만, Redis의 Network 정보를 보면 텅텅 비어있습니다.<br>이는 docker0 interface를 통해 네트워크 설정이 bind 되지 않았다는 의미입니다.</p>
<p>약간 위로 올려보면</p>
<p><img src="./redis2.PNG" alt="redis2"></p>
<p>NetworkMode에 httpd의 container 자원을 사용하여 접근하는 것을 알 수 있습니다.<br>다른 docker image 중 내부 명령어로 ip addr을 지원하는 image가 있다면</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &lt;container ID&gt; ip addr show</span><br></pre></td></tr></table></figure>

<p>위 명령을 통해 Mac Address가 Container자원을 할당한 Container의 Mac Address와 같음을 알 수 있습니다.</p>
<h1 id="Host-모드"><a href="#Host-모드" class="headerlink" title="Host 모드"></a>Host 모드</h1><p>Host 모드는 docker0 interface를 사용하지 않고 Host OS의 네트워크 자원을 사용합니다.<br>bridge 형식으로 사용하지 않기 때문에 brctl show docker0 명령으로 검색해도 interfaces에 나타나지 않습니다.<br><strong>Bridge를 쓰지 않기 때문에 Container에서 <code>Port를 노출하지 않는 경우 사용할 수가 없는 점</code>을 유의 해야 합니다.</strong><br>(Redis Cluster를 구성 할 때에도 Redis에서는 Cluster모드 구현 시, docker bridge mode를 지원하지 않기 때문에 host로 설정했었습니다.)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=host -p <span class="string">&quot;6515&quot;</span> <span class="comment">#이렇게 옵션을 추가해주면 됩니다. (port는 문자열로!)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#또는 docker-compose.yml 파일에서</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">network_mode:</span> <span class="string">host</span> <span class="comment">#이 처럼 표기하시면 됩니다.</span></span><br></pre></td></tr></table></figure>



<h1 id="none-모드"><a href="#none-모드" class="headerlink" title="none 모드"></a>none 모드</h1><p>–net&#x3D;none 옵션으로 Container 생성 시, 격리된 네트워크 영역을 갖기는 하지만 network 인터페이스가 없는 Container가 생성 됩니다.</p>
<p>아래의 코드로 테스트를 해보았습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=none -d httpd</span><br><span class="line">docker <span class="built_in">exec</span> httpd ip addr show</span><br></pre></td></tr></table></figure>

<p><img src="./none.PNG" alt="none"></p>
<p>검색되는 내부 네트워크 인터페이스가 없습니다.</p>
<blockquote>
<p><strong>none으로 처리하는 이유</strong><br>network mode를 none으로 하는 경우는 보통 사용자 정의 interface를 사용할 때 입니다.<br>network 환경을 깔끔하게 만든 다음에 사용자 정의 interface를 적용하기 위함입니다.</p>
</blockquote>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="http://bluese05.tistory.com/38">http://bluese05.tistory.com/38</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network">https://docs.docker.com/network/network-tutorial-standalone/#use-the-default-bridge-network</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/network/network-tutorial-host/">https://docs.docker.com/network/network-tutorial-host/</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/01/2018-12-01-docker-4/">Docker기반 Redis 구축하기 - (4) Docker-Compose 설치 및 사용방법</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="Docker-Compose-이란"><a href="#Docker-Compose-이란" class="headerlink" title="Docker-Compose 이란?"></a>Docker-Compose 이란?</h1><p>기존에는 Docker를 이용해서 1개의 이미지를 바탕으로 하나의 소프트웨어에 대한 컨테이너를 만들 수 있었습니다.<br>하지만 목표는 Web Server도 설치하고, DB도 설치하고, IDE도 설치해서 한 세트로 배포를 해주고 싶은데… 지금까지 배운 방법으로는 Docker image를 내가 필요한 것만큼 다운받아서 Container를 생성해야 합니다.</p>
<p>이때 필요한 개념이 Docker-Compose입니다.<br>Docker-Compose는 사용자에게 한번에 여러가지 소프트웨어에 대한 이미지 정보를 담아 빌드 할 수 있습니다.<br>사용자는 Docker-Compose로 만든 파일을 다운받아 이미지 내에 포함된 소프트웨어에 대한 Container를 한번에 만들 수 있습니다.</p>
<h1 id="Docker-Compose-설치"><a href="#Docker-Compose-설치" class="headerlink" title="Docker-Compose 설치"></a>Docker-Compose 설치</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker 공식 github에서 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>다운로드 받은 docker-compose 파일을 실행 가능한 파일로 만듭니다.<br>(보통의 리눅스 실행파일 path는 <code>/usr/local/bin</code>입니다. <strong>OS별로 다를 수 있습니다.</strong>)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>



<h1 id="Docker-compose-yml"><a href="#Docker-compose-yml" class="headerlink" title="Docker-compose.yml"></a>Docker-compose.yml</h1><p>Docker-compose.yml 파일은 생성하고자 하는 Container들의 image 정보들을 담고 있는 설정 파일입니다.<br>여기에 설치하고자 하는 소프트웨어들의 빌드정보를 지정 할 수 있습니다.<br>또한 Docker에서 사용한 설정정보를 기술 할 수 있어 사용자는 파일을 받아 별도의 옵션 없이 Container만 생성하면 됩니다.</p>
<h1 id="Docker-Compose-yml에서-자주-사용하는-options"><a href="#Docker-Compose-yml에서-자주-사용하는-options" class="headerlink" title="Docker-Compose.yml에서 자주 사용하는 options"></a>Docker-Compose.yml에서 자주 사용하는 options</h1><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>build는 해당 이미지가 빌드 될 때 사용 할 Dockerfile을 지정할 수 있는 options입니다.</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">     <span class="attr">build:</span></span><br><span class="line">       <span class="attr">context:</span> <span class="string">..</span></span><br><span class="line">       <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">       <span class="attr">args:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">buildno :</span> <span class="number">1</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">username :</span> <span class="string">carrey</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>context : dockerfile의 위치를 지정합니다. Default는 현재위치 (.&#x2F;) 입니다.</p>
</li>
<li><p>dockerfile : dockerfile명을 지정합니다 Default는 Dockerfile 입니다.</p>
</li>
<li><p>args : Dockerfile내에서 사용할 Arguments를 설정합니다.</p>
</li>
</ul>
<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>command는 Dockerfile에서 CMD역할을 했던 명령을 <code>Override</code>합니다.<br>(Dockerfile과 같이 사용하는 경우 Dockerfile의 CMD명령이 아닌 <code>Docker-compose의 command명령이 실행</code>)</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line">  <span class="attr">command :</span> <span class="string">startup.sh</span> <span class="string">-p</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>



<h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h2><p>Docker-compose 내의 이미지가 2개 이상인 경우 실행 의존성을 줄 수 있습니다.<br>예를들어 DB가 먼저 실행된 다음에 WAS가 실행되어야 하는 경우 Docker-Compose에서는 depend_on 설정에 따라 다른 이미지를 먼저 빌드 합니다.</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span> <span class="string">//web</span> <span class="string">이미지에</span> <span class="string">대한</span> <span class="string">Container는</span> <span class="string">redis와</span> <span class="string">db가</span> <span class="string">생성되고</span> <span class="string">시작되기</span> <span class="string">전에는</span> <span class="string">빌드되지</span> <span class="string">않습니다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span>       </span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>



<h2 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h2><p>Container가 run 또는 start 시, entrypoint 로직을 실행 합니다.<br>entrypoint와 Dockerfile이 함께 사용되는 경우, <code>Dockerfile의 ENTRYPOINT설정은 무시됩니다.</code></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1 :</span> </span><br><span class="line">	<span class="attr">image:</span> <span class="string">redis:5.0-alpine</span></span><br><span class="line">	<span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure>



<h2 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h2><p>Env 파일을 Container 내부에 import 하는 경우에 사용합니다.</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line">	<span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="attr">env_file :</span> <span class="string">../env/environments.env</span></span><br></pre></td></tr></table></figure>



<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>Container 내부에서 사용할 환경 변수를 등록합니다.</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis1:</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REQUIREPASS=1234</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTHOST=192.168.130.93</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLIENTPORT=6380</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERHOST=192.168.130.93</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MASTERPORT=6379</span></span><br></pre></td></tr></table></figure>



<h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><p>Container내의 내부 포트만 설정 (외부 노출은되지 않습니다.)<br>link된 Container끼리는 expose에 설정된 포트로 통신이 가능</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">	<span class="attr">expose:</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line">	  <span class="bullet">-</span> <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h2><p>Host OS 포트와 Container 내부포트 매핑 (포트포워딩)<br>Host OS 포트를 사용할 수 있으므로 외부접속이 가능</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;80:8080&quot;</span>  <span class="comment"># &lt;Host OS포트&gt; : &lt;컨테이너 내부포트&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">#Short Syntax --&gt; 권장하는 방식</span></span><br><span class="line"><span class="attr">ubuntu:</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span>        <span class="comment">#이 구문은 &quot;3000:3000&quot; 과 동일</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3000-3005&quot;</span>   <span class="comment">#이 구문은 &quot;3000-3005:3000-3005&quot;와 동일</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;9090-9091:8080-8081&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;49100:22&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:5000-5010:5000-5010&quot;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;6060:6060/udp&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#Long Syntax --&gt; 권장하지 않는 방식</span></span><br><span class="line"><span class="attr">tomcat2:</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">target :</span> <span class="number">8080</span> <span class="comment">#Container 내부포트</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">published :</span> <span class="number">80</span> <span class="comment"># 외부 OS 포트</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">protocol :</span> <span class="string">tcp</span> <span class="comment"># tcp 또는 udp</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">mode :</span> <span class="string">host</span> <span class="comment">#host: 각각의 Container 노드와 1:1로 매핑 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>포트 매핑 시 주의 할 점<br>Host : Container 형식으로 포트를 매핑하면 YAML이 xx:yy 형식은 구문 분석시에 default를 60으로 주기 때문에 60번 이하 포트에 대해서 잘못된 결과가 초래될 수 있음.<br>(8000 : 22 와 같이 숫자만 적는 경우 문제가 발생)<br>따라서, <code>포트 매핑은 항상 문자열로 적어야 합니다.</code><br>( “8000 : 22”와 같이 문자열로 선언해야 안전합니다. ) &#x3D;&#x3D;&gt; 60번 이하 포트를 쓰지말라는 소리가 아님.</p>
</blockquote>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>어떤 image를 바탕으로 생성할 것인지 지정합니다.</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> </span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">ubuntu:</span> </span><br><span class="line">      <span class="attr">image:</span> <span class="string">ubuntu:14.04</span></span><br></pre></td></tr></table></figure>



<h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><ul>
<li>다른 Container와 연결하기 위해 설정합니다.</li>
<li>외부 Port노출이 안되어도 Expose명령으로 노출된 Port로 연결</li>
<li>network_mode가 <code>host인 경우 사용할 수 없습니다.</code> (host인 경우 Host OS의 port를 직접 사용하기 때문)</li>
<li>서비스 이름:Alias 형태로 선언하거나 서비스 이름만 지정합니다.</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">  <span class="attr">link:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db:mycontainerdb-alias</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">db:</span> </span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">redis:</span> </span><br><span class="line">  <span class="attr">image:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>



<h2 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h2><p>Docker network policy 설정 (다음 장에 상세 설명하겠습니다.)</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;service:[service name]&quot;</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">&quot;container:[container name/id]&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Docker Swarm을 사용하는 경우 network_mode 옵션은 무시됩니다.</p>
</blockquote>
<h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h2><ul>
<li>Host OS의 디렉터리 경로를 Container 내부의 디렉터리에 Mount 합니다. (쉽게 말해서 디렉토리가 연동됩니다.)</li>
<li>docker run -v 또는 –volume과 같습니다.</li>
<li>Dockerfile의 VOLUME[] 과 같습니다.</li>
<li>docker-compose.yml의 volumes에는 상대경로를 지정할 수 있습니다.</li>
<li>호스트:컨테이너:권한 순으로 작성하여 읽기&#x2F;쓰기 권한 설정을 할 수 있습니다. (Default는 rw)<ul>
<li>ro : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수만 있음. Container에서 파일에 대한 수정이 불가능합니다.</li>
<li>rw : Container 디렉토리에서 Host OS 디렉토리의 내용을 읽을 수 있고, Container에서 파일 수정이 가능하고, Host OS 디렉토리에 반영이 됩니다.</li>
</ul>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> </span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/usr/local/redis/data:/data</span> <span class="comment"># &lt;Host OS 디렉터리 경로&gt; : &lt;Container 내부 data 경로&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/usr/local/redis/data:/data:ro</span> <span class="comment">#ReadOnly </span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/usr/local/redis/data:/data:rw</span> <span class="comment">#ReadWrite</span></span><br></pre></td></tr></table></figure>



<h2 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h2><p>Container 재 시작에 대한 policy를 설정합니다.</p>
<ul>
<li>no : 문제가 발생하여 Container가 중지된 경우 재시작 하지 않음 (default)</li>
<li>always : 어떠한 문제로 Container가 중지되는 경우 무조건 재시작 </li>
<li>on-failure : Container의 exit code 0 이 아닌 경우 재시작</li>
<li>unless-stopped : 명시적으로 중지되거나, Docker 자체가 중지되는 경우 재시작</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="literal">no</span>            </span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span>          </span><br><span class="line"><span class="attr">restart:</span> <span class="string">on-failure</span>      </span><br><span class="line"><span class="attr">restart:</span> <span class="string">unless-stopped</span>  </span><br></pre></td></tr></table></figure>



<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></li>
<li><a target="_blank" rel="noopener" href="http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/">http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer">https://www.joinc.co.kr/w/man/12/docker/Guide/DataWithContainer</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/12/01/2018-12-01-docker-3/">Docker기반 Redis 구축하기 - (3) Dockerfile</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="Dockerfile-이란"><a href="#Dockerfile-이란" class="headerlink" title="Dockerfile 이란?"></a>Dockerfile 이란?</h1><p>이전 예제에서는 Docker Hub에 등록된 이미지를 다운받아서 사용하였고, 이미지를 바탕으로 Container를 생성 할 수 있었습니다. Docker Hub에는 각 소프트웨어에 대한 공식이미지도 있지만, Docker Hub 사용자들이 공식이미지를 바탕으로 커스터마이징하여 배포한 이미지도 등록되어 있습니다.</p>
<p>어떻게 이미지를 빌드하고 배포 할 수 있었을까요? <strong>Dockerfile을 이용한 이미지 빌드를 이용하면 가능합니다.</strong></p>
<p>Dockerfile은 이미지를 바탕으로 몇가지 명령을 실행 할 수 있는 로직을 담은 파일입니다.<br>Dockerfile을 통해 더 유연하게 이미지에 대한 설정을 변경할 수 있고, 그 설정을 이미지에 담아 배포 할 수 있습니다.</p>
<p>물론 Docker run 구문에서 options을 사용하여 같은 기능을 하도록 구현 할 수 있지만, Dockerfile로 작성하게 되면 향후 유지보수가 쉬워지고 run 구문에 대한 options을 전부 기억하지 않아도 되는 장점이 있습니다.</p>
<p>이번 장에서는 Dockerfile을 작성하는 명령어를 위주로 알아보겠으며, 간단한 예제 Dockerfile을 보도록 하겠습니다.</p>
<h1 id="Dockerfile-사용방법"><a href="#Dockerfile-사용방법" class="headerlink" title="Dockerfile 사용방법"></a>Dockerfile 사용방법</h1><p>Dockerfile을 이용한 docker build</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dockerfile이 위치한 directory의 dockerfile을 가지고 build합니다.</span></span><br><span class="line">docker build -f /path/to/dockerfile </span><br></pre></td></tr></table></figure>



<h1 id="Dockerfile을-구성하는-핵심-명령어"><a href="#Dockerfile을-구성하는-핵심-명령어" class="headerlink" title="Dockerfile을 구성하는 핵심 명령어"></a>Dockerfile을 구성하는 핵심 명령어</h1><h2 id="From-Dockerfile의-시작"><a href="#From-Dockerfile의-시작" class="headerlink" title="From - Dockerfile의 시작"></a>From - Dockerfile의 시작</h2><p>From 명령어는 어떤 이미지를 바탕으로 container를 빌드 할 것인지 명시합니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis:5.0-alpine 이미지를 바탕으로 빌드</span></span><br><span class="line">From redis:5.0-alpine</span><br></pre></td></tr></table></figure>



<h2 id="CMD-Dockerfile의-끝"><a href="#CMD-Dockerfile의-끝" class="headerlink" title="CMD - Dockerfile의 끝"></a>CMD - Dockerfile의 끝</h2><ul>
<li>CMD명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>
<li>보통은 해당 프로그램을 실행시키는 명령을 사용합니다. ( ex&gt; startup.sh)</li>
<li>CMD 명령은 Dockerfile에서 <code>단 한번만 사용</code>할 수 있습니다.</li>
</ul>
<p>명령어 예제</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 일반적인 실행 방법</span></span><br><span class="line">CMD [<span class="string">&quot;execute.sh&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># Entrypoint 실행을 위한 Default Parameter - Entrypoint를 위한 파라미터를 제공</span></span><br><span class="line">CMD [<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># shell form</span></span><br><span class="line">CMD execute.sh param1 param2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>CMD 구문 사용 시, 주의사항!</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f ./dockerfile <span class="built_in">test</span></span><br><span class="line"><span class="comment"># Container 생성 시, docker run [이미지] [실행파일 또는 명령] 입니다.</span></span><br><span class="line">docker run <span class="built_in">test</span> <span class="built_in">echo</span> <span class="string">&quot;test!&quot;</span> </span><br></pre></td></tr></table></figure>

<p>위 예시 처럼 run 명령 시, 이미지 명 뒤에 <code>실행파일이나 명령어</code>가 오게되면 CMD에 설정된 명령은 <code>무시</code>되고 docker run 구문에서 사용된 명령이 <strong>CMD 대신 실행</strong>됩니다.</p>
</blockquote>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><ul>
<li>ENTRYPOINT명령은 Container가 docker run, docker start 명령을 실행 하였을 때 실행 됩니다.</li>
<li>보통 스크립트를 실행하거나, 실행명령을 수행하게 됩니다.</li>
<li>ENTRYPOINT명령은 Dockerfile에서 <code>단 한번만 사용가능</code> 합니다.</li>
<li>기본적으로 FROM에서 설정한 이미지의 &#x2F;bin&#x2F;sh 파일을 기반으로 실행되며, 이미지에 &#x2F;bin&#x2F;sh 파일이 없는 경우 실행이 불가능 합니다.</li>
</ul>
<p>ENTRYPOINT 사용 예시</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;docker-entrypoint.sh&quot;</span>, <span class="string">&quot;--param1=true&quot;</span>, <span class="string">&quot;--param2=1&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#run 명령의 options으로 구현한 방식</span></span><br><span class="line"><span class="comment">#이러한 방식으로도 사용할 수 있지만, 추천하지 않는 안티패턴입니다.</span></span><br><span class="line">docker run --entrypoint=<span class="string">&quot;docker-entrypoint.sh&quot;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>



<h1 id="Dockerfile에서-자주-사용하는-명령어"><a href="#Dockerfile에서-자주-사용하는-명령어" class="headerlink" title="Dockerfile에서 자주 사용하는 명령어"></a>Dockerfile에서 자주 사용하는 명령어</h1><h2 id="ADD-파일을-Container에-추가"><a href="#ADD-파일을-Container에-추가" class="headerlink" title="ADD - 파일을 Container에 추가"></a>ADD - 파일을 Container에 추가</h2><ul>
<li>Container 내부에 Host OS의 파일을 추가하려고 할 때 사용합니다.</li>
<li>ADD &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>
<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>
<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>
<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>
<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>
<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀어서 Container에 추가됩니다.<br>(Container에 압축 해제 된 파일들이 추가됨)</li>
<li>인터넷에 있는 파일 URL은 압축만 해제된 뒤, tar파일만 추가됩니다.</li>
<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>
<li>ADD로 추가되는 파일은 root root 기존 권한을 따릅니다 (단, URL로 추가된 파일의 경우 600)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADD ../file.sh /home/file.sh (x) <span class="comment">#상위 디렉터리 사용x</span></span><br><span class="line">ADD /home/user/file.sh /home/file.sh(x) <span class="comment">#절대경로 사용x</span></span><br><span class="line">ADD file.sh ../../file.sh (x) <span class="comment">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class="line"> </span><br><span class="line">ADD file.sh /home/file.sh (O) <span class="comment">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class="line">ADD *.sh /home (O) <span class="comment"># 와일드카드를 이용하여 복사 가능</span></span><br><span class="line">ADD compress.tar.gz / <span class="comment"># Container / 경로에 compress.tar파일의 풀어진 형태로 파일 추가</span></span><br><span class="line">ADD http://file.co.kr/file/1234.tar.gz / <span class="comment"># Container 내부의 / 경로에 1234.tar.gz 파일 추가</span></span><br></pre></td></tr></table></figure>



<h2 id="COPY-파일을-Container로-복사"><a href="#COPY-파일을-Container로-복사" class="headerlink" title="COPY - 파일을 Container로 복사"></a>COPY - 파일을 Container로 복사</h2><ul>
<li>ADD의 기능과 거의 유사합니다.</li>
<li>COPY &lt;Host OS의 파일 경로&gt; &lt;Container의 파일 경로&gt; 로 작성합니다.</li>
<li>&lt;Container의 파일경로&gt;란에 파일 경로만 적는 경우 파일 명은 Host OS의 파일명을 사용합니다.</li>
<li>&lt;Host OS의 파일경로&gt;는 현재 컨텍스트보다 상위 파일, 디렉터리나 절대경로는 사용 불가</li>
<li>&lt;Container의 파일경로&gt;는 <code>반드시 절대경로</code>로 사용합니다.</li>
<li>와일드카드(*)를 이용하여 특정파일만 복사도 가능합니다.</li>
<li>Host OS에 있는 압축파일(tar.gz, tar.bz2, tar.xz)은 압축을 풀지않고 그대로 복사됩니다. <strong>(ADD와 차이점)</strong></li>
<li>인터넷에 있는 파일 URL은 사용 불가. <strong>(ADD와 차이점)</strong></li>
<li>Directory 전체를 추가 시, .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다.</li>
<li>COPY로 추가되는 파일은 root root 기존 권한을 따릅니다</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COPY ../file.sh /home/file.sh (x) <span class="comment">#상위 디렉터리 사용x</span></span><br><span class="line">COPY /home/user/file.sh /home/file.sh(x) <span class="comment">#절대경로 사용x</span></span><br><span class="line">COPY file.sh ../../file.sh (x) <span class="comment">#&lt;Container 파일경로&gt;는 상대경로 사용x</span></span><br><span class="line"> </span><br><span class="line">COPY file.sh /home/file.sh (O) <span class="comment">#가급적이면 Dockerfile과 같은 경로상에 두는 것이 좋다.</span></span><br><span class="line">COPY *.sh /home (O) <span class="comment"># 와일드카드를 이용하여 복사 가능</span></span><br><span class="line">COPY compress.tar.gz / (O)<span class="comment"># Container / 경로에 compress.tar파일이 복사</span></span><br><span class="line">COPY http://file.co.kr/file/1234.tar.gz / (X) <span class="comment"># COPY는 인터넷 파일URL 사용 불가</span></span><br></pre></td></tr></table></figure>



<h2 id="RUN-Container-내부에서-명령-실행"><a href="#RUN-Container-내부에서-명령-실행" class="headerlink" title="RUN - Container 내부에서 명령 실행"></a>RUN - Container 내부에서 명령 실행</h2><ul>
<li>기본적으로 &#x2F;bin&#x2F;sh 파일로 실행됩니다.</li>
<li>Window의 경우 cmd 기반 명령을 수행합니다.</li>
</ul>
<p>Dockerfile 내 RUN 명령어 사용법</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># software 설치 명령 실행 (예시의 경우 yum이 Container내부에 설치되어야 합니다.)</span></span><br><span class="line">RUN yum -y install software  </span><br><span class="line"><span class="comment"># /usr/local/redis directory 생성</span></span><br><span class="line">RUN <span class="built_in">mkdir</span> -p /usr/local/redis </span><br><span class="line"><span class="comment"># execute.sh 파일 실행 </span></span><br><span class="line">RUN [<span class="string">&quot;execute.sh&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] </span><br></pre></td></tr></table></figure>



<p>명령어의 길이가 긴 경우 \ 문자를 사용하여 append 가능합니다</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN yum -y install software \</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">&quot;install software&quot;</span> \</span><br><span class="line">         <span class="built_in">mkdir</span> -p /usr/local/redis</span><br></pre></td></tr></table></figure>



<h2 id="ENV-Container-내부에서-사용할-환경-변수-추가"><a href="#ENV-Container-내부에서-사용할-환경-변수-추가" class="headerlink" title="ENV - Container 내부에서 사용할 환경 변수 추가"></a>ENV - Container 내부에서 사용할 환경 변수 추가</h2><p>Container는 Host OS와 독립된 공간이기 때문에 Container 내부에서 사용 할 환경변수를 추가할 수 있습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV LOCAL_PORT 80</span><br><span class="line">ENV REDIS_HOME /usr/local/bin/redis</span><br></pre></td></tr></table></figure>



<h2 id="EXPOSE-Container의-Port-설정"><a href="#EXPOSE-Container의-Port-설정" class="headerlink" title="EXPOSE - Container의 Port 설정"></a>EXPOSE - Container의 Port 설정</h2><ul>
<li>Host OS - Container와 통신할 포트를 설정</li>
<li>EXPOSE는 Host OS와 연결만 할 뿐 외부에 노출 되지는 않습니다.</li>
<li>포트를 노출 하기 위해서는 docker run -p 또는 -P 옵션 사용해야 합니다.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80   <span class="comment">#Container 내의 Web Server Port 노출</span></span><br><span class="line">EXPOSE 6379 <span class="comment">#Container 내의 Redis Server Port 노출</span></span><br><span class="line"> </span><br><span class="line">EXPOSE 80 6379 <span class="comment">#포트 여러개 노출</span></span><br></pre></td></tr></table></figure>



<h2 id="VOLUME-외부-볼륨-설정"><a href="#VOLUME-외부-볼륨-설정" class="headerlink" title="VOLUME - 외부 볼륨 설정"></a>VOLUME - 외부 볼륨 설정</h2><ul>
<li>Container 내부의 Directory와 Host OS의 Directory를 동기화 시키는 설정</li>
<li>log파일이나 설정파일은 보통 Container 내부에만 있는데 이를 Host OS에 동기화 하여 파일에 대한 접근이 가능하게 한다.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile volume 설정</span></span><br><span class="line">VOLUME [<span class="string">&quot;/data&quot;</span>, <span class="string">&quot;/var/log&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker run 사용 시, volumn 설정</span></span><br><span class="line"><span class="comment"># -v 옵션을 사용하여 설정 -v &lt;host 디렉터리&gt;:&lt;컨테이너 디렉터리&gt;</span></span><br><span class="line">docker run -v /host/os/data:/container/data app </span><br></pre></td></tr></table></figure>



<h2 id="WORKDIR-Container의-Work-Directory-설정"><a href="#WORKDIR-Container의-Work-Directory-설정" class="headerlink" title="WORKDIR - Container의 Work Directory 설정"></a>WORKDIR - Container의 Work Directory 설정</h2><ul>
<li>RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉터리</li>
<li>중간에 Directory가 변경되는 경우 바꿀수 있다.</li>
<li>리눅스의 cd 명령어와 비슷하다.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /usr/local/bin</span><br><span class="line">ADD redis.conf /usr/local/bin/redis.conf</span><br><span class="line"> </span><br><span class="line">WORKDIR /usr/local</span><br><span class="line">ADD redis.log /usr/local/redis.log</span><br><span class="line"></span><br><span class="line">WORKDIR var</span><br><span class="line">WORKDIR lib</span><br><span class="line">RUN <span class="built_in">touch</span> file.sh <span class="comment"># /var/lib/file.sh 생성</span></span><br></pre></td></tr></table></figure>

<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="http://pyrasis.com/book/DockerForTheReallyImpatient">http://pyrasis.com/book/DockerForTheReallyImpatient</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/11/28/2018-11-28-docker-2/">Docker기반 Redis 구축하기 - (2) Docker 설치 및 사용방법</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Docker/">Docker</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>지난 장에서는 Docker에 대한 개념, Image와 컨테이너, VM과의 차이점등을 그림으로 설명하였습니다.<br>이번 장부터는 Docker를 linux서버에 설치하는 과정을 설명하고자 합니다.<br>(Linux서버 설치는 hyper-v를 이용하여 vm으로 설치 하였습니다. &lt;차후에 hyper-v 설정기를 올릴 예정입니다.&gt;)<br>Windows, Mac에도 설치 할 수 있지만, Linux에 설치하는게 거의 표준이다 싶히 사용되고 있으며, Windows, Mac에 설치를 하더라도 어차피 가상화 환경에서 Docker가 설치 되기 때문에… linux를 설치하여 Docker를 설치하였습니다.<br>(지울 때 편하게 지우고 싶어서 그런건 안비밀)</p>
<h1 id="CentOS-7-환경에서-Docker-설치하기"><a href="#CentOS-7-환경에서-Docker-설치하기" class="headerlink" title="CentOS 7 환경에서 Docker 설치하기"></a>CentOS 7 환경에서 Docker 설치하기</h1><p>Docker를 설치하는 방법은 다양한 방법이 있겠지만.. 가장 간단한 방법으로 설치해 보도록 하겠습니다.</p>
<p>설치 환경은 아래와 같습니다.</p>
<ul>
<li>OS: CentOS 7 (VM 환경(Hyper-v)에서 테스트)</li>
<li>user: docker-user (일부러 root가 아닌 사용자를 생성하였습니다… 이유는 아래에)</li>
<li>SW: Redis 5</li>
</ul>
<blockquote>
<p>Docker 다운로드 yum을 이용해서 Docker를 받는 방법도 있지만, <code>최신버전이 아닙니다. </code><br>차후 Docker-compose를 사용하기 위해서는 Docker버전이 1.13 이상이 되야 합니다.<br>따라서 한번에 패키지로 설치해 주는 url로 설치하도록 합니다. </p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -fsSL https://get.docker.com/ | sudo sh</span><br><span class="line">sudo sh sudo service docker start <span class="comment">#Docker Daemon Start</span></span><br></pre></td></tr></table></figure>



<h1 id="Docker의-Permission"><a href="#Docker의-Permission" class="headerlink" title="Docker의 Permission"></a>Docker의 Permission</h1><p>Docker를 설치하고 확인하기 위해 Docker 명령을 입력하였습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><img src="./docker-permission.png" alt="docker permission"></p>
<p>docker명령을 입력했을 시, permission denied 에러가 발생한 것을 볼 수 있습니다.<br>docker는 명령을 실행 할 때 기본적으로 root계정을 필요로 합니다. (docker의 특성상 시스템의 내부적인 부분에 접근하는 게 많다보니… 그렇다고 합니다.)<br>그렇기 때문에 sudo명령을 사용하여 docker 명령을 실행 할 수 있습니다.</p>
<p><code>하지만 sudo가 너무 귀찮다! 하시는 분들은...</code> 아래 명령을 실행하여 계정을 <code>docker 그룹</code>에 포함 시켜주시면 됩니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line">sudo service docker restart</span><br><span class="line"> </span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#로그아웃</span></span><br><span class="line">docker-user &lt;password&gt; <span class="comment">#다시 로그인</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p><img src="./sudo-docker.png" alt="sudo docker"></p>
<p>이제 sudo 명령 없이도 docker 명령어 실행이 잘 됩니다!</p>
<h1 id="간단한-Docker-Container-깡통-를-만들어-봅시다"><a href="#간단한-Docker-Container-깡통-를-만들어-봅시다" class="headerlink" title="간단한 Docker Container(깡통)를 만들어 봅시다!"></a>간단한 Docker Container(깡통)를 만들어 봅시다!</h1><p>Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>) 사이트에 들어가면 우리가 필요로하는 많은 프로그램들이 이미지로 올라가 있습니다.<br>이번 예제에서는 Redis를 가지고 Docker Container를 만들어보도록 하겠습니다.</p>
<p><img src="./docker-hub.png" alt="docker-hub"></p>
<p>docker hub 사이트에서 redis를 검색해 보았습니다.<br>여러가지 redis 이미지가 보이는데 official이라고 되어있는 것이 공식이미지 입니다.<br>bitnami&#x2F;redis라고 되어있는 것은 docker hub의 사용자들이 올린 이미지입니다.</p>
<p><img src="./redis-versions.png" alt="redis-versions"></p>
<p>official 이미지의 상세 버전을 보니 4.x~5.0.1까지 있습니다.<br>이번 예제에서는 그나마 stable한 버전인 인 5.0-alpine 버전을 사용해 보도록 하겠습니다.</p>
<h1 id="Docker-이미지-다운로드-Docker-hub-gt-Docker-Client"><a href="#Docker-이미지-다운로드-Docker-hub-gt-Docker-Client" class="headerlink" title="Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)"></a>Docker 이미지 다운로드 (Docker hub -&gt; Docker Client)</h1><p>pull 명령을 통해 docker hub에 있는 이미지를 다운로드 합니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:&lt;tag&gt; <span class="comment"># ex) redis:5.0-alpine, redis:4-alpine, redis:latest(가장 마지막 배포 버전입니다.)</span></span><br><span class="line">docker pull redis <span class="comment">#tag version을 적지 않은 경우 자동으로 lastest 버전을 다운로드 합니다.</span></span><br></pre></td></tr></table></figure>



<h1 id="Docker-이미지-확인-x2F-삭제"><a href="#Docker-이미지-확인-x2F-삭제" class="headerlink" title="Docker 이미지 확인 &#x2F; 삭제"></a>Docker 이미지 확인 &#x2F; 삭제</h1><h2 id="Docker-이미지-확인"><a href="#Docker-이미지-확인" class="headerlink" title="Docker 이미지 확인"></a>Docker 이미지 확인</h2><p>images 명령을 이용하여 docker image리스트를 확인합니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<ul>
<li>자주 사용하는 options<ul>
<li>-a –all : 숨겨진 임시 이미지를 보여줍니다.</li>
<li>-f –filter : filter를 이용하여 이미지 조회 조건을 변경하여 조회 할 수 있습니다.</li>
<li>-q –quite : image의 image ID만 출력합니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>docker의 이미지는 1개의 파일이 아닌, 여러 이미지의 레이어(Layer)로 구성되어 있습니다.<br>따라서 Redis이미지를 다운받더라고 Redis 이미지 하나가 아닌 여러 이미지의 레이어로 구성되어 있습니다.<br><img src="./image-layer.png" alt="image layer"><br>따라서 하나의 이미지라도 여러 이미지가 투영되어 보이는 결과물이라 볼 수 있습니다.</p>
</blockquote>
<h2 id="Docker-이미지-삭제"><a href="#Docker-이미지-삭제" class="headerlink" title="Docker 이미지 삭제"></a>Docker 이미지 삭제</h2><p>rmi 명령을 이용하여 docker의 image를 삭제 할 수 있습니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker rmi redis:5.0-alpine, docker rmi &lt;imageID&gt;</span></span><br><span class="line">docker rmi &#123;이미지명/이미지ID&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>자주 사용하는 Options<ul>
<li>-f –force : 이미지를 강제로 삭제합니다. (해당 이미지로 만들어진 Docker Container가 존재하는 경우 이미지를 삭제 할 수 없는데, 그 때 강제로 삭제 하기위해 사용)</li>
</ul>
</li>
</ul>
<h1 id="Docker-Container-생성-x2F-삭제"><a href="#Docker-Container-생성-x2F-삭제" class="headerlink" title="Docker Container 생성 &#x2F; 삭제"></a>Docker Container 생성 &#x2F; 삭제</h1><h2 id="Docker-Container-생성"><a href="#Docker-Container-생성" class="headerlink" title="Docker Container 생성"></a>Docker Container 생성</h2><p>run 명령으로 Container를 생성합니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker run -it -d redis:5.0-alpine,</span></span><br><span class="line"><span class="comment">#     docker run -it -d 4760dc956b2d</span></span><br><span class="line">docker run &#123;options&#125; &lt;image명/image ID&gt; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>자주 사용하는 Options</p>
<ul>
<li>-d –detach : Container 생성 후 Background로 실행 (이 옵션 없을 시, Redis 같은 경우에는 Console에 Redis log가 지속적으로 표시됩니다.)</li>
<li>-h –hostname : Container 명 지정</li>
<li>-i –interactive : 소통형 모드로 실행 (주로 ubuntu와 같은 Container 실행 시 사용)</li>
<li>-p –publish : 해당 Container의 외부 Port 지정 (10000:6379) (외부:내부) 형식으로 지정</li>
<li>-P –publish-all : 여러개의 Port 노출 (1000-1100)</li>
<li>–rm : Container 종료 시, Container 삭제 <code>(자주 사용되는 옵션입니다)</code></li>
<li>-v –volume : 외부 볼륨 연동 &#x2F;home&#x2F;user&#x2F;data:&#x2F;data (외부 OS 디렉토리:컨테이너 내부 디렉토리) - 상호 데이터가 공유됨</li>
</ul>
</li>
</ul>
<h2 id="Docker-Container-목록-조회"><a href="#Docker-Container-목록-조회" class="headerlink" title="Docker Container 목록 조회"></a>Docker Container 목록 조회</h2><p>ps 명령으로 Container 목록을 조회합니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps &#123;options&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>자주 사용하는 Options</li>
<li>-a : 비활성 상태의 Container까지 조회</li>
<li>-q : Container ID만 조회</li>
<li>-f –filter : Container 조회 시, Filter를 이용하여 조회</li>
</ul>
<h2 id="Docker-Container-내부-접속"><a href="#Docker-Container-내부-접속" class="headerlink" title="Docker Container 내부 접속"></a>Docker Container 내부 접속</h2><p>attach 명령을 이용하여 접속</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [container명/container ID]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>attach 명령은 &#x2F;bin&#x2F;bash로 실행 되기 때문에, Container에 &#x2F;bin&#x2F;bash가 없는 경우에는 접속이 불가능 합니다. </p>
</blockquote>
<p>exec 명령을 이용하여 Container 내부 명령 수행</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker exec -it redis:5.0-alpine /bin/sh</span></span><br><span class="line"><span class="comment"># Redis의 경우 Container에 bin/bash가 없어 bin/sh로 실행하면 내부접속이 가능합니다</span></span><br><span class="line">docker <span class="built_in">exec</span> &#123;options&#125; [container명/container ID] [명령어]  </span><br></pre></td></tr></table></figure>

<ul>
<li>자주 사용하는 options<ul>
<li>-d –detach : 명령수행을 Background 모드로 수행</li>
<li>-e –env : 환경변수 (Environment) 설정</li>
<li>-i –interaction : 대화형 모드로 설정</li>
</ul>
</li>
</ul>
<h1 id="Docker-Container-삭제"><a href="#Docker-Container-삭제" class="headerlink" title="Docker Container 삭제"></a>Docker Container 삭제</h1><p>rm 명령으로 Container를 삭제 합니다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex) docker rm -f redis:5.0-alpine</span></span><br><span class="line">docker <span class="built_in">rm</span> &#123;options&#125; [container명/container ID] </span><br></pre></td></tr></table></figure>

<ul>
<li>자주 사용하는 options<ul>
<li>-f –force : 활성(active) 상태의 Container 강제삭제</li>
<li>-l –link : Container간 link가 관계인 Container 삭제</li>
<li>-v –volumes : Container 관련 볼륨(외부 디렉토리) 삭제</li>
</ul>
</li>
</ul>
<h1 id="자주-사용한-명령어-모음"><a href="#자주-사용한-명령어-모음" class="headerlink" title="자주 사용한 명령어 모음"></a>자주 사용한 명령어 모음</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Container 전체 삭제 (-a -q 옵션으로 전체 Container의 ID만 뽑아온다.)</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Image 전체 삭제 (-q 옵션으로 images에 대한 Image ID만 뽑아온다.)</span></span><br><span class="line">docker rmi $(docker images -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#특정 Container 삭제 (grep 명령으로 Container ID만 뽑아온다.)</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a | grep <span class="string">&quot;redis:5.0-alpine&quot;</span>| awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#특정 이미지 삭제 (grep + awk 명령어로 image ID만 뽑아온다.)</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">&quot;^redis&quot;</span>| awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#Docker 삭제</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">yum remove -y docker*</span><br></pre></td></tr></table></figure>



<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.sauru.so/blog/docker-installation-and-test-drive/">http://www.sauru.so/blog/docker-installation-and-test-drive/</a></li>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/_/redis/">https://hub.docker.com/_/redis/</a></li>
<li><a target="_blank" rel="noopener" href="http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03">http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter03</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="../8/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../8/">8</a><span class="page-number current">9</span><a class="page-number" href="../10/">10</a><span class="space">&hellip;</span><a class="page-number" href="../12/">12</a><a class="extend next" rel="next" href="../10/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="../../js/utils.js?version=1.9.0"></script><script src="../../js/fancybox.js?version=1.9.0"></script><script src="../../js/sidebar.js?version=1.9.0"></script><script src="../../js/copy.js?version=1.9.0"></script><script src="../../js/fireworks.js?version=1.9.0"></script><script src="../../js/transition.js?version=1.9.0"></script><script src="../../js/scroll.js?version=1.9.0"></script><script src="../../js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>