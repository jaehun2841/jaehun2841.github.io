<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다. | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../melody-favicon.ico"><link rel="stylesheet" href="../../css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href=".."><span class="pull-left">Articles</span><span class="pull-right">112</span></a><a class="author-info-articles__tags article-meta" href="../../tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Carrey`s 기술블로그</div><div id="site-sub-title">공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="../../2018/09/01/2018-09-01-servlet/">Servlet이란?</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Spring/">Spring</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/J2EE/">J2EE</a></span><div class="content"><p><img src="./servlet.png" alt="servlet"></p>
<h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>약 4년 동안 개발하면서, Spring core에 대한 공부를 하지 않고, “이렇게 코딩하면 이렇게 동작하네<del>“ 라는 생각만 가지고 개발을 해왔었다. 근 1</del>2달 간 Spring core 부분에 관심을 가지며 동작 원리에 대한 지식을 습득하였다. 그러면서 “이게 이래서 이렇게 동작하는구나~” 라고 개인적으로 Spring에 대한 insight를 높일 수 있었고, 이런 점들은 실제 개발 시 뚜렷하게 나타났다.</p>
<p>최근 Dispatcher Servlet에 대한 Spring MVC에 대한 공부를 진행하면서, Spring 이전 기술인 Servlet에 대해 한번은 공부하고 넘어가야 겠다고 생각했다. 이번 기회에 4년동안 이름만 들어봤던 Servlet에 대한 포스팅을 써보게 되었다.</p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet이 뭐지?  대학 시절 JSP를 배웠지만, 교수님이 Servlet에 대한 내용을 강의를 하지 않았다. (교수님이 약간 프로그래밍 지식이 부족하신 분이다.) 그 때 그랬으면 스스로 Servlet에 대한 스터디라도 해봤어야 했는데… 이제와서 알아보게 되었다.</p>
<p>Servlet의 정의에 대해 찾아보게 되었다. (출처 : <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF">wikipedia</a>)</p>
<blockquote>
<p>자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 “서블릿”이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</p>
</blockquote>
<p>결국은 <code>웹 서버에서 돌아가는 Java 코드</code>라는 뜻이다.<br>Java 코드 이긴 코드인데 무작정 연습예제 만들 듯이 짜는 코드가 아니다.<br><code>HttpServlet</code> 이라는 Class를 상속하여 만든 Class를 Servlet Class로 사용 할 수 있다.</p>
<h2 id="Servlet의-특징"><a href="#Servlet의-특징" class="headerlink" title="Servlet의 특징"></a><strong>Servlet의 특징</strong></h2><ul>
<li>Servlet이란 Java 기반의 웹 어플리케이션 프로그래밍 기술</li>
<li>흔히 Java로 만든 CGI(Common Gateway Interface)라고들 한다.</li>
<li>클라이언트 요청 (request)에 대해 java코드로 된 로직을 수행 하고 응답(Response)을 돌려준다.</li>
<li>Http Method (GET, POST, PUT, DELETE)에 대해 지원한다.<br>(doGet, doPost, doPut, doDel 메소드를 상위 클래스인 HttpServlet 클래스에서 제공한다)</li>
<li>클라이언트 요청 시, 별도의 Thread가 생성되어 로직을 수행한다.<br>(WAS 내의 Thread pool의 Thread 객체를 이용한다.)</li>
<li>Servlet 객체는 실제로 WAS load시 하나의 Servlet 객체가 생성되어 Memory에 올라간다<br>(내부적으로 Sington을 구현하고 있지는 않다고한다.)<br>여기서 주의 해야 할 내용은 클라이언트 요청 별로 Thread가 생성 되기 때문에 하나의 Servlet에 동시 다발적으로 여러 Thread에 대한 접근이 이루어지게 된다. 따라서 Servlet에 대한 코드는 멀티스레드 환경에 대한 동기화처리가 필요하다.</li>
<li>요즘은 거의 Servlet을 사용하지는 않는다. 특히 Spring에서는 Spring MVC라는 강력한 구조가 있기 때문에 Spring에서는 웬만하면 Servlet생성을 하지 않는다.<br>(오히려 Servlet을 생성하는게 더 귀찮다. 별도로 설정해야 되고, Dispatcher Servlet에서 지원하는 강려크(?) 한 기능을 사용하지 못한다.)</li>
<li>MVC에서 컨트롤러로 이용됨..</li>
</ul>
<h1 id="Servlet-Container"><a href="#Servlet-Container" class="headerlink" title="Servlet Container"></a>Servlet Container</h1><p>Servlet이라는 Java Class를 만들었으면, 당연히 이 Class를 실행 시켜주는 프로세스가 있어야 하지 않을까?<br>당연히 있다. WAS라고 불리우는 프로그램이 있다.<br>Java 진영에서 자주 사용하는 WAS는 단연 으뜸으로 <code>Apache Tomcat</code>이 있다.<br>(다른거로는 <code>Jeus</code>나, <code>jBoss</code> 같은 것들이 있다. 하지만 Apache Tomcat이 Spring, JSP진영에서는 거의 표준이다 싶이 사용되니 Apache Tomcat을 기준으로 적었다.)</p>
<p>WAS에는 Servlet들을 관리 하는 Servlet Container가 있고 이러한 일들을 해준다.</p>
<ul>
<li><p>Web Server (apache, nginx)와의 통신 지원</p>
<ul>
<li>클라이언트 요청(Request)에 대한 Socket 통신 지원</li>
</ul>
</li>
<li><p>Servlet Lifecycle 관리</p>
</li>
<li><p>Client 접근 URL에 대한 Servlet Mapping </p>
</li>
<li><p>클라이언트 요청(Request)에 대한 멀티 스레드 관리</p>
</li>
<li><p>선언적인 보안관리</p>
<ul>
<li>보안에 대한 코드를 Servlet 내부에 작성하지 않아도 된다.</li>
<li>Servlet Filter와 같은 Filter에서 보안에 대한 처리가 가능하기 때문</li>
<li>DD (배포 서술자 : Deploy Descriptor (web.xml))에 보안 관련 설정을 할 수 있다.<br>대표적인 예로 Spring Security가 있다.</li>
</ul>
</li>
</ul>
<h1 id="Servlet-LifeCycle"><a href="#Servlet-LifeCycle" class="headerlink" title="Servlet LifeCycle"></a>Servlet LifeCycle</h1><p><img src="./Servlet-life-cycle.png" alt="Servlet-life-cycle"></p>
<p>Servlet의 LifeCycle은 3단계로 이루어 진다.</p>
<ul>
<li>init() <ul>
<li>WAS Load후 최초로 Servlet에 대한 요청이 들어올 때 실행 된다.</li>
<li>주로 Servlet 객체에 대한 초기화 로직을 작성한다.</li>
<li>실행 중 Servlet의 코드가 변경 될 경우, 기존 Servlet을 Destroy 시키고<br>다시 서블릿 생성과 동시에 init()이 실행</li>
</ul>
</li>
<li>service()<ul>
<li>Servlet 객체 생성 이후 GET, POST, PUT, DELETE 메소드에 대한 메소드가 실행된다.<br>(doGet(), doPost(), doPut(), doDel())</li>
</ul>
</li>
<li>destroy()<ul>
<li>WAS shutdown 시 호출 된다.</li>
<li>주로 Servlet 객체에서 사용하던 자원의 해제 용도로 사용된다</li>
<li>자원 해제 된 객체는 JVM의 Garbage Collector에서 처리한다.</li>
</ul>
</li>
</ul>
<h1 id="Servlet-설정하기"><a href="#Servlet-설정하기" class="headerlink" title="Servlet 설정하기"></a>Servlet 설정하기</h1><h2 id="Servlet-class-생성하기"><a href="#Servlet-class-생성하기" class="headerlink" title="Servlet class 생성하기"></a>Servlet class 생성하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.demo3.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebServlet(name=&quot;demoServlet&quot;, url-pattern=&quot;/servlet/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;doGet() 실행실행실행!!!&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        log.info(<span class="string">&quot;Thread ID : &quot;</span> + thread.getId());</span><br><span class="line">        <span class="built_in">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Servlet destroy()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Servlet init()&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>@WebServlet 어노테이션을 이용하면 web.xml이나 별도의 Java config 설정없이 Servlet을 등록 할 수 있다.<br>(단, Spring boot - Embedded WAS에서는 해당 설정이 잘 안먹는다.)</p>
<p>기본적으로 Servlet 클래스 생성은 <code>HttpServlet</code> 클래스를 상속 받아 생성한다.<br>HttpServlet내의 init, destroy, doGet, doPost에 대한 Override 후 기능을 확장하도록 한다.</p>
<h2 id="web-xml-기반-설정"><a href="#web-xml-기반-설정" class="headerlink" title="web.xml 기반 설정"></a>web.xml 기반 설정</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.springstudy.demo3.servlet.DemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/demo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>web.xml에 servlet 클래스를 선언하고 <servlet-mapping> 태그를 통해 url-pattern이나 init-data와 같은 메타 데이터를 추가 할 수 있다.</p>
<h2 id="Java-Config-기반-설정"><a href="#Java-Config-기반-설정" class="headerlink" title="Java Config 기반 설정"></a>Java Config 기반 설정</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.demo3.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo3.servlet.DemoServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServletConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">demoServletRegistrationBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">demoServletRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>();</span><br><span class="line">        demoServletRegistrationBean.setServlet(<span class="keyword">new</span> <span class="title class_">DemoServlet</span>());</span><br><span class="line">        demoServletRegistrationBean.addUrlMappings(<span class="string">&quot;/servlet/demo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> demoServletRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>@Configuration 어노테이션을 이용하여 Java config 설정을 할 수 있다.<br>ServletRegistrationBean을 생성하여 등록하고자 하는 Servlet 클래스와 url-pattern과 같은 메타 정보를 설정 할 수 있다.</p>
<h1 id="JSP-vs-Servlet"><a href="#JSP-vs-Servlet" class="headerlink" title="JSP vs Servlet"></a>JSP vs Servlet</h1><p><strong>JSP와 Servlet의 차이점</strong></p>
<ul>
<li>JSP는 html 파일에 스크립트릿으로 Java 코드가 들어간 형태</li>
<li>Servlet은 html 태그가 out.println(“<html>“) 형태로 들어간 형태</li>
</ul>
<h2 id="JSP-gt-Servlet-변환-과정"><a href="#JSP-gt-Servlet-변환-과정" class="headerlink" title="JSP -&gt; Servlet 변환 과정"></a>JSP -&gt; Servlet 변환 과정</h2><p><img src="./jspToServlet.jpeg" alt="jspToServlet"></p>
<p>Servlet의 최종 형태는 out.println(“<html>“) 과 같은 형태로 html 파일을 인코딩 해야 하는데, 가독성도 떨어지고 유지보수 성도 좋지 않다. 그러한 번거로움을 jsp가 대신 해준다고 볼 수 있다.</p>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a target="_blank" rel="noopener" href="http://mangkyu.tistory.com/14">http://mangkyu.tistory.com/14</a><br><a target="_blank" rel="noopener" href="http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80</a><br><a target="_blank" rel="noopener" href="http://til0804.tistory.com/25">http://til0804.tistory.com/25</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/08/30/2018-08-25-spring-mvc-handle-exception/">Spring Handle Exception</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-30</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Spring/">Spring</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Spring-Core/">Spring Core</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Spring에서 제공하는 예외처리 방법에는 유용한 방법들이 몇가지 있다.<br>Dispatcher Servlet내에서는 몇 가지 HandleExceptionResolver를 제공하여 예외 처리를 할 수 있도록 돕고 있다. 또한 @ControllerAdvice를 이용하여 Web Application 전역에 대한 Exception 처리를 위한 API를 제공한다.<br>Spring 예외처리에 대한 내용과 간단한 사용법에 대한 포스팅을 작성하고자 한다.</p>
<h1 id="예외-Exception-처리는-어떻게"><a href="#예외-Exception-처리는-어떻게" class="headerlink" title="예외(Exception) 처리는 어떻게?"></a>예외(Exception) 처리는 어떻게?</h1><p>Spring에서는 예외처리에 대해 강려크(?) 하게 지원해주고 있다.</p>
<ol>
<li>Controller 레벨에서 처리</li>
<li>Global 레벨에서 처리</li>
<li>HandlerExceptionResolver를 이용한 처리</li>
</ol>
<h1 id="Controller-레벨에서의-처리"><a href="#Controller-레벨에서의-처리" class="headerlink" title="Controller 레벨에서의 처리"></a>Controller 레벨에서의 처리</h1><p>Spring에서는 Controller에서 발생한 예외에 대해 Common하게 처리 할 수 있는 기능을 제공한다.<br><code>@ExceptionHandler</code> 어노테이션을 통해 Controller의 메소드에서 throw된 Exception에 대한 공통적인 처리를 할 수 있도록 지원하고 있다.</p>
<p>예제 코드</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.demo2.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(path=&quot;/exception/demo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">occurDemoException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DemoException</span>(); <span class="comment">//occur DemoException (RuntimeException)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(path=&quot;/exception/demo2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">occurDemoException2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//강제로 DemoException을 발생 시켜 보았다.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DemoException</span>(); <span class="comment">//occur DemoException (RuntimeException)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value=DemoException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleDemoException</span><span class="params">(DemoException e)</span> &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/error/404&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DemoController내에서 발생한 DemoException에 대해서는 <code>handleDemoException</code> 메소드에서 모두 처리를 해준다.</p>
<ul>
<li>Controller 메소드 내의 하위 서비스에서 Checked Exception이 발생하더라도, Controller 메소드 상위까지 예외를 throw 시키면<code> @ExceptionHandler</code> 어노테이션을 사용하여 Controller 전역적으로 예외처리가 가능하다.</li>
<li>Controller 메소드 내의 하위 서비스에서 Runtime Exception이 발생하면, 서비스를 호출한 최상위 Controller에서 해당 예외를 처리해준다.</li>
</ul>
<p>Spring MVC 모델에서 예외처리를 미루고 미루면 이런식으로 Controller 레벨에서 예외처리를 Common하게 해줄 수 있다.</p>
<h1 id="Global-레벨에서의-처리"><a href="#Global-레벨에서의-처리" class="headerlink" title="Global 레벨에서의 처리"></a>Global 레벨에서의 처리</h1><p>만약 여러 Controller에서 같은 Exception이 발생하는 경우엔 어떻게 해야 할까?<br>위의 방식 처럼 Controller 별로 <code>@ExceptionHandler</code> 어노테이션이 붙은 메소드를 만들게 된다면, 중복코드가 양산 될 것이고 결국 유지보수의 비용이 증가하게 될 것이다.<br>Spring 에서는 이런 상황을 위해 Web Application 전역적으로 @ExceptionHandler를 사용할 수 있도록 지원한다.</p>
<ul>
<li><code>@ControllerAdvice</code> - Exception 처리 후 Error Page등을 통해 처리가 가능하다.</li>
<li><code>@RestControllerAdvice</code><ul>
<li>REST API에 대한 Exception 처리 등에 용이. (Default 데이터를 리턴 해 줄 수 있다.)</li>
<li>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</li>
</ul>
</li>
</ul>
<p>위 2개의 어노테이션을 이용하여  Web Application 전역적으로 @ExceptionHandler를 사용할 수 있다.</p>
<p><strong>주의!) @ControllerAdvice로 케어 가능한 범위는 Dispatcher Servlet내에서 이루어진다는 것을 명심!!</strong></p>
<p>예제 코드</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.DemoException;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.FilterException;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.demo2.exception.InterceptorException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoControllerAdvisor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//모든 Controller에서 일어나는 DemoException에 대해 전역적으로 예외처리</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = DemoException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleDemoExceptionForGlobal</span><span class="params">(DemoException e)</span> &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/error/404&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="여기서-궁금한-점…"><a href="#여기서-궁금한-점…" class="headerlink" title="여기서 궁금한 점…"></a>여기서 궁금한 점…</h2><p>Controller 클래스 내에 <code>@ExceptionHandler</code>, <code>@ControllerAdvice</code> 클래스 내의 <code>@ExceptionHandler</code> 둘 중 뭐가 먼저 실행 될까? 그리고 둘 다 실행 될까?</p>
<p>실험을 해보았다.<br>준비물은 아래와 같다.</p>
<ol>
<li>DemoException을 throw하는 DemoController1, DemoController2</li>
<li>DemoController1에서는 DemoException에 대해 <code>@ExceptionHandler</code>를 구현하였다.</li>
<li>DemoController2에서는 DemoException에 대한 예외처리를 별도로 하지 않았다.</li>
<li>전역적으로 DemoException에 대한 처리를 할 수 있는 DemoControllerAdvice 클래스를 생성하고<br><code>@ExceptionHandler</code>를 통해 DemoException에 대한 예외 처리를 할 수 있도록 하였다.</li>
</ol>
<h3 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test-Case"></a>Test-Case</h3><ol>
<li>DemoController1 -&gt; throw DemoException</li>
<li>DemoController2 -&gt; throw DemoException</li>
</ol>
<h3 id="어떤-결과가-나왔을까"><a href="#어떤-결과가-나왔을까" class="headerlink" title="어떤 결과가 나왔을까?"></a>어떤 결과가 나왔을까?</h3><ol>
<li><p>DemoController1 -&gt; throw DemoException</p>
<ul>
<li>예상대로 DemoController1 내의 @ExceptionHandler 메소드를 통해 우선적으로 예외처리가 되었다.</li>
<li>예외처리가 끝난 후 404페이지가 리턴 되었다.</li>
<li><code>@ControllerAdvice내의 @ExceptionHandler</code>는 실행 되지 않았다.</li>
</ul>
<p><strong>&#x3D;&gt; <strong>@Controller내의 @ExceptionHandler로 예외처리를 하게 되면 거기서 예외처리가 끝난다.</strong><br>     더 상위로 Exception을 throw하더라도 <code>@ControllerAdvice의 @ExceptionHandler</code>에서 예외처리를 하지 않는다.</strong></p>
</li>
<li><p>DemoController2 -&gt; throw DemoException</p>
<ul>
<li>예상대로 DemoControllerAdvice 내의 <code>@ExceptionHandler</code> 메소드에서 예외처리가 되었다.</li>
<li>DemoController2에는 <code>@ExceptionHandler</code>가 없으므로 Controller레벨에서 예외처리가 되지는 않는다.</li>
</ul>
</li>
</ol>
<h1 id="HandlerExceptionResolver를-이용한-처리"><a href="#HandlerExceptionResolver를-이용한-처리" class="headerlink" title="HandlerExceptionResolver를 이용한 처리"></a>HandlerExceptionResolver를 이용한 처리</h1><p>HandlerExceptionResolver는 Controller의 작업 중에 발생한 예외를 어떻게 처리 할 지에 대한 전략이다.<br><code>DispatcherServlet이외의 영역에서 발생한 에러는 Servlet Container 내부에서 처리 될 것</code>이다. 만약 error-page라도 잘 정의 했다면은 다행이겠지만, 그렇지 않다면 브라우져 화면에서 404, 500과 같은 에러 메세지를 표현 할 것이다.<br>(Spring boot의 경우 default로 white label page가 에러페이지로 설정 되어있다.)</p>
<p>HandlerExceptionResolver는 아래와 같은 인터페이스를 제공한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, <span class="meta">@Nullable</span> Object var3, Exception var4)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatcherServlet내에서 예외 발생 시, resolverException 메소드를 구현한 HandlerExceptionResolver들이 실행 계획에 따라 처리 되며 예외를 처리 하게 된다.<br>사실 위에서 본 2가지 방식의 예외처리도 HandlerExceptionResolver를 이용한 예외 처리 방법이다.<br>Spring에서 기본적으로 설정되어 있는 HandlerExceptionResolver에 대해 알아보도록 하겠다.</p>
<p>Dispatcher Servlet에 기본적으로 3개의 HandlerExceptionResolver가 등록 되어있다.</p>
<ol>
<li>ExceptionHandlerExceptionResolver</li>
<li>ResponseStatusExceptionResolver</li>
<li>DefaultHandlerExceptionResolver</li>
</ol>
<p>순으로 Resolver가 실행된다.</p>
<p><img src="./image-20180831234615081.png" alt="image-20180831234615081"></p>
<h2 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h2><p>Spring 3.2때 AnnotationMethodHandlerExceptionResolver라는 이름으로 등장하였다. 현재는 Deprecated처리 되어 ExceptionHandlerExceptionResolver 클래스를 사용하고 있다.<br>위에서 사용한 <code>@ExceptionHandler</code> 어노테이션에 대한 Resolver 클래스이다.</p>
<h2 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h2><p>ResponseStatusExceptionResolver는 예외에 대한 Http 응답을 설정해 줄 수 있다.<br>특정 예외가 발생하였을 때 , 단순히 500 (internal-server-error) 대신 더 구체적인 응답 상태값을 전달 해 줄 수 있다.</p>
<p>사용 예제 (@ExceptionHandler와 함께 사용)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ExceptionHandler 어노테이션과 함께 사용할 수 있다.</span></span><br><span class="line"><span class="comment">//구체적인 응답 코드를 줄 뿐 아니라, 간단한 사유도 전달 할 수 있다.</span></span><br><span class="line"><span class="meta">@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = &quot;Permission Denied&quot;)</span></span><br><span class="line"><span class="meta">@ExceptionHandler(value=DemoException.class)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handleDemoException</span><span class="params">(DemoException e)</span> &#123;</span><br><span class="line">    log.error(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/error/403&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./image-20180831235454808.png" alt="image-20180831235454808"></p>
<p>위의 예제대로 실행 시, Fobidden(403) 응답 코드와 Permission Denied라는 응답 사유가 전달되었다.<br>(403에 대한 페이지는 못만들었다 ^^;)</p>
<h2 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h2><p>DispatcherServlet에 디폴트로 등록 된 3가지 HandlerExceptionResolver에서 예외처리를 하지 못하는 경우, 마지막으로 <code>DefaultHandlerExceptionResolver</code>에서 예외처리를 해준다.</p>
<p>DefaultHandlerExceptionResolver에서는 내부적으로 Spring 표준 예외처리를 해준다.<br>각 상황에 걸맞는 응답 코드를 리턴해 주는 역할을 한다. </p>
<ul>
<li>Request URL에 맞는 Controller를 못찾는 경우 &#x3D;&#x3D;&gt; 404 Not Found</li>
<li>Controller 메소드 실행 중 예외가 발생하는 경우 &#x3D;&#x3D;&gt; 500 Internal Server error</li>
<li>Controller의 파라미터 형식이 잘못된 경우 &#x3D;&#x3D;&gt; 400 Bad Request</li>
</ul>
<h2 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h2><p>SimpleMappingExceptionResolver는 web.xml에 error-page를 지정하는 것과 비슷한 처리를 할 수 있도록 해준다.<br>Exception별로 error-page를 매핑할 수 있는 기능을 제공한다.</p>
<p>설정방법은 2가지로 설명하도록 하겠다.</p>
<ol>
<li>Java config 방식</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> WebMvcConfig <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name=“customMappingExceptionResolver”)</span></span><br><span class="line">    <span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title function_">customMappingExceptionResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="type">SimpleMappingExceptionResolver</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        mappings.setProperty(<span class="string">&quot;DatabaseException&quot;</span>, <span class="string">&quot;databaseError&quot;</span>);</span><br><span class="line">        mappings.setProperty(<span class="string">&quot;DemoException&quot;</span>, <span class="string">&quot;demoError&quot;</span>);</span><br><span class="line"></span><br><span class="line">        r.setExceptionMappings(mappings);  </span><br><span class="line">        r.setDefaultErrorView(<span class="string">&quot;default-error-page&quot;</span>);    </span><br><span class="line">        r.setExceptionAttribute(<span class="string">&quot;ex&quot;</span>);     </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>xml 방식</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleMappingExceptionResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;DatabaseException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;databaseError&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;DemoException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;demoError&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>자, 이만하면은 Controller 내부에서 발생하는 Exception에 대해서는 어느정도 예외처리를 할 수 있게 되었다.<br>근데 DispatcherServlet 외부의 Filter에서 예외가 발생하면은 어쩌지?</p>
<h1 id="다시-한번-Spring-MVC를-보자-자꾸-보게되네"><a href="#다시-한번-Spring-MVC를-보자-자꾸-보게되네" class="headerlink" title="다시 한번 Spring MVC를 보자 (자꾸 보게되네?)"></a>다시 한번 Spring MVC를 보자 (자꾸 보게되네?)</h1><p><img src="./spring-mvc-request.jpg" alt="spring-mvc-request"></p>
<p>Spring MVC의 대한 처리는 99프로가 <code>Dispatcher Servlet</code>에서 일어난다. 그렇기 때문에 Dispatcher Servlet 내부에서 발생한 Exception은 Dispatcher Servlet 내부에서 자체적으로 해결이 가능하다.<br>하지만, Dispatcher Servlet 이전에 Filter에서 Exception이 발생 할 경우 Dispatcher Servlet 내의 <code>HandlerExceptionResolver</code>의 처리를 받을 수 없다. 이럴때는 어떡할건가?<br>지금부터 Filter에 대한 예외처리 방법을 알아보도록 하겠다.</p>
<h1 id="Filter에서-예외가-발생하면"><a href="#Filter에서-예외가-발생하면" class="headerlink" title="Filter에서 예외가 발생하면?"></a>Filter에서 예외가 발생하면?</h1><p>filter에서 예외가 발생하면 여태까지 말한 예외처리 방법이 적용되지 않는다. 왜냐? 실제 Dispatcher Servlet에서 처리하기도 전에 예외가 발생되기 때문이다.</p>
<p>Filter에서 예외가 발생하면 Web Application 레벨에서 처리를 해줘야 한다.</p>
<ul>
<li>web.xml에 error-page를 잘 등록해줘서 에러를 사용자에게 표현</li>
<li>Filter 내부에서 try-catch 구문을 통해 예외 발생 시, <code>request.getRequestDispatcher(String)</code>를 통해 어떻게든 Controller까지 예외를 보내서 처리하게 한다.<br>(웬만하면 Filter보다는 Interceptor에서 로직을 처리하는 것이 예외처리가 쉽곘다.<br> Interceptor는 DispatcherServlet 내부에서 실행되는 것이니 여태 얘기한 Spring에서 지원하는 예외처리 방법을 모두 사용할 수 있다.)</li>
</ul>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a target="_blank" rel="noopener" href="https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc">https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc</a><br><a target="_blank" rel="noopener" href="https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver">https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver</a><br><a target="_blank" rel="noopener" href="http://www.nextree.co.kr/p3239/">http://www.nextree.co.kr/p3239/</a><br><a target="_blank" rel="noopener" href="http://springsource.tistory.com/7">http://springsource.tistory.com/7</a><br><a target="_blank" rel="noopener" href="http://stewie38.tistory.com/59">http://stewie38.tistory.com/59</a><br><a target="_blank" rel="noopener" href="https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/08/29/2018-08-29-java-exception/">Java Exception</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-30</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Java/">Java</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h1><p>Java&#x2F;Spring 기반의 코드를 작성하다보면, 예외 처리는 필수적이고 늘상 마주하게 되는 문제이다.<br>예외처리가 견고한 프로그램은 유지보수하기 좋을 뿐만 추가적인 요구사항이 발생하였을 때, 처리하기 쉬워지고 편해진다. 최근 업무 중에 Spring Interceptor 단계에서 예외처리를 구현해야 했다. 그때 사용한 @ControllerAdvice, @ExceptionHandler 등의 어노테이션를 사용하여 쉽게 예외처리를 구현 할 수 있었고, 그에 관련된 추가적인 내용을 기록해보고자 2장의 포스팅을 작성하게 되었다.<br>이번 장에서는 Java의 기본 예외처리에 대한 내용을 리마인드 해보는 포스팅을 작성하도록 하겠다.</p>
<h1 id="에러-Error-와-예외-Exception"><a href="#에러-Error-와-예외-Exception" class="headerlink" title="에러(Error)와 예외(Exception)"></a>에러(Error)와 예외(Exception)</h1><p><img src="./Exception-Class.png" alt="Exception-Class"></p>
<p>Java에서는 3가지 종류의 Throwable을 제공한다. 크게는 Error와 Exception으로 구분한다.<br>Exception은 또 2가지 종류로 구분 할 수 있다.</p>
<ul>
<li>Error <ul>
<li>주로 프로그램이 사용 불가능한 상태가 되었을 때 발생한다.</li>
<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>
<li>주로 JVM 자원 부족이나, 불변식을 사용하는 경우에 발생한다.</li>
<li>관례적으로 Error에 대해서는 Custom Class를 만들지 않는다.<br>(어플리케이션 레벨에서 발생하므로 이미 지정된 Error만으로도 충분 - 개발자가 관여x)</li>
</ul>
</li>
<li>Checked Exception <ul>
<li>점검지정 예외</li>
<li>Checked Exception이 발생하는 메소드를 사용하는 경우에는 개발자는 반드시 예외처리에 대한 로직을 구현해야한다.</li>
<li>예외처리를 하지 않을 시, <code>컴파일 오류가 발생</code></li>
<li>주로 <code>복구 가능한 상황</code>에 Checked Exception을 사용한다.</li>
<li>Custom Checked Exception을 만들 경우 <code>Exception</code> 클래스를 상속하여 만든다.</li>
</ul>
</li>
<li>Unchecked Exception<ul>
<li>무점검 예외</li>
<li>프로그래밍 오류를 표현하는 경우 사용</li>
<li>개발자가 굳이 예외처리를 할 필요가 없으며, 메소드 시그니처에 throws를 이용하여 상위 로직으로 Exception을 throw할 필요가 없다.</li>
<li>주로 <code>복구 불가능한 상황</code>에 대해 사용한다.</li>
<li>Custom Unchecked Exception을 만들 경우 <code>RuntimeException</code> 클래스를 상속하여 만든다</li>
</ul>
</li>
</ul>
<h2 id="추가적으로"><a href="#추가적으로" class="headerlink" title="추가적으로.."></a>추가적으로..</h2><p>개발자 정의 Exception을 생성하다 보면은 주로 RuntimeException으로 많이 생성하게 된다.<br>아무래도 발생 즉시 시스템 실행 스택을 중단 할 수 있으며, 명시적인 throw처리를 안해줘도 되기 때문에 편리함 때문에 사용하는 것 같다. 최근 면접관으로 들어가서 예외처리에 대한 질문을 하면 Checked Exception은 절대로 쓰면 안된다! 라고 대답을 하는 지원자들이 있었다. Checked Exception을 절대 쓰지 말자? 이는 Exception의 성질을 모르는 사람이 하는 소리라고 생각한다.<br>Checked Exception으로 처리하는 이유는 API를 사용하여 개발하는 개발자가 반드시 이 단계에서 예외에 대한 처리를 하여 대행 할 수 있는 로직을 추가 하던, 아예 throw를 시켜 중지 하던 개발자에게 어느정도 선택의 기회를 주는 것이라고 생각한다.<br>지원자가 했던 “Checked Exception 절대 쓰지 말자!” “Checked Exception이 발생하더라도 Unchecked Exception으로 Wrapping 하자!”라는 의견도 어느정도는 맞는 소리이다.<br>새로운 Checked Exception이 발생하는 코드가 메소드 내의 메소드의 내의 메소드의 내의….로 간다고 하면 밑에서 부터 계속 throw..throw.. 해야 하는 상황이 발생 할 수 있다. 이러한 Exception에 대해서 전역적인 처리를 하는 경우에는 위의 말이 당연히 맞는 소리이다.<br>다시 한번 Exception의 성질을 생각해 보고, 왜 Java가 굳이 Checked Exception, Unchecked Exception을 구분했는지를 생각을 해봐야 할 것이다.</p>
<h1 id="Java에서의-기본적인-예외처리"><a href="#Java에서의-기본적인-예외처리" class="headerlink" title="Java에서의 기본적인 예외처리"></a>Java에서의 기본적인 예외처리</h1><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><p>try-catch-finally 구문은 웬만한 프로그래밍 언어에서 지원하는 구문이다.<br>프로그래밍 기본을 공부한 사람이라면 모두가 알고 있는 구문이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//핵심 로직 수행</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">//예외 발생 시, 예외에 대한 처리</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">//try block, catch block 실행 후 반드시 실행하는 로직</span></span><br><span class="line">   <span class="comment">//주로 자원에 대한 해제 로직이 추가된다. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="try-catch-resources"><a href="#try-catch-resources" class="headerlink" title="try-catch-resources"></a>try-catch-resources</h2><p>Java 1.7에 추가된 문법이다. Closeable Interface를 구현하는 객체에 대한 Resource해제를 자동으로 할 수 있도록 해 준다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123; </span><br><span class="line">     <span class="comment">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class="line">     <span class="comment">//핵심 로직 수행</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//예외 발생 시, 예외에 대한 처리</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Multi-catch"><a href="#Multi-catch" class="headerlink" title="Multi catch"></a>Multi catch</h2><p>Java 1.7에 추가된 문법이다. 기존에는 catch 구문을 여러개 둘 수 있었다. Java 1.7부터는 하나의 catch문에서 여러개의 Exception에 대한 처리를 공통적으로 할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123; </span><br><span class="line">     <span class="comment">//try block이 종료 되면 InputStream에 대한 close() 메소드를 실행</span></span><br><span class="line">     <span class="comment">//핵심 로직 수행</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException | ArrayIndexBoundException e) &#123;</span><br><span class="line">    <span class="comment">//예외 발생 시, 예외에 대한 처리</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h1><p>Checked Exception가 발생되는 메소드를 사용되는 경우 IDE에서는 개발자에게 2가지 중 하나의 행위를 하라고 한다.</p>
<ul>
<li>Method signiture에 throws 구문을 통해 예외처리를 상위 메소드로 전파하여 예외처리를 미루기</li>
<li>try-catch구문을 통한 예외처리를 하도록 유도</li>
</ul>
<p>보통의 경우에는 try-catch 구문을 통해서 해결 가능한 에러에 대한 처리로직을 개발자가 구현 해주면 된다.<br>하지만 Service Layer에서 예외처리를 하는 경우에는 2가지를 모두 다 사용하는게 좋다고 본다.</p>
<h1 id="Anti-Pattern"><a href="#Anti-Pattern" class="headerlink" title="Anti Pattern"></a>Anti Pattern</h1><ol>
<li>Exception을 무시 하지 말 것</li>
<li>exception.printStackTrace()는 쓰는게 아니다.</li>
<li>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</li>
</ol>
<h2 id="Exception을-무시-하지-말-것"><a href="#Exception을-무시-하지-말-것" class="headerlink" title="Exception을 무시 하지 말 것"></a>Exception을 무시 하지 말 것</h2><p>간혹 코드를 보다 보면..</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//열심히 작성</span></span><br><span class="line">    veryHardDo();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//아무것도 안해요~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이런 코드를 보는 경우가 있다. 일단 veryHardDo() 메소드에서 Exception을 던져 주니 컴파일 에러가 안나려면 뭔가 처리는 해야 겠고.. 막상 catch구문에 작성할 코드는 없어보이고… 할 때 저런 코드들이 나오게 된다.<br>이는 매~~우 좋지 않은 코드이다. 실제 RuntimeException이 발생 했을 때도 에러 파악도 안되고, 시스템은 작동 안하고.. 왜 에러나는지 모르는 코드가 되어버린다.<br>되도록이면 catch구문을 작성하였으면 반드시 예외처리에 대한 로직을 구현 해주자.. (로그라도 남겨줘 ㅜㅜ)</p>
<h2 id="exception-printStackTrace-는-쓰는게-아니다"><a href="#exception-printStackTrace-는-쓰는게-아니다" class="headerlink" title="exception.printStackTrace()는 쓰는게 아니다."></a>exception.printStackTrace()는 쓰는게 아니다.</h2><p>exception.printStackTrace()는 에러가 발생한 원인에 대한 Stack Trace를 추적하여 개발자에게 디버깅을 할 수 있는 힌트를 제공해 준다 (개발 할 때는 이거만한 게 없긴하다.)<br>하지만 성능을 생각하는 개발자라면 이 메소드는 사용을 지양해야 한다. 실제로 java reflection을 사용하여 trace를 추적하는 것이기 때문에 꽤 오버헤드가 발생한다. 성능이 중시되는 어플리케이션이라면 stackTrace에 대한 추적 보다는 간단한 로그정도로 에러의 원인을 파악하는 것이 좋다.</p>
<h2 id="반복문-내에서는-Checked-Exception에-대한-처리는-지양하자"><a href="#반복문-내에서는-Checked-Exception에-대한-처리는-지양하자" class="headerlink" title="반복문 내에서는 Checked Exception에 대한 처리는 지양하자"></a>반복문 내에서는 Checked Exception에 대한 처리는 지양하자</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String item : items) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        insert(item);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다.<br>이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.</p>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p>Effective Java 2nd Edition (Joshua Bloch)<br>가장 빨리 만나는 자바8 (카이 호스트만)</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/08/25/2018-08-18-spring-filter-interceptor/">Spring Filter와 Interceptor</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-25</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Spring/">Spring</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Spring-Core/">Spring Core</a></span><div class="content"><h1 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며.."></a>들어가며..</h1><p>개발 업무를 하다보면 갖가지 인증 처리, 예외 처리등을 위해 Filter나 Interceptor를 사용해야 하는 부분이 많다. 특히 필자의 경우에는 어뷰징 방지등을 위한 코드로 Interceptor를 많이 사용하였다.<br>회사 코드 중에서는 어뷰징 방지 코드가 Service Layer에서 이루어지는 경우가 많은데, 비교하는 코드에서 중복코드가 몇 군데 있었고, 다른 코드에서 중복코드를 양산 할 수 있다는 생각이 들어 이번 기회에 Interceptor로 리팩토링을 하였다.<br>Filter의 경우는 거의 사용해 본 적이 없는데, 자주 쓰는 Interceptor와 비교하여 그 내용을 이번 기회에 정리하고자 한다.</p>
<h1 id="Spring-Request-Flow"><a href="#Spring-Request-Flow" class="headerlink" title="Spring Request Flow"></a>Spring Request Flow</h1><p><img src="./spring-request-lifecycle.jpg" alt="spring-request-lifecycle"></p>
<p>이 이미지가 Spring MVC 구조를 가장 잘 보여주는 도식도 인 것 같아 첨부하였다.<br>(많은 블로그에서 이 이미지를 사용하고 있는점은 안 비밀이다.)</p>
<p>그림에서 보면 가장 먼저 눈에 띄는 것은 Filter와 Interceptor의 실행 위치이다.<br>Filter는 Dispatcher Servlet 이전에 실행된다. 정확히는 WAS내의 ApplicationContext에서 등록된 필터가 실행 된다. Filter는 <code>J2EE 표준스펙</code>이며, Servlet 2.3에 등장하였다. 따라서 Spring Framework가 아니어도 Servlet Filter를 사용할 수 있다. </p>
<p>Interceptor의 실행 위치는 DispatchetServlet 내부에서 실행이 되고 있다.<br>따라서 Interceptor는 <code>Spring Framework에서 제공하는 API</code>이며, 전후처리에 대한 편리한 인터페이스를 제공하고 있다. 공통적으로 Spring에서는 전후처리기로 많이 사용하고 있다. AOP와 함께 핵심 로직에 영향을 주지 않고 요청을 가로채어 처리하는 Spring의 큰 특징 중 하나로 생각된다.</p>
<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>위에서 잠깐 설명 했듯이, (Servlet) Filter는 J2EE 표준 스펙으로 Servlet API 2.3 부터 등장 하였다.<br>실행 위치는 WAS(Web Application Server) 내의 Application Context에 등록 된 필터가 요청 URL Pattern에 따라 실행 되도록 되어있다. 대표적인 예로는 <code>Spring Security, CORS Filter</code>등이 있다.</p>
<h2 id="Filter-Chain"><a href="#Filter-Chain" class="headerlink" title="Filter Chain"></a>Filter Chain</h2><p><img src="./filter-chain.gif" alt="filter-chain"></p>
<p>Filter의 큰 특징으로는 Filter chain이라는 개념이 있다.<br>실제 Filter는 web.xml에 등록 된 Filter들을 WAS 구동 시에, WAS내의 ApplicationContext내의 <code>Standard Context</code>에 <code>FilterMap</code>이라는 Array에 등록된다. 실행 시에 요청 URL의 형식에 맞는 Pattern을 가진 Filter들로 <code>Filter chain</code>을 구성하게 되어 순차적으로 실행 되게 된다. </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationDispatcher.java#L705">Request에 대한 Filter Chain 생성</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/tomcat/blob/trunk/java/org/apache/catalina/core/ApplicationFilterFactory.java#L53">Request URL에 대한 FilterMap 생성</a></li>
</ul>
<p>※ 본 포스팅에서는 WAS에 대한 기준을 Apache Tomcat 8.5를 기준으로 작성하였다.</p>
<p>Filter Chain이 실행되는 순서는 2가지 원칙에 의해 결정된다.</p>
<ol>
<li>url-pattern 매칭은 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>
<li>servlet-name 매칭이 web.xml 파일에 표기된 순서대로 필터 체인을 형성한다.</li>
</ol>
<h2 id="Filter-생성"><a href="#Filter-생성" class="headerlink" title="Filter 생성"></a>Filter 생성</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">		<span class="comment">//filter 생성 시 처리</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//다음 Filter 실행 전 처리 (preHandle)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//다음 filter-chain에 대한 실행 (filter-chain의 마지막에는 Dispatcher servlet실행)</span></span><br><span class="line">		filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//다음 Filter 실행 후 처리 (postHandle)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//filter 제거 시 처리 (보통 자원의 해제처리를 한다.)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="설정-방법"><a href="#설정-방법" class="headerlink" title="설정 방법"></a>설정 방법</h2><p>Filter를 등록하는 방식을 크게 4가지 정도 있다.</p>
<ol>
<li>web.xml 등록 방식</li>
<li>Java config 등록 방식 -&gt; FilterRegistration Bean을 정의하여 추가할 Filter를 정의</li>
<li>java config 등록 방식 -&gt; AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</li>
<li>@WebFilter Annotation 등록 방식</li>
</ol>
<h3 id="1-web-xml-등록-방식"><a href="#1-web-xml-등록-방식" class="headerlink" title="1. web.xml 등록 방식"></a>1. web.xml 등록 방식</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.springstudy.filter.TestFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- url-pattern 대신 Servlet을 지정할 수도 있다. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-FilterRegistration-Bean을-정의하여-추가할-Filter를-정의"><a href="#2-FilterRegistration-Bean을-정의하여-추가할-Filter를-정의" class="headerlink" title="2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의"></a>2.  FilterRegistration Bean을 정의하여 추가할 Filter를 정의</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.filter.TestFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplicationFilterConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">testFilterRegistration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">filterRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">TestFilter</span>());</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setName(<span class="string">&quot;Test-Filter&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">testFilter2Registration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">filterRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">TestFilter2</span>());</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setName(<span class="string">&quot;Test-Filter2&quot;</span>);</span><br><span class="line">        filterRegistrationBean.setOrder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Filter chain의 실행 순서는 Filter1(Prehandle) -&gt; Filter2(Prehandle) -&gt; Filter2 (Posthandle) -&gt; Filter1 (Posthandle) 순으로 실행 된다. </p>
<h3 id="3-AbstractAnnotationConfigDispatcherServletInitializer에서-getServletFilter에-추가"><a href="#3-AbstractAnnotationConfigDispatcherServletInitializer에서-getServletFilter에-추가" class="headerlink" title="3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가"></a>3.  AbstractAnnotationConfigDispatcherServletInitializer에서 getServletFilter에 추가</h3><p>※ 이 방식은 Spring Boot 환경에서 동작하지 않았다. (Embedded Tomcat이어서 그런가? 잘 모르겠다.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInitializerConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="comment">//추가할 필터 리스트를 추가한다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;<span class="keyword">new</span> <span class="title class_">TestFilter</span>(), <span class="keyword">new</span> <span class="title class_">TestFilter2</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-Component-WebFilter-Order-어노테이션을-이용한-필터-등록"><a href="#4-Component-WebFilter-Order-어노테이션을-이용한-필터-등록" class="headerlink" title="4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록"></a>4. @Component, @WebFilter, @Order 어노테이션을 이용한 필터 등록</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter(</span></span><br><span class="line"><span class="meta">        description = &quot;1번째 필터&quot;,</span></span><br><span class="line"><span class="meta">        urlPatterns = &quot;/*&quot;,</span></span><br><span class="line"><span class="meta">        filterName = &quot;Test-Filter1&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start testFilter1&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;finish testFilter1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다른 설정 파일 없이 Filter Class파일 하나만 가지고 Filter에 대한 설정을 할 수 있다.<br>@Component -&gt; Component-scan 시 Spring Bean으로 등록 된다.<br>@WebFIlter -&gt; Filter등록에 필요한 Interface를 제공한다.<br>@Order -&gt; @Component 어노테이션 사용 시 <code>Order Interface</code> 사용이 가능하다. Filter chain에 대한 순서를 지정 할 수 있다.<br>개인적으로 가장 깔끔한 방법이라 생각하지만, Ordering 시 헷갈릴 수 있을 것 같다는 생각이 들었다.</p>
<h1 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h1><p>인터셉터는 주로 세션에 대한 체크, 인증 처리 등에 사용한다. 위에서 말했듯이 필자는 대부분의 어뷰징에 대한 처리를 인터셉터 단에서 처리하고 했다. 또한 특정 상품 진입 시, 권한 체크, 제약 조건 체크들도 인터셉터 단에서 처리 한 경험이 있다.</p>
<p>인터셉터도 필터와 비슷한 방식으로 작동한다. 하지만 필터와는 다르게 <code>preHandle(), postHandle()</code> 메소드가 구분 되어져 있어, 분기가 명확하다.<br>또한 Filter와는 다르게 <code>handlerMethod</code>를 파라미터로 제공하여 AOP 비스무리한 효과를 낼 수 있다. handler에서는 실행하고자 하는 컨트롤러에 대한 method 시그니처를 제공하여 좀 더 기능을 확장할 수 있다는 장점이 있다.</p>
<h2 id="Interceptor-동작-방식"><a href="#Interceptor-동작-방식" class="headerlink" title="Interceptor 동작 방식"></a>Interceptor 동작 방식</h2><ol>
<li>외부로 부터 요청이 들어오면 DispatcherServlet에서 요청을 처리한다.</li>
<li>DispatcherServlet의 doDispatch() 메소드에서 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1013">getHandler()</a> 메소드로 HandlerExecutionChain를 호출 한다.<br>(정확히는 RequestMappingHandlerAdapter의 HandlerExecutionChain)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1227">getHandler()</a> 메소드 내부에는 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L401">getHandlerInternal()</a> 메소드로 handler를 가져오는 부분이 있다.<br>   이 부분이 바로 요청 URL과 매칭하는 Controller 메소드를 찾아내는 부분이다.</li>
<li>그 다음 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L480">getHandlerExecutionChain()</a> 메소드에서 요청 메소드의 URL에 대해 이미 등록 된 interceptor 들의 url-pattern들과 매칭 되는 interceptor 리스트를 추출한다.</li>
<li>추출 된 interceptor들에 대해 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1032">preHandle()</a> 메소드를 실행 시킨다.<br>(preHandle() 메소드의 리턴 타입은 boolean인데 false가 리턴 되는 경우에는 Controller 메소드를 실행 하지 않는다.)</li>
<li>그 다음 요청 URL에 맞는 Controller 메소드를 실행 시킨다.</li>
<li>메소드 작업이 끝난 뒤 추출 된 interceptor들에 대해 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1044">postHandle()</a> 메소드를 실행 시킨다.</li>
</ol>
<h2 id="설정-방법-1"><a href="#설정-방법-1" class="headerlink" title="설정 방법"></a>설정 방법</h2><p>설정 방법은 크게 2가지로 이루어져 있다.</p>
<ol>
<li><p>servlet-context.xml에 등록</p>
</li>
<li><p>Java-config 방식을 이용한 등록 -&gt; WebMvcConfigurationSupport 이용하여 등록</p>
</li>
</ol>
<h3 id="1-Servlet-context-xml에-등록"><a href="#1-Servlet-context-xml에-등록" class="headerlink" title="1. Servlet-context.xml에 등록"></a>1. Servlet-context.xml에 등록</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/client&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/client/test1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">class</span>=<span class="string">&quot;com.example.springstudy.interceptor.TestInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-WebMvcConfigurationSupport-이용하여-등록"><a href="#2-WebMvcConfigurationSupport-이용하여-등록" class="headerlink" title="2. WebMvcConfigurationSupport 이용하여 등록"></a>2. WebMvcConfigurationSupport 이용하여 등록</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.interceptor.TestInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.interceptor.TestInterceptor2;</span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * addInterceptors 메소드를 통해 Interceptor 등록</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addInterceptors(registry);</span><br><span class="line">        <span class="comment">//String... 타입으로 여러개 지정 가능</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">TestInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/client/test1&quot;</span>, <span class="string">&quot;/client/help&quot;</span>);</span><br><span class="line">        <span class="comment">//List 타입으로 여러개 지정 가능</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">TestInterceptor2</span>())</span><br><span class="line">                .addPathPatterns(Lists.newArrayList(<span class="string">&quot;/client&quot;</span>, <span class="string">&quot;/client/test1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p><a target="_blank" rel="noopener" href="http://javacan.tistory.com/entry/58">http://javacan.tistory.com/entry/58</a><br><a target="_blank" rel="noopener" href="http://www.leafcats.com/39">http://www.leafcats.com/39</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war">https://stackoverflow.com/questions/6560969/how-to-define-servlet-filter-order-of-execution-using-annotations-in-war</a><br><a target="_blank" rel="noopener" href="https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/">https://supawer0728.github.io/2018/04/04/spring-filter-interceptor/</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/08/11/2018-08-11-spring-dispatcher-servlet/">Spring Dispatcher Servlet</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-11</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Spring/">Spring</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/core/">core</a></span><div class="content"><h1 id="Spring-Dispatcher-Servlet"><a href="#Spring-Dispatcher-Servlet" class="headerlink" title="Spring Dispatcher Servlet"></a>Spring Dispatcher Servlet</h1><p>Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소이다.  DispatcherServlet은 Controller로 향하는 모든 웹요청의 진입점이며, 웹요청을 처리하며, 결과 데이터를 Client에게 응답 한다.  DispatcherServlet은 Spring MVC의 웹요청 Life Cycle을 주관한다 할 수 있다. </p>
<h1 id="Front-Controller-Pattern"><a href="#Front-Controller-Pattern" class="headerlink" title="Front Controller Pattern"></a>Front Controller Pattern</h1><p>Dispatcher Servlet이 없는 MVC Model2 방식에서는 Servlet을 생성하면 각각의 mapping-url을 web.xml에 설정해 줘야하는 번거로움이 있었다. Front Controller Pattern을 접목한 Spring은 Dispatcher Servlet하나만 web.xml에 등록하여, 더 효과적으로 MVC패턴을 사용할 수 있도록 변경 되었다.</p>
<p><img src="./Front-controller-pattern.png" alt="Front-controller-pattern"></p>
<p>Spring에서는 모든 요청이 Dispatcher Servlet으로 오게 된다.<br>모든 요청에 대해 Dispatcher Servlet에 등록된 Handler Mapping(대표적으로 RequestMappingHandlerAdapter)을 통해 Controller에 개발자가 정의한 로직을 호출 하도록 해준다.<br>자세한 Cycle은 아래 그림과 같다.</p>
<h1 id="Dispatcher-Servlet-Cycle"><a href="#Dispatcher-Servlet-Cycle" class="headerlink" title="Dispatcher Servlet Cycle"></a>Dispatcher Servlet Cycle</h1><p><img src="./dispatcher-servlet-lifecycle.jpg" alt="dispatcher-servlet-lifecycle"></p>
<ol>
<li>doService 메소드에서부터 웹요청의 처리가 시작된다. DispatcherServlet에서 사용되는 몇몇 정보를 request 객체에 담는 작업을 한 후 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L942">doDispatch()</a> 메소드를 호출한다. </li>
<li>아래 3번~13번 작업이 doDispatch 메소드안에 있다. Controller, View 등의 컴포넌트들을 이용한 실제적인 웹요청처리가 이루어 진다.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017">getHandler()</a>  메소드는 RequestMapping 객체를 이용해서 요청에 해당하는 Controller를 얻게 된다.</li>
<li>요청에 해당하는 Handler를 찾았다면 Handler를 HandlerExecutionChain 객체에 담아 리턴하는데, 이때 HandlerExecutionChain는 요청에 해당하는 interceptor들이 있다면 함께 담아 리턴한다.</li>
<li>실행될 interceptor들이 있다면 interceptor의 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1036">preHandle()</a> 메소드를 차례로 실행한다.</li>
<li>Controller의 인스턴스는 HandlerExecutionChain의 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1017">getHandler()</a> 메소드를 이용해서 얻는다.</li>
<li>HandlerMapping과 마찬가지로 여러개의 HanlderAdaptor를 설정할 수 있는데, <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1024">getHandlerAdaptor()</a> 메소드는 Controller에 적절한 HanlderAdaptor 하나를 리턴한다.</li>
<li>선택된 HanlderAdaptor의 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1041">handle()</a> 메소드가 실행되는데, 실제 실행은 파라미터로 넘겨 받은 Controller를 실행한다.</li>
<li>계층형 Controller인 경우는 handleRequest 메소드가 실행된다. @Controller인 경우는 HandlerAdaptor(RequestMappingHandlerAdapter)가 ServletInvocableHandlerMethod 이용해 실행할 Controller의 메소드를 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L894">invoke()</a>한다. (이 과정에서 Controller Parameter에 대한 ArgumentResolver 처리와 ReturnValue에 대한 ReturnValueHandler에 대한 처리가 이루어진다.)</li>
<li>interceptor의 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1048">postHandle()</a> 메소드가 실행된다.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1409">resolveViewName()</a> 메소드는 논리적 뷰 이름을 가지고 해당 View 객체를 반환한다.</li>
<li>Model 객체의 데이터를 보여주기 위해 해당 View 객체의 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1119">render()</a> 메소드가 수행된다.</li>
</ol>
<h1 id="web-xml-설정하기"><a href="#web-xml-설정하기" class="headerlink" title="web.xml 설정하기"></a>web.xml 설정하기</h1><h3 id="기본-설정"><a href="#기본-설정" class="headerlink" title="기본 설정"></a>기본 설정</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span> <span class="comment">&lt;!-- appServlet 웹어플리케이션의 모든 웹요청을 DispatcherServlet이 처리한다.--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- Default Servlet을 의미 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>appServlet 웹 어플리케이션의 모든 요청을 Dispatcher Servlet이 처리하게 된다.<br>Dispatcher Servlet도 Servlet이기 때문에 web.xml에 등록하며, <code>/</code> prefix로 들어오는 모든 요청을 처리한다.</p>
<p>servlet-name은 DispatcherServlet이 기본(default)으로 참조할 빈 설정 파일 이름의 prefix가 되는데, (servlet-name)-servlet.xml 같은 형태이다.  위 예제와 같이 web.xml을 작성했다면 DispatcherServlet은 기본으로 <code>/WEB-INF/appServlet-servlet.xml</code>을 찾게 된다. </p>
<h3 id="contextConfigLocation을-이용한-설정"><a href="#contextConfigLocation을-이용한-설정" class="headerlink" title="contextConfigLocation을 이용한 설정"></a>contextConfigLocation을 이용한 설정</h3><p>빈 설정 파일(xml파일)을 하나 이상을 사용하거나, 파일 이름과 경로를 직접 지정해주고 싶다면 contextConfigLocation 라는 초기화 파라미터 값에 빈 설정 파일 경로를 설정해준다. </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">        	/WEB-INF/spring/appServlet/servlet-context.xml</span><br><span class="line">		<span class="comment">&lt;!-- 파일을 여러개 등록하고 싶다면 ,(콤마) ;(세미콜론) 으로 구분한다 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="ContextLoaderListener를-이용한-설정"><a href="#ContextLoaderListener를-이용한-설정" class="headerlink" title="ContextLoaderListener를 이용한 설정"></a>ContextLoaderListener를 이용한 설정</h3><p>일반적으로 빈 설정 파일은 하나의 파일만 사용되기 보다는 persistance, service, web등 layer 단위로 나뉘게 된다.<br>또한, 같은 persistance, service layer의 빈을 2개 이상의 DispatcherServlet이 공통으로 사용할 경우도 있다.<br>이럴때는 공통빈(persistance, service)설정 정보는 ApplicationContext에, web layer의 빈들은 WebApplicationContext에 저장하는 아래와 같은 방법을 추천한다.<br>공통빈 설정 파일은 서블릿 리스너로 등록된 org.springframework.web.context.ContextLoaderListener로 로딩해서 ApplicationContext을 만들고,<br>web layer의 빈설정 파일은 DispatcherServlet이 로딩해서 WebApplicationContext을 만든다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ApplicationContext 빈 설정 파일--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--빈 설정 파일들간에 구분은 줄바꿈(\n),컴마(,),세미콜론(;)등으로 한다.--&gt;</span> </span><br><span class="line">        /WEB-INF/config/myapp-service.xml,</span><br><span class="line">        /WEB-INF/config/myapp-dao.xml 		</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">웹 어플리케이션이 시작되는 시점에 ApplicationContext을 로딩하며, </span></span><br><span class="line"><span class="comment">로딩된 Bean정보는 모든 WebApplicationContext들이 참조할 수 있다.</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> <span class="tag">&lt;/<span class="name">listener</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>employee<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> 		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">    	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> 	</span><br><span class="line">    	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span> /WEB-INF/config/myapp-servlet.xml <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>webservice<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> 		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">    	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">    	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span> /WEB-INF/config/myapp-webservice.xml <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>맨위에 설정한 Application Context에서 정의 한 설정파일은 모든 Servlet에서 참조 될 수 있다.<br>(선언은 하지 않았지만, Global 개념으로 생각하면 될 것 같다.)</p>
<p>따라서<br>employee Servlet에는 myapp-service, myapp-dao, myapp-servlet에 대한 설정을 가지고 있고,<br>webServices Servlet에는 myapp-service, myapp-dao, myapp-webservice에 대한 설정을 가지고 있다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a target="_blank" rel="noopener" href="http://mangkyu.tistory.com/18">http://mangkyu.tistory.com/18</a><br><a target="_blank" rel="noopener" href="http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet">http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet</a><br><a target="_blank" rel="noopener" href="http://hermeslog.tistory.com/156">http://hermeslog.tistory.com/156</a><br><a target="_blank" rel="noopener" href="https://github.com/dongmyo/dispatcher2">https://github.com/dongmyo/dispatcher2</a><br><a target="_blank" rel="noopener" href="https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/">https://justforchangesake.wordpress.com/2014/05/07/spring-mvc-request-life-cycle/</a><br><a target="_blank" rel="noopener" href="https://nesoy.github.io/articles/2017-02/Front-Controller">https://nesoy.github.io/articles/2017-02/Front-Controller</a><br><a target="_blank" rel="noopener" href="http://wonwoo.ml/index.php/post/1590">http://wonwoo.ml/index.php/post/1590</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/08/10/2018-08-10-httprequest-client-ip/">Spring에서 Client IP구하기</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Spring/">Spring</a></span><div class="content"><h1 id="HttpServletRequest에서-IP-구하기"><a href="#HttpServletRequest에서-IP-구하기" class="headerlink" title="HttpServletRequest에서 IP 구하기"></a>HttpServletRequest에서 IP 구하기</h1><p>회사 업무 중에 Controller에서 Request를 보낸 IP에 대한 정보를 저장해야 하는 요청 사항이 있었다. 처음에는 Javascript를 통해 Client IP를 조회한 다음에 파라미터로 보내야 하나? 하고 생각 했지만, 적용해야 하는 부분도 많았고, IP를 조회 하는 중복 코드가 다수 발생 할 것이라 생각이 들었다. </p>
<p>생각을 해보니, HttpServletRequest내의 Header정보 중에는 분명 IP정보도 잊겠지? 라는 생각으로 찾아보았고, 아니나 다를까 IP정보를 조회할 수 있는 방법이 있었다.</p>
<p>HttpServletRequest에서 IP를 구하는 소스는 아래와 같다.</p>
<p>이전 포스트에서 잠깐 다뤘던 내용을 그대로 퍼왔다 (<a href="https://jaehun2841.github.io/2018/08/10/2018-08-10-spring-argument-resolver/">Spring Argument Resolver</a>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodParameter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modelAndViewContainer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nativeWebRequest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webDataBinderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">clientIp</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp)|| <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        <span class="comment">//Proxy 서버인 경우</span></span><br><span class="line">        clientIp = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        <span class="comment">//Weblogic 서버인 경우</span></span><br><span class="line">        clientIp = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        clientIp = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        clientIp = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">        clientIp = request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clientIp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>보통은 HttpServletRequest.getRemoteAddr()를 하면은 서비스를 요청한 Client의 IP정보가 나온다. 하지만 서버 구성이 L4 스위치, 프록시 서버, 로드밸런서등이 구성 되어 있으면 다른 Header를 통해 ip를 접근해야 하는 경우도 생긴다.<br>구글링을 해보니 위의 코드 정도면은 예상 되는 Case를 Filtering 하여 Client IP를 구할 수 있다고 한다.</p>
<h1 id="IPv6-형식으로-나오는-IP를-IPv4로-변환"><a href="#IPv6-형식으로-나오는-IP를-IPv4로-변환" class="headerlink" title="IPv6 형식으로 나오는 IP를 IPv4로 변환"></a>IPv6 형식으로 나오는 IP를 IPv4로 변환</h1><p>위의 코드를 적용하여 Client IP가 제대로 나오는지 테스트를 해보았다.</p>
<p><img src="./ipv6.png" alt="ipv6"></p>
<p>예상과는 다르게 IPv6 형태의 IP주소가 나오는 것을 볼 수 있었다. </p>
<p> IPv6로 나오는 IP를 IPv4형식으로 나오게 하기 위해서는 WAS의 VM옵션을 추가해야 한다.</p>
<ol>
<li>Tomcat인 경우<ol>
<li>$CATALINA_HOME\bin\catalina.bat(.sh) 을 찾는다.</li>
<li><code>:noJuliConfig, :noJuliManager</code> 를 검색한다. </li>
<li>JAVA_OPTS에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if not &quot;%LOGGING_CONFIG%&quot; == &quot;&quot; goto noJuliConfig</span><br><span class="line">set LOGGING_CONFIG=-Dnop</span><br><span class="line">if not exist &quot;%CATALINA_BASE%\conf\logging.properties&quot; goto noJuliConfig</span><br><span class="line">set LOGGING_CONFIG=-Djava.util.logging.config.file=&quot;%CATALINA_BASE%\conf\logging.properties&quot;</span><br><span class="line">:noJuliConfig</span><br><span class="line">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Djava.net.preferIPv4Stack=true</span><br><span class="line"></span><br><span class="line">if not &quot;%LOGGING_MANAGER%&quot; == &quot;&quot; goto noJuliManager</span><br><span class="line">set LOGGING_MANAGER=-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">:noJuliManager</span><br><span class="line">set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Djava.net.preferIPv4Stack=true</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>개발 환경에서 VM 속성 추가 하기<ol>
<li>사용 중인 IDE에서 VM Options에 <code>-Djava.net.preferIPv4Stack=true</code> 를 추가한다.</li>
</ol>
</li>
</ol>
<p><img src="./ide-setting.png" alt="ide-setting"></p>
<p>확인 결과</p>
<p><img src="./ipv4.png" alt="ipv4"></p>
<p>127.0.0.1로 정상적인 IP가 나오는 것을 확인 하였다.</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a target="_blank" rel="noopener" href="http://all-record.tistory.com/168">http://all-record.tistory.com/168</a><br><a target="_blank" rel="noopener" href="http://www.leafcats.com/35">http://www.leafcats.com/35</a><br><a target="_blank" rel="noopener" href="http://ooz.co.kr/138">http://ooz.co.kr/138</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/08/09/2018-08-10-spring-argument-resolver/">Spring Argument Resovler</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Spring/">Spring</a></span><div class="content"><p>회사 업무 중에 이미 개발 된 API의 Controller에 요청을 보낸 Client의 IP 정보를 보내달라는 수정 사항이 들어 왔다. 처음에는 Javascript로 Client IP를 찾아서 Controller의 메소드의 Parameter로 보내야 하나.. 하고 생각 했지만, 적용해야 하는 부분이 여러군데 있었고, Client IP를 script로 찾기가 번거로웠다.</p>
<p>그러던 와중 HttpServletRequest 객체에 Client IP정도는 있지 않을까? 하는 고민을 해보았고, 바로 검색해보았다. 아니나 다를까 HttpServletRequest에서 Client IP를 구할 수 있었다.</p>
<p>하지만 이미 만들어진 Controller의 메소드에서 HttpServletRequest객체의 Client IP를 조회하는 소스를 중복해서 넣는 것은 번거럽고 꾀나 길었다.. (Client IP를 구하는 코드가 한 10줄 정도는 된다.)</p>
<p>그래서 중간에 Filter나 Interceptor로 해볼까..? 하다가 Argument Resolver라는 기능을 발견하여 사용해보았다. 그에 대한 기록을 위해 포스팅을 작성한다.</p>
<h1 id="Spring-Argument-Resolver"><a href="#Spring-Argument-Resolver" class="headerlink" title="Spring Argument Resolver"></a>Spring Argument Resolver</h1><p>Spring Argument Resolver는 <code>Controller에 들어오는 파라미터를 가공</code> 하거나 (ex. 암호화 된 내용 복호화), 파라미터를 추가하거나 수정해야 하는 경우에 사용한다. 사실 Argument Resolver가 없어도 개발하는데 문제는 없다. Controller에서 파라미터를 가공&#x2F;추가&#x2F;수정 할 수 있기 때문이다. 하지만, 이러한 방식은 중복 코드를 양산하게 되며,  깔끔한 코드를 작성하기 어렵게 만든다. Spring에서 제공하는 Argument Resolver를 이용하면 Controller의 파라미터에 대한 공통 기능을 제공 할 수 있다.<br>Spring에서는 <code>HandlerMethodArgumentResolver</code>라는 인터페이스를 사용하여 개발자가 기능을 확장 할 수 있도록 해준다.</p>
<h1 id="Argument-Resolver-동작-방식"><a href="#Argument-Resolver-동작-방식" class="headerlink" title="Argument Resolver 동작 방식"></a>Argument Resolver 동작 방식</h1><p><img src="./Dispatch-Seq.jpg" alt="Dispatch-Seq"></p>
<p>(중국어?로 되어있지만 이 그림이 순서도를 잘 그려둔것 같아 첨부했다.)</p>
<ol>
<li>Client Request 요청</li>
<li>Dispatcher Servlet에서 해당 요청을 처리</li>
<li>Client Request에 대한 Handler Mapping <ol>
<li>RequestMapping에 대한 매칭 (RequestMappingHandlerAdapter)</li>
<li>Interceptor처리</li>
<li><code>Argument Resolver 처리</code> &lt;– 바로 여기서 우리가 지정한 Argument Resolver 실행</li>
<li>Message Converter 처리</li>
</ol>
</li>
<li>Controller Method invoke</li>
</ol>
<p><img src="./RequestMappingHandlerAdapter.png" alt="RequestMappingHandlerAdapter"></p>
<p>RequestHandlerMappingAdapter.java &gt; getDefaultArgumentResolvers</p>
<p>위에서 지정 된 순서대로 Argument Resolver를 실행 한다.<br>메소드의 파라미터 타입, Annotation등을 이용하여 Argument Resolver에 대한 적용 여부를 결정한다.<br>아랫 줄 쯤에 getCustomArgumentResolvers는 개발자가 지정한 CustomArgumentResolver를 등록하여 실행 스택에 포함 되도록 해준다.</p>
<h1 id="Custom-Argument-Resolver-만들기"><a href="#Custom-Argument-Resolver-만들기" class="headerlink" title="Custom Argument Resolver 만들기"></a>Custom Argument Resolver 만들기</h1><p>내가 업무 중에 처한 상황을 바탕으로 설명을 하자면, HttpServletRequest로 부터 Client IP정보를 얻을 수 있다는 정보를 알아 냈다. (자세한건 여기에..)</p>
<p>기존에 있던 Controller에서 바로 clientIp를 파라미터로 받아서 처리 할 수 있도록 해 볼 예정이다.<br>Custom Argument Resolver를 만들기 위해서는 <code>HandlerMethodArgumentResolver</code> 인터페이스를 구현하여 만든다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.resolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientIpArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resolveArgument를 실행 할 수 있는 method인지 판별</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> &#123;</span><br><span class="line">        <span class="comment">//@ClientIP 어노테이션이 붙은 파라미터에 대해 적용</span></span><br><span class="line">        <span class="keyword">return</span> methodParameter.hasParameterAnnotation(ClientIP.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method parameter에 대한 Argument Resovler로직 처리</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndViewContainer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nativeWebRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webDataBinderFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) nativeWebRequest.getNativeRequest();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">clientIp</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp)|| <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(clientIp) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(clientIp)) &#123;</span><br><span class="line">            clientIp = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clientIp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>HandlerMethodArgumentResolver에서는 두 가지 메소드를 구현하도록 되어있다.</p>
<ul>
<li>supportsParameter : 호출 되는 Controller의 파라미터를 검사하여 CustomArgumentResolver의 로직을 수행 할 지를 검사한다. (예시에서는 @ClientIP가 선언 된 파라미터만 ArgumentResolver를 적용하도록 하였다.)<ul>
<li>물론 파라미터 타입이나, 특수한 규칙에 의해 ArgumentResolver를 적용할 파라미터를 필터링 할 수 있다.</li>
</ul>
</li>
<li>resolveArgument : supportsParameter가 true인 파라미터에 대해 어떤 값을 넣어줄 것인지에 대한 로직을 수행한다.</li>
</ul>
<h1 id="Custom-Argument-Resolver-등록하기"><a href="#Custom-Argument-Resolver-등록하기" class="headerlink" title="Custom Argument Resolver 등록하기"></a>Custom Argument Resolver 등록하기</h1><p>개발자가 목적을 가지고 만든 Custom Argument Resolver를 등록하는 방식은 2가지가 있다.</p>
<p>전통적인 ServletContext.xml에 등록하는 방법과 Java Config를 이용하여 등록하는 방법이 있다.</p>
<ol>
<li>ServletContext.xml 에 등록하는 방법</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:argument-resolvers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.springstudy.resolver.ClientIpArgumentResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:argument-resolvers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol>
<li>Java Config를 이용하는 방법</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.resolver.ClientIpArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurationSupport를 상속 </span></span><br><span class="line"><span class="comment">//(기존에는 WebMvcConfigurerAdapter를 사용하였으나 Spring boot 2.0에서는 Deprecated 되었다.)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//우리가 만든 ArgumentResolver를 추가한다.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addArgumentResolvers(argumentResolvers);</span><br><span class="line">        argumentResolvers.add(<span class="keyword">new</span> <span class="title class_">ClientIpArgumentResolver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Controller에-적용"><a href="#Controller에-적용" class="headerlink" title="Controller에 적용"></a>Controller에 적용</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springstudy.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springstudy.annotation.ClientIP;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 요청을 보낸 Client Ip를 return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientIp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/client&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClientIp</span><span class="params">(<span class="meta">@ClientIP</span> String clientIp)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Request Client Ip = %s&quot;</span>, clientIp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Controller 메소드의 파라미터에 @ClientIP 어노테이션이 붙은 파라미터에는 ClientArgumentResolver의 로직을 수행한 데이터가 바인딩 된다.</p>
<p>실행 결과</p>
<p><img src="./argument-resolver-result.png" alt="argument-resolver-result"></p>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p>토비의 스프링 vol.2</p>
<p><a target="_blank" rel="noopener" href="http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0">http://jekalmin.tistory.com/entry/%EC%BB%A4%EC%8A%A4%ED%85%80-ArgumentResolver-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0</a></p>
<p><a target="_blank" rel="noopener" href="http://zgundam.tistory.com/38">http://zgundam.tistory.com/38</a></p>
<p><a target="_blank" rel="noopener" href="http://rstoyanchev.github.io/spring-mvc-31-update/#13">http://rstoyanchev.github.io/spring-mvc-31-update/#13</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/07/24/2018-07-24-spring-aop5/">Spring AOP (5)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-24</time><div class="content"><p>AOP를 어느정도 공부하고 회사 업무에 써먹어 보기로 했다.<br>결제에 대한 로그 데이터를 DB에 Insert하는 로직을 AOP로 구현하고 코드 리뷰를 딱! 올렸다.<br>AOP사용 시 주의 할 부분에 대한 리뷰가 달렸다.<br>아래의 리뷰와 같다.</p>
<p><img src="/Users/carrey/Desktop/jaehun2841.github.io/img/2018-07-24/aop5/AOP%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2.png" alt="AOP코드리뷰"></p>
<p>메소드 명에 대한 와일드 카드 처리는 AOP를 설정한지 모르는 다른 개발자가 똑같은 prefix로 시작하는 경우 의도치 않은 Advice로직을 적용 시킬 수 있기 때문에 주의를 강조 했다.</p>
<p>이를 극복 할 수 있는 방법으로 Custom Annotation 클래스를 생성하여 메소드의 Annotation으로 pointcut을 잡아 보는 것을 알아보았다.</p>
<h1 id="Custom-Annotation"><a href="#Custom-Annotation" class="headerlink" title="Custom Annotation"></a>Custom Annotation</h1><p>API에서 지정된 Annotation 이외에 개발자가 필요로 목적으로 정의한 Annotation을 말한다.</p>
<h2 id="Annotation-생성하기"><a href="#Annotation-생성하기" class="headerlink" title="Annotation 생성하기"></a>Annotation 생성하기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span>  <span class="comment">//Annotation의 상속이 가능함 </span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">//JavaDoc 문서 추가 가능</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 컴파일 이후에도 JVM에 의해서 참조가 가능</span></span><br><span class="line"><span class="comment">//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효</span></span><br><span class="line"><span class="comment">//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 사라짐 (ex. lombok)</span></span><br><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">        ElementType.PACKAGE,         // 패키지 선언시</span></span><br><span class="line"><span class="meta">        ElementType.TYPE,            // 타입 선언시</span></span><br><span class="line"><span class="meta">        ElementType.CONSTRUCTOR,     // 생성자 선언시</span></span><br><span class="line"><span class="meta">        ElementType.FIELD,           // 멤버 변수 선언시</span></span><br><span class="line"><span class="meta">        ElementType.METHOD,          // 메소드 선언시</span></span><br><span class="line"><span class="meta">        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시</span></span><br><span class="line"><span class="meta">        ElementType.LOCAL_VARIABLE,  // 지역 변수 선언시</span></span><br><span class="line"><span class="meta">        ElementType.PARAMETER,       // 매개 변수 선언시</span></span><br><span class="line"><span class="meta">        ElementType.TYPE_PARAMETER,  // 매개 변수 타입 선언시</span></span><br><span class="line"><span class="meta">        ElementType.TYPE_USE         // 타입 사용시</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;  <span class="comment">//interface에 @를 붙여주면 Annotation으로 등록</span></span><br><span class="line">    <span class="comment">/* enum 타입을 선언할 수 있습니다. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Quality</span> &#123;BAD, GOOD, VERYGOOD&#125;</span><br><span class="line">    <span class="comment">/* String은 기본 자료형은 아니지만 사용 가능합니다. */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/* 배열 형태로도 사용할 수 있습니다. */</span></span><br><span class="line">    <span class="type">int</span>[] values();</span><br><span class="line">    <span class="comment">/* enum 형태를 사용하는 방법입니다. */</span></span><br><span class="line">    Quality <span class="title function_">quality</span><span class="params">()</span> <span class="keyword">default</span> Quality.GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Annotation-Pointcut-지정하기"><a href="#Annotation-Pointcut-지정하기" class="headerlink" title="Annotation Pointcut 지정하기"></a>Annotation Pointcut 지정하기</h2><p>예시로 Annotation을 추가하여 Pointcut을 설정해 보았다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aopexam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//AOP Advisor를 Component로 선언하여 ComponentScan이 되어야 AOP적용 가능</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&#123;&quot;com.example.aopexam&quot;, &quot;com.example.custom.annotation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopExamApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(AopExamApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aopexam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.custom.annotation.CustomLog;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/aop-test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApiService apiService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@CustomLog</span> <span class="comment">//get 메소드에 @CustomLog추가</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getTest</span><span class="params">()</span> &#123;</span><br><span class="line">        apiService.method(ApiType.GET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTest</span><span class="params">()</span> &#123;</span><br><span class="line">        apiService.method(ApiType.POST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putTest</span><span class="params">()</span> &#123;</span><br><span class="line">        apiService.method(ApiType.PUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTest</span><span class="params">()</span> &#123;</span><br><span class="line">        apiService.method(ApiType.DELETE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.custom.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">//메소드 어노테이션 적용</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomLog &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.custom.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span> <span class="comment">//cglib 사용 -&gt; class기반 proxy생성</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomLogAdvisor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Annotation을 기준으로 pointcut설정</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.example.custom.annotation.CustomLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customLogPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(value=&quot;customLogPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pringLog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;메소드 실행 전 무조건 이 로그를 보게 될 것이야...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/aop-test</span><br><span class="line"></span><br><span class="line">메소드 실행 전 무조건 이 로그를 보게 될 것이야...</span><br><span class="line">[ApiService.method] apiType : GET</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/07/21/2018-07-22-spring-aop4/">Spring AOP (4)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-22</time><div class="content"><h1 id="AspectJ란"><a href="#AspectJ란" class="headerlink" title="AspectJ란?"></a>AspectJ란?</h1><blockquote>
<p>AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능이다. 이클립스 재단 오픈 소스 프로젝트에서 독립형 또는 이클립스로 통합하여 이용 가능하다. AspectJ는 최종 사용자를 위한 단순함과 이용성을 강조함으로써 폭넓게 사용되는 AOP에 대한 디 팩터 표준(사실 상 표준)이 되었다.</p>
</blockquote>
<p>AspectJ란 순수 Spring AOP API에서 제공하지 않는 필드에 대한 Advisor를 지원하고, <code>CTW, LTW</code>과 같은 다양한 위빙 방법을이용할 수 있는 기능을 제공하여 프로그램의 퍼포먼스를 향상 시킬 수 있도록 해준다.<br>또한 @Aspect 어노테이션을 바탕으로 Aspect 로직을 작성 할 수 있어 기존의 xml방식보다는 더 편리하다.<br>현재는 Spring AOP + AspectJ는 거의 표준이라고 할 정도로 많이 사용이 되고 있는 추세다. AspectJ는 스프링 뿐만 아니라 AOP를 지원하지 않는 프레임 워크에서도 AOP를 지원할 수 있도록 도움을 주는 API이다.</p>
<blockquote>
<p>Aspect란?</p>
<p>Aspect란 객체지향 언어의 클래스와 비슷한 개념이라고 생각하면 이해하기 쉽다.<br>그 자체로 애플리케이션의 도메인 로직을 담은 핵심기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화 해놓은 것이다.<br>구조적으로 보자면 Aspect &#x3D; PointCut + Advisor이다.</p>
</blockquote>
<h1 id="위빙-Weaving"><a href="#위빙-Weaving" class="headerlink" title="위빙 Weaving"></a>위빙 Weaving</h1><p>위빙(Weaving) 이란? Aspect 클래스에 정의 한 Advice 로직을 타깃(Target)에 적용하는 것을 의미한다.<br>위빙 방법으로는 RTW, CTW, LTW 3가지가 있다.</p>
<h2 id="런타임-시-위빙-RTW-Runtime-Weaving"><a href="#런타임-시-위빙-RTW-Runtime-Weaving" class="headerlink" title="런타임 시, 위빙 (RTW: Runtime Weaving)"></a>런타임 시, 위빙 (RTW: Runtime Weaving)</h2><p>Spring AOP에서 사용하는 위빙 방식이다. Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행한다.<br>실제 런타임 상, Method 호출 시에 위빙이 이루어 지는 방식이다.<br>소스파일, 클래스 파일에 대한 변형이 없다는 장점이 있지만, 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어진다는 단점이 있다. 또한 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRArzBX0BqyZ3iAK8yaBbFHkewLoHMLGLEy_BEUkOzZ6g5IBXTcNw" alt="Spring aopì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼"></p>
<h2 id="컴파일-시-위빙-CTW-Compile-time-Weaving"><a href="#컴파일-시-위빙-CTW-Compile-time-Weaving" class="headerlink" title="컴파일 시, 위빙 (CTW: Compile time Weaving)"></a>컴파일 시, 위빙 (CTW: Compile time Weaving)</h2><p>AspectJ에는 AJC (AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.<br>AJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.<br>장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. (JVM 상에 올라갈 때 메소드 내에 이미 advise 코드가 삽입 되어있기 때문) 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다. (거의 같이 사용 불가)</p>
<h3 id="CTW를-사용하기-위한-메이븐-설정"><a href="#CTW를-사용하기-위한-메이븐-설정" class="headerlink" title="CTW를 사용하기 위한 메이븐 설정"></a>CTW를 사용하기 위한 메이븐 설정</h3><p><strong>라이브러리 추가:</strong> (pom.xml)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><strong>플러그인 설정:</strong> (pom.xml)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">showWeaveInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWeaveInfo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">complianceLevel</span>&gt;</span>$&#123;aspectj-compiler.version&#125;<span class="tag">&lt;/<span class="name">complianceLevel</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outxml</span>&gt;</span>true<span class="tag">&lt;/<span class="name">outxml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>(*IntelliJ를 사용하고 있다면 설정에서 컴파일러를 AJC 로 변경하여 손쉽게 CTW를 사용할 수 있다.)</em></p>
<p>위의 플러그인 설정은 mojohaus에 제공하는 aspects-maven-plugin을 사용 </p>
<p>AspectJ Compiler(AJC)를 사용하여 AspectJ Aspect를 클래스에 적용</p>
<h2 id="클래스-로드-시-위빙-LTW-Load-time-Weaving"><a href="#클래스-로드-시-위빙-LTW-Load-time-Weaving" class="headerlink" title="클래스 로드 시, 위빙 (LTW: Load time Weaving)"></a>클래스 로드 시, 위빙 (LTW: Load time Weaving)</h2><p> ClassLoader를 이용하여 클래스가 JVM에 로드 될 때 바이트 코드 조작을 통해 위빙이 되는 방식<br>RTW처럼 소스파일과 클래스 파일에 조작을 가하지 않아 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임 시, 시간은 CTW보다 상대적으로 느리다.<br>Application Context에 객체가 로드될 때, aspectj weaver와 spring-instrument에 의한 객체 handling이 발생하기 때문에 performance가 저하된다.</p>
<p>그리고 설정이 가장 복잡하지 않은가 싶다..</p>
<p>아래 내용들은 LTW를 사용하기 위해 해줘야 하는 설정들이다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span> <span class="comment">&lt;!-- 스프링 설정 파일에 추가 servlet.xml --&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableLoadTimeWeaving</span> <span class="comment">//Java Configuration에서 해당 LTW기능을 사용하도록 설정해준다.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//IDE에서 개발 시, 해당 설정을 추가</span><br><span class="line">-javaagent:/fullpath/aspectjweaver-1.8.1.jar </span><br><span class="line">-javaagent:/fullpath/spring-instrument-4.0.6.RELEASE.jar </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//톰캣 시작 시, jvmargs 옵션에 추가</span><br><span class="line">-javaagent:/weavers/spring-instrument-4.0.6.RELEASE.jar</span><br></pre></td></tr></table></figure>



<h1 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h1><h2 id="JoinPoint-관련-Annotations"><a href="#JoinPoint-관련-Annotations" class="headerlink" title="JoinPoint 관련 Annotations"></a>JoinPoint 관련 Annotations</h2><p>공통적으로 pointcut에 대한 표현식을 인자로 받는다.</p>
<ul>
<li>@Before<ul>
<li>메소드 실행 이전 부분에 대한 Joinpoint 설정</li>
</ul>
</li>
<li>@Around<ul>
<li>ProceedingJoinPoint라는 파라미터를 이용하여 Target메소드 실행을 직접 제어 할 수 있다.</li>
<li>메소드 실행 시점을 기준으로 AOP로직을 구현할 수 있어 가장 강력하게 사용이 가능하다.</li>
</ul>
</li>
<li>@After<ul>
<li>메소드 실행 이후 부분의 대한 Joinpoint 설정</li>
</ul>
</li>
<li>@AfterReturning<ul>
<li>메소드 실행 이후 return 실행 이후 부분에 대한 Joinpoint 설정</li>
</ul>
</li>
<li>@AfterThrowable<ul>
<li>메소드 실행 시, Throw 이후 부분에 대한 Joinpoint 설정</li>
</ul>
</li>
</ul>
<h2 id="Pointcut-관련-Annotation"><a href="#Pointcut-관련-Annotation" class="headerlink" title="Pointcut 관련 Annotation"></a>Pointcut 관련 Annotation</h2><ul>
<li>@Pointcut<ul>
<li>Pointcut에 대한 표현식을 값으로 가짐</li>
<li>@Pointcut이 적용된 메소드는 무조건 리턴타입이 void</li>
</ul>
</li>
</ul>
<h1 id="Point-Cut"><a href="#Point-Cut" class="headerlink" title="Point Cut"></a>Point Cut</h1><p>포인트 컷이란? 메소드의 Joinpoint에 대한 Advice가 언제 실행될 지를 지정하는데 사용한다.<br>여러 메소드의 Joinpoint시점 여러개를 묶어 하나의 pointcut으로 만들 수 있다.</p>
<p><img src="https://t1.daumcdn.net/cfile/tistory/223B623D548C415631" alt="pointcut 개념"></p>
<h2 id="포인트-컷-표현식"><a href="#포인트-컷-표현식" class="headerlink" title="포인트 컷 표현식"></a>포인트 컷 표현식</h2><p>Expression을 이용한 pointcut 표현식</p>
<p><img src="http://1.bp.blogspot.com/-pKNhsebIDls/VhWk6fUzqJI/AAAAAAAAAU0/dl6e6V3G1KE/s1600/pointcut%2Bexpression-execution.jpg" alt="pointcut ííìì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼"></p>
<ol>
<li><p>접근 제어자 패턴 public이나 protected (private는 사용하지 말자 proxy구현 불가)</p>
<ul>
<li>* 인 경우 모든 접근제어자에 대해 설정 가능</li>
<li>생략 시, * 과 같은 효과</li>
</ul>
</li>
<li><p>리턴 타입 : 메소드의 리턴 타입을 지정한다. (해당 타입으로 리턴되는 모든 메소드에 대한 Pointcut)</p>
<ul>
<li>필수 적으로 기재해야 한다.</li>
<li>* 을 통해 모든 리턴 타입에 대해 Pointcut을 설정 할 수 있다.</li>
</ul>
</li>
<li><p>Class 타입 : 클래스 타입 패턴 (해당 클래스에 대한 모든 메소드에 대해 Pointcut)</p>
<ul>
<li>단, 패키지 명도 기재해야 함 </li>
<li>com.springframework.aop.. 처럼 ..으로 붙이는 경우 하위 패키지에 대한 모든 클래스의 모든 메소드에 대해 Pointcut을 처리</li>
<li>필수 적으로 기재해야 한다.</li>
</ul>
</li>
<li><p>메소드 명 : 특정 클래스 또는 패키지 하위의 메소드 명에 대해 Pointcut 설정</p>
<ul>
<li>필수 적으로 기재해야 한다.</li>
<li>모든 메소드에 적용 하려면 * 을 사용</li>
</ul>
</li>
<li><p>파라미터 타입 : 메소드의 파라미터 타입에 따른 Pointcut 설정</p>
<ul>
<li>필수 적으로 기재해야 한다.</li>
<li>,로 구분하여 순서대로 파라미터를 기재한다.</li>
<li>타입과 갯수에 상관없다면 .. 또는 * 를 기재한다.</li>
</ul>
</li>
<li><p>예외 타입 : 예외 클래스에 대해 Joinpoint를 설정 할 수 있다. (생략가능)</p>
</li>
</ol>
<h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2><ul>
<li><p><strong>execution(int minus(int, int))</strong>: int 타입의 리턴 값, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>
</li>
<li><p><strong>execution(* minus(int, int))</strong>: 리턴 타입은 상관없이, minus 라는 메소드 이름, 두 개의 int 파라미터를 가지는 메소드</p>
</li>
<li><p><strong>execution(* minus(..))</strong>: 리턴 타입과 파라미터의 종류 및 개수에 상관없이 minus 이름을 가진 메소드</p>
</li>
<li><p>**execution(* *(..))**: 리턴 타입, 파라미터, 메소드 이름에 상관없는 모든 메소드</p>
</li>
<li><p>**execution(* *())**: 리턴 타입, 메소드 이름에 상관없고 파라미터는 없는 모든 메소드</p>
</li>
<li><p><strong>execution(* springbook.aop.Target.*(..))</strong>: springbook.aop.Target 클래스의 모든 메소드</p>
</li>
<li><p><strong>execution(* springbook.aop.<em>.</em>(..))</strong>: springbook.aop 패키지의 모든 메소드, 단 서브패키지의 클래스는 포함 안된다.</p>
</li>
<li><p><strong>execution(* springbook.aop..<em>.</em>(..))</strong>: springbook.aop 패키지의 모든 메소드, 서브패키지의 클래스까지 포함</p>
</li>
<li><p>**execution(* <em>..Target.</em>(..))**: 패키지에는 상관없이 Target 클래스의 모든 메소드</p>
</li>
<li><p>*<em>execution(</em> *(..) throws Exception) **: Exception을 throw하는 모든 메소드</p>
</li>
<li><p><strong>within(com.springbook.aop.service.</strong>*) : service 패키지 내의 모든 Joinpoint</p>
</li>
<li><p><strong>within(com.springbook.aop.service..</strong>*) : service 패키지의 하위패키지 내의 모든 Joinpoint</p>
</li>
<li><p><strong>this(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 프록시 객체의 모든 Joinpoint</p>
</li>
<li><p><strong>target(com.springbook.aop.service.UserService)</strong> : UserService 인터페이스를 구현하는 대상 객체의 모든 Joinpoint</p>
</li>
<li><p><strong>args(java.utils.List)</strong> : 파라미터가 1개이고 List타입인 모든 Joinpoint</p>
</li>
<li><p><strong>@target(org.springframework.transaction.annotation.Transactional)</strong> :대상 객체가 @Transactional 어노테이션을 갖는 모든 결합점</p>
</li>
<li><p><strong>@within(org.springframework.transaction.annotation.Transactional)</strong> : 대상 객체의 선언 타입이 @Transactional 어노테이션을 갖는 모든 결합점</p>
</li>
<li><p><strong>@annotation(org.springframework.transaction.annotation.Transactional)</strong> : 실행 메소드가 @Transactional 어노테이션을 갖는 모든 결합점</p>
</li>
</ul>
<ul>
<li><p><strong>@args(com.xyz.security.Classified)</strong> : 단일 파라미터를 받고, 전달된 인자 타입이 @Classified 어노테이션을 갖는 모든 결합점</p>
</li>
<li><p><strong>bean(UserRepository)</strong> : “UserRepository” 빈</p>
</li>
<li><p><strong>!bean(UserRepository)</strong> :  “UserRepository” 빈을 제외한 모든 빈</p>
</li>
<li><p><strong>bean(*)</strong> : 모든 빈</p>
</li>
<li><p><em><em>bean(user</em>)</em>* : 이름이 ‘user’로 시작되는 모든 빈</p>
</li>
<li><p>*<em>bean(<em>Repository)</em></em> : 이름이 “Repository”로 끝나는 모든 빈</p>
</li>
<li><p><strong>bean(user&#x2F;*)</strong> : 이름이 “user&#x2F;“로 시작하는 모든 빈</p>
</li>
<li><p>**bean(<em>dataSource) || bean(<em>DataSource)</em></em> : 이름이 “dataSource” 나 “DataSource” 으로 끝나는 모든 빈</p>
</li>
</ul>
<h1 id="예시코드"><a href="#예시코드" class="headerlink" title="예시코드"></a>예시코드</h1><h2 id="Aspect-파일-사용"><a href="#Aspect-파일-사용" class="headerlink" title="Aspect 파일 사용"></a>Aspect 파일 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> aspect TestAdvisor &#123;</span><br><span class="line">    pointcut <span class="title function_">advicePoint</span><span class="params">()</span> : execution(* com.example.advice..*(..));</span><br><span class="line">    </span><br><span class="line">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;처음으로 실행되는 로그&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    after(Joinpoint joinpoint) : advicePoint() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;두번째로 실행되는 로그&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//order는 어떻게 주는건지 모르겠다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Aspect-어노테이션-사용"><a href="#Aspect-어노테이션-사용" class="headerlink" title="@Aspect 어노테이션 사용"></a>@Aspect 어노테이션 사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAdvisor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * advice패키지 하위의 모든 클래스의 모든 메소드에 대한 pointcut</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.advice..*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@order(2)</span> <span class="comment">//order가 높은 순으로 먼저 실행</span></span><br><span class="line">    <span class="meta">@After(pointcut=&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">(Joinpoint joinpoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;처음으로 실행되는 로그&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@order(1)</span></span><br><span class="line">    <span class="meta">@After(pointcut=&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLog</span><span class="params">(Joinpoint joinpoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;두번째로 실행되는 로그&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a target="_blank" rel="noopener" href="http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220564638014</a></p>
<p><a target="_blank" rel="noopener" href="http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9">http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9</a></p>
<p><a target="_blank" rel="noopener" href="https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5">https://steemit.com/kr-dev/@nhj12311/aop-aspectj-java-aop-5</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2018/07/20/2018-07-21-spring-aop3/">Spring AOP (3)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-21</time><div class="content"><p>앞서 AOP에대한 간단한 예시와 개념을 살펴보았다.</p>
<p>이번 포스트에서는 Spring에서 제공하는 AOP 기능과 작동방식에 대해서 알아보도록 하겠다.</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP란 <code>횡단 관심사 (Cross Cutting Concern)</code> 을 한데 모아 로직을 설계한다음<br>런타임(Runtime) 시, 클래스 로드 (Load Time) 시, 컴파일(Compile Time) 시, 횡단 로직을 핵심 로직에 적용하여 작동하게 해준다. </p>
<p>이 중에서 Spring AOP는 Proxy를 이용하여 런타임 위빙(Runtime Weaving)을 이용하여 횡단 로직을 수행 할 수 있도록 한다.   Spring AOP에서 사용되는 Proxy는 2가지가 있다.<br>한가지는 JDK 1.3 부터 적용되기 시작한 JDK Dynamic Proxy가 있다. 이는 Java 라이브러리에서 제공하는 Proxy이다.<br>또 다른 한가지는 CGLIB Proxy가 있다. CGLIB를 사용하기 위해서는 개발하는 프로젝트에 CGLIB 라이브러리를 추가해야 사용이 가능하다.</p>
<h1 id="Proxy란"><a href="#Proxy란" class="headerlink" title="Proxy란?"></a>Proxy란?</h1><p><img src="https://camo.githubusercontent.com/d799bd0ae9b0df6a67b6d2c69a29f1a8eba1d8d2/687474703a2f2f6366696c6532362e75662e746973746f72792e636f6d2f696d6167652f32343237303333373531344630464635313445334336" alt="Proxy구성도"></p>
<blockquote>
<p>Proxy란 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 하는 객체의 의미한다.</p>
<p>그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃(Target) 또는 실체(Real Object) 라고 부른다.</p>
<p>토비의 스프링 vol.1 (p. 430)</p>
</blockquote>
<p>토비의 스프링 책에서는 Proxy에 대한 정의를 위와 같이 하고 있다. 실제 Target이 담당하는 역할을 요청을 대리 받아서 요청 이전, 이후에 대한 추가적인 로직을 추가 할 수 있는 객체이다. 이렇게 하면 실제 Target이 담당하는 역할에 대해서는 관여 하지 않으면서 추가적인 역할을 추가 할 수 있기 때문이다. </p>
<p>Spring에서는 Proxy를 이용해 객체지향의 5대원칙 중 하나인 OCP(Open-Close Principal : 개방폐쇄의 원칙)을 적용하고 있다.</p>
<blockquote>
<p>OCP (Open-Close Principal : 개방 폐쇄의 원칙)</p>
<p><strong>개방-폐쇄 원칙</strong>(OCP, Open-Closed Principle)은 ‘소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.’는 프로그래밍 원칙이다.  </p>
</blockquote>
<p>실제 Target에 대한 수정을 하지 않으면서, Proxy를 통해 추가적인 코드를 작성 하여 기능을 확장 시킬 수 있음을 의미한다.</p>
<h1 id="Proxy-vs-Proxy-Pattern"><a href="#Proxy-vs-Proxy-Pattern" class="headerlink" title="Proxy vs Proxy Pattern"></a>Proxy vs Proxy Pattern</h1><p>일반적으로 사용하는 하는 Proxy라는 용어와 디자인패턴에서 말하는 프록시 패턴(Proxy Pattern)은 구분할 필요가 있다.<br>비슷한 개념이지만, 내용이 조금 다르다.</p>
<p>일반적으로 부르는 Proxy는 실제 Target의 기능을 수행하면서 기능을 확장하거나 추가 하는 실제 객체(Object)를 의미한다.</p>
<p>Proxy Pattern은 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해 주는 역할을 한다.</p>
<h1 id="JDK-Dynamic-Proxy"><a href="#JDK-Dynamic-Proxy" class="headerlink" title="JDK Dynamic Proxy"></a>JDK Dynamic Proxy</h1><p><img src="https://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="JDK Dynamic Proxy"></p>
<p>JDK Dynamic Proxy는 JDK 1.3+ 부터 제공되는 Proxy Factory에 의해 런타임 시 동적으로 만들어 지는 오브젝트이다.<br>JDK Dynamic Proxy는 반드시 Interface가 정의 되어있고, Interface에 대한 명세를 기준으로 Proxy를 생성한다.<br>따라서 Interface 선언에 대한 강제성이 있다는 단점이 있다.<br>이전에는 직접 수동으로 Proxy 객체를 만들어서 사용하는 경우도 있었으나, 요즘은 자동 프록시 생성기라는 모듈을 이용하여 Dynamic Proxy를 생성한다. </p>
<p>내부적으로 Dynamic Proxy에서는 InvocationHandler라는 Interface를 구현하여 만들어지는데 InvocationHandler의 invoke라는 함수를 Override하여 Proxy의 위임 기능을 수행한다. 이 과정에서 Object에 대해 Reflection기능을 사용하여 기능을 구현하기 때문에 퍼포먼스의 하락의 원인이 되기도 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamDynamicHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExamInterface target; <span class="comment">// 타깃 객체에 대한 클래스를 직접 참조하는것이 아닌 Interface를 이용</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExamDynamicHandler</span><span class="params">(ExamInterface target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 메소드에 대한 명세, 파라미터등을 가져오는 과정에서 Reflection 사용</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> (String)method.invoke(target, args); <span class="comment">//타입 Safe하지 않는 단점이 있다.</span></span><br><span class="line">        <span class="keyword">return</span> ret.toUpperCase(); <span class="comment">//메소드 기능에 대한 확장</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="CGLIB-Proxy"><a href="#CGLIB-Proxy" class="headerlink" title="CGLIB Proxy"></a>CGLIB Proxy</h1><p>CGLIB Proxy는 순수 Java JDK 라이브러리를 이용하는 것이 아닌 CGLIB라는 외부 라이브러리를 추가해야만 사용할 수 있다.<br>실제 CGLIB의 Enhancer라는 클래스를 바탕으로 Proxy를 생성하며, JDK Dynamic Proxy의 단점인 Interface가 없어도 Proxy를 생성 할 수 있다. CGLIB Proxy는 Target Class를 상속받아 생성된다. 그렇기 때문에 개발자는 Proxy를 생성 하기 위해 굳이 Interface를 만들어야 하는 수고를 덜 수 있다.</p>
<p>하지만, 상속을 이용하는 만큼 final이나 private과 같이 상속에 대해 Override를 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다는 단점이 있다. </p>
<p>CGLIB Proxy의 경우 실제 바이트 코드를 조작하여 JDK Dynamic Proxy보다는 퍼포먼스가 상대적으로 빠른 장점이 있다.</p>
<p><img src="http://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png" alt="CGLIB Proxy"></p>
<ul>
<li><p>CGLIB Proxy 설정법</p>
</li>
<li><p>~~~yaml<br>spring.aop.proxy-target-class&#x3D;false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">~~~xml</span><br><span class="line">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; &lt;!-- AspectJ를 사용하는 경우 --&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AOP를 사용하는 경우 Interface가 있더라도 cglib사용(target class기반)을 강제한다</span></span><br><span class="line"><span class="meta">@EnableAsync(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@EnableCaching(proxyTargetClass = true)</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Spring-Bean에-대한-Proxy는"><a href="#Spring-Bean에-대한-Proxy는" class="headerlink" title="Spring Bean에 대한 Proxy는?"></a>Spring Bean에 대한 Proxy는?</h1><p>Spring에서 Bean으로 등록된 객체는 싱글톤으로 등록되어 IoC 컨테이너에서 관리 된다.<br>하지만 Bean 객체에 대해 Spring AOP를 적용하는 경우 Proxy가 생성 될 텐데.. 이 경우 이 Bean을 DI하여 사용하는 곳에서는 어떻게 Proxy를 주입하여 사용할까?</p>
<p><img src="https://dhsim86.github.io/static/assets/img/blog/web/2017-09-11-toby_spring_06_aop_2/00.png" alt="00.png"></p>
<p>Spring에서는 <code>자동 프록시 생성기</code> 라는 것이 있다.</p>
<p>빈 후처리기들 중에서 자동으로 프록시를 생성하기 위해  <code>DefaultAdvisorAutoProxyCreator</code> 라는 클래스를 사용한다.<br>이 클래스는 어드바이저를 이용한 <code>자동 프록시 생성기</code> 이다. 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록시킬 수 있다.</p>
<p>DefaultAdvisorAutoProxyCreator 빈 후처리가 등록되어 있다면, 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.</p>
<ol>
<li>후처리기는 <code>빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해</code> 전달받은 빈이 프록시 적용 대상인지 확인한다.</li>
<li>프록시 적용 대상이면 내장된 프록시 생성기를 통해 현재 빈에 대한 <code>프록시를 생성하고 어드바이저를 연결한다.</code></li>
<li>프록시가 생성되면 전달받은 Target Bean 오브젝트 대신에 Proxy 오브젝트를 스프링 컨테이너에게 돌려준다.</li>
<li>컨테이너는 빈 후처리가 돌려준 Proxy 오브젝트를 빈으로 등록한다.</li>
</ol>
<p>이 후처리기를 통해 일일이 ProxyFactoryBean을 빈으로 등록하지 않아도 여러 타깃 오브젝트에 자동으로 프록시를 적용시킬 수 있다.</p>
<h1 id="요약"><a href="#요약" class="headerlink" title="요약.."></a>요약..</h1><ul>
<li>Spring AOP는 무조건 Proxy 기반의 RTW(Run Time Weaving)을 적용한 AOP방식이다.</li>
<li>Spring AOP에서 사용하는 Proxy는 JDK Dynamic Proxy와 CGLIB Proxy를 사용한다.<ul>
<li>JDK Dynamic Proxy는 Interface 기반으로 생성 된다. (반드시 Interface가 있어야지만 생성가능하다)</li>
<li>CGLIB Proxy는 Class에 대한 Proxy생성을 지원한다 (상속을 이용)<br>따라서 final이나 private Method에 대한 AOP 불가 (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문)</li>
</ul>
</li>
<li>Spring AOP에서는 Method에 대해서만 JoinPoint를 지원한다.<br>(그 이상의 Join Point를 이용하기 위해서는 AspectJ와 같은 모듈을 이용해야 한다.)</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p>토비의 스프링 vol.1</p>
<p><a target="_blank" rel="noopener" href="http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811">http://blog.naver.com/PostView.nhn?blogId=tmondev&amp;logNo=220556587811</a></p>
<p><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99">https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="../10/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../10/">10</a><span class="page-number current">11</span><a class="page-number" href="../12/">12</a><a class="extend next" rel="next" href="../12/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="../../js/utils.js?version=1.9.0"></script><script src="../../js/fancybox.js?version=1.9.0"></script><script src="../../js/sidebar.js?version=1.9.0"></script><script src="../../js/copy.js?version=1.9.0"></script><script src="../../js/fireworks.js?version=1.9.0"></script><script src="../../js/transition.js?version=1.9.0"></script><script src="../../js/scroll.js?version=1.9.0"></script><script src="../../js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>