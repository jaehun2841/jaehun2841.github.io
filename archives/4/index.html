<!DOCTYPE html><html lang="lang"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Carrey"><meta name="copyright" content="Carrey"><title>공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다. | Carrey`s 기술블로그</title><link rel="shortcut icon" href="../../melody-favicon.ico"><link rel="stylesheet" href="../../css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://www.gravatar.com/avatar/3f8583b7b0f0c1ebd249dffad42707af?s=300"></div><div class="author-info__name text-center">Carrey</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href=".."><span class="pull-left">Articles</span><span class="pull-right">112</span></a><a class="author-info-articles__tags article-meta" href="../../tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="../../index.html">Carrey`s 기술블로그</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Carrey`s 기술블로그</div><div id="site-sub-title">공부하고, 경험하고, 삽질해서 얻은 지식들을 기록합니다.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="../../2019/03/03/effective-java-item68/">Item 68. 일반적으로 통용되는 명명 규칙을 따르라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다.<br>자바의 명명 규칙은 철자와 문법 두 범주로 나뉜다.<br>철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룬다.<br>이 규칙들은 특별한 이유가 없는 한 반드시 따르는게 좋고 이를 어기면 다른 프로그래머들이 그 코드를 읽기 번거로울 뿐 아니라 다른뜻으로 오해할 수도 있고 그로 인해 장애로 발전할 수 있다.</p>
<h1 id="명명-규칙"><a href="#명명-규칙" class="headerlink" title="명명 규칙"></a>명명 규칙</h1><h2 id="패키지-Package"><a href="#패키지-Package" class="headerlink" title="패키지 (Package)"></a>패키지 (Package)</h2><ul>
<li>패키지 (Package)와 모듈 이름은 각 요소를 **점(.)**으로 구분하여 계층적으로 짓는다.</li>
<li>요소들은 모두 소문자 알파벳 혹은 숫자로 이뤄진다.</li>
<li>com.google, kr.co.edu와 같은 식이다.</li>
<li>패키지를 설명하는 하나이상의 요소로 이루어져 있다.</li>
<li>일반적으로 8자 이하의 짧은 단어로 한다.</li>
<li>utilities보다는 util처럼 의미가 통하는 약어가 좋다.</li>
<li>요소의 이름은 보통 한 단어 혹은 약어로 이루어진다.</li>
<li>많은 기능을 제공하는 애플리케이션의 경우에는 계층을 더 많은 요소로 나누는 것이 좋다.</li>
</ul>
<h2 id="클래스-인터페이스-열거타입"><a href="#클래스-인터페이스-열거타입" class="headerlink" title="클래스, 인터페이스, 열거타입"></a>클래스, 인터페이스, 열거타입</h2><ul>
<li>클래스 명은 하나이상의 단어로 구성되며, 첫글자는 대문자로 작성한다.</li>
<li>여러 단어의 첫글자만 딴 약자나 널리 통용되는 줄임말을 제외하고는 줄임말을 쓰지 않도록 한다.</li>
<li>조합한 단어를 구분할 수 있게 <strong>camel case</strong>로 작성한다.</li>
</ul>
<h2 id="메서드-필드명"><a href="#메서드-필드명" class="headerlink" title="메서드, 필드명"></a>메서드, 필드명</h2><ul>
<li>첫 글자를 소문자로 작성하고 클래스 명과 같게 단어 별로 <strong>camel case</strong>로 작성한다.</li>
<li>첫 단어가 약자라면 단어 전체가 소문자여야 한다.</li>
<li>상수 필드는 예외다. 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 언더바(_)로 구분한다.<br>(VALUES, NEGATIVE_INFINITY등..)</li>
<li>상수 필드는 static final인 타입을 의미한다.</li>
<li>가르키는 객체가 불변이라면, 그 타입은 가변이어도 상수이다.</li>
<li>지역번수에도 동일한 규칙이 적용된다. 단, 문맥에서 의미를 쉽게 유추할 수 있는 경우에는 <strong>약어를 사용해도 좋다.</strong><br>(i, denom, houseNum등..)</li>
<li>타입 매개변수의 이름은 한 글자로 표현한다.<ul>
<li>T: 임의의 타입 (Type)</li>
<li>E: 컬렉션의 원소 (Element)</li>
<li>K: 맵의 키 (Key)</li>
<li>V: 맵의 값 (Value)</li>
<li>X: 예외 (eXception)</li>
<li>R: 메서드의 반환타입 (Return)</li>
<li>그 이외의 타입에는 T, U, V 혹은 T1, T2, T3의 식으로 사용</li>
</ul>
</li>
</ul>
<h1 id="명명-규칙2"><a href="#명명-규칙2" class="headerlink" title="명명 규칙2"></a>명명 규칙2</h1><ul>
<li>객체를 생성하는 클래스나 열거타입 인터페이스는 <strong>단수 명사나 명사구를 사용한다.</strong><ul>
<li>Thread, PriorityQueue, ChessPiece 등..</li>
</ul>
</li>
<li>객체를 생성할 수 없는 클래스 (Utils 클래스)에는 보통 <strong>복수형 명사로 짓는다.</strong><ul>
<li>Collectors, Collections 등..</li>
</ul>
</li>
<li>인터페이스 이름은 클래스명과 동일하게 짓거나, <strong>ible, able로 끝나는 형용사로 짓는다.</strong><ul>
<li>Runnable, Iterable, Accessible 등…</li>
</ul>
</li>
<li>애너테이션은 워낙 다양하게 활용되어 지배적인 규칙이 없이 명사, 형용사, 동사, 전치사가 두루 쓰인다.<ul>
<li>@Binding, @Inject, @ImplementsBy, @Singleton 등..</li>
</ul>
</li>
<li>메서드의 이름은 동사나 목적어를 포함한 <strong>동사구로 짓는다.</strong><ul>
<li>append, drawImage</li>
</ul>
</li>
<li>boolean 값을 반환하는 메서드라면 <strong>is<del>, has</del>로 짓는다.</strong><ul>
<li>isDigit, isEmpty, hasSiblings 등..</li>
</ul>
</li>
<li>반환타입이 boolean이 아닌경우 보통 명사, 명사구, get~로 짓는다.<ul>
<li>size, hashcode, getTime 등…</li>
<li>get으로 시작하는 형태는 주로 자바빈즈(JavaBeans) 명세에 뿌리를 두고 있다.</li>
<li>보통 getter&#x2F;setter의 한 묶음 형태로 만드는 경우가 많다.</li>
</ul>
</li>
<li>반환타입을 또다른 타입을 반환하는 경우에는<strong>toType</strong> 의 형태로 짓는다.<ul>
<li>toString, toArray 등..</li>
</ul>
</li>
<li>객체의 내용을 다른 뷰로 보여주는 메서드는 <strong>asType</strong> 의 형태로 짓는다.<ul>
<li>asList, asMap 등..</li>
</ul>
</li>
<li>객체의 값을 기본 타입(primitive type)으로 반환하는 경우에는 <strong>typeValue</strong> 의 형태로 짓는다.<ul>
<li>intValue, longValue 등…</li>
</ul>
</li>
<li>정적 팩터리의 이름은 다양하다<ul>
<li>from, valueOf, getInstance, newInstance 등..</li>
</ul>
</li>
</ul>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul>
<li>표준 명명 규칙을 체득하여 자연스럽게 사용하도록 연습하자</li>
<li>철자 규칙은 직관적이라 모호한 부분이 적지만, 문법 규칙은 더 복잡하고 느슨하다</li>
<li>오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안된다. 상식대로 가자</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 68. 일반적으로 통용되는 명명 규칙을 따르라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/03/03/effective-java-item67/">Item 67. 최적화는 신중히 하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="최적화에-대한-명언"><a href="#최적화에-대한-명언" class="headerlink" title="최적화에 대한 명언"></a>최적화에 대한 명언</h1><blockquote>
<p>맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)</p>
<p>- 윌리엄 울프(Wulf72)</p>
</blockquote>
<blockquote>
<p>(전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만약의 근원이다. - 도널드 크누스(Knuth74)</p>
</blockquote>
<blockquote>
<p>최적화를 할 때는 다음 두 규칙을 따르라.</p>
<p>첫 번째, 하지마라.<br>두 번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.<br>- M.A 잭슨 (Jackson75)</p>
</blockquote>
<p>위의 명언들을 풀어보면,<br>최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고 섣불리 진행하면 특히 더 그렇다.<br>빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시키는 것이다.</p>
<h1 id="프로그램을-설계할-때-생각해야-할-점"><a href="#프로그램을-설계할-때-생각해야-할-점" class="headerlink" title="프로그램을 설계할 때 생각해야 할 점"></a>프로그램을 설계할 때 생각해야 할 점</h1><h2 id="빠른-프로그램보다는-좋은-프로그램을-작성하자"><a href="#빠른-프로그램보다는-좋은-프로그램을-작성하자" class="headerlink" title="빠른 프로그램보다는 좋은 프로그램을 작성하자"></a>빠른 프로그램보다는 좋은 프로그램을 작성하자</h2><ul>
<li>좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.</li>
<li>좋은 프로그램은 정보 은닉(캡슐화) 원칙을 따르므로 개별 구성요소 내부를 독립적으로 설계할 수 있다.</li>
<li>따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.</li>
<li>구현상의 문제는 나중에 최적화 할 수 있지만, 아키텍처의 결함이 성능을 제한한다면 시스템을 다시 작성해야 하기 때문이다.</li>
<li>따라서 설계 단계에서 성능을 반드시 염두하자</li>
</ul>
<h2 id="성능을-제한하는-설계를-피하라"><a href="#성능을-제한하는-설계를-피하라" class="headerlink" title="성능을 제한하는 설계를 피하라"></a>성능을 제한하는 설계를 피하라</h2><ul>
<li>완성 후 변경하기가 가장 어려운 설계 요소는 컴포넌트끼리 또는 외부 시스템과의 소통 방식이다.</li>
<li>API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 있다.</li>
<li>완성후에는 변경하기 어렵거나 불가능 하고, 동시에 시스템 성능을 제한할 수 있다.</li>
</ul>
<h2 id="API를-설계할-때-성능에-주는-영향을-고려하라"><a href="#API를-설계할-때-성능에-주는-영향을-고려하라" class="headerlink" title="API를 설계할 때 성능에 주는 영향을 고려하라"></a>API를 설계할 때 성능에 주는 영향을 고려하라</h2><ul>
<li>가변 객체를 사용하여 내부데이터를 변경할 수 있게 만들면 불필요한 방어적 복사를 유발할 수 있다.</li>
<li>컴포지션으로 해결할 수 있는 경우에도 상속을 이용하면 상위클래스에 영원히 종속되고, 성능 제약까지 물려받는다</li>
<li>인터페이스도 있는데 굳이 클래스 타입으로 사용하면, 차후 개선된 구현체를 사용하기 어려워진다.</li>
</ul>
<h2 id="성능을-위해-API를-왜곡하지-말자"><a href="#성능을-위해-API를-왜곡하지-말자" class="headerlink" title="성능을 위해 API를 왜곡하지 말자"></a>성능을 위해 API를 왜곡하지 말자</h2><ul>
<li>API를 왜곡하도록 만든 성능 문제는 해당 플랫폼이나 아랫단 소프트웨어의 다음 버전에서 사라질 수 있다.</li>
<li>왜곡된 API를 지원하는 데 따르는 고통은 영원하다</li>
</ul>
<h2 id="프로파일링-도구를-적극-활용하자"><a href="#프로파일링-도구를-적극-활용하자" class="headerlink" title="프로파일링 도구를 적극 활용하자"></a>프로파일링 도구를 적극 활용하자</h2><ul>
<li>프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다.</li>
<li>개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공하여 개발자의 수고를 덜어준다.</li>
<li>JMH도 알아야 하는 도구이다.  프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크다.</li>
</ul>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul>
<li>빠른프로그램을 작성하려 하지 말고 좋은 프로그램을 작성하려 노력하자. 성능은 따라오기 마련이다.</li>
<li>시스템을 설계할 때 API, 네트워크 프로토코르 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두하자</li>
<li>시스템 구현을 완료했으면 측정해보고 충분히 빠르면 최적화를 하지 마라</li>
<li>성능 측정 시에는 프로파일링 도구를 이용해 문제의 원인이 되는 지점을 찾아 최적화하자</li>
<li>알고리즘을 잘못 골랐다면, 저수준 최적화는 의미가 없다. </li>
<li>만족할 만한 성능이 나올 때까지 위의 과정을 반복하고, 변경 후에는 성능 측정을 꼭하자</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 67. 최적화는 신중히 하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/03/03/effective-java-item66/">Item 66. 네이티브 메서드는 신중히 사용하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.  </p>
<blockquote>
<p>네이티브 메서드란?</p>
<p>C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.</p>
</blockquote>
<h1 id="네이티브-메서드의-주요-쓰임"><a href="#네이티브-메서드의-주요-쓰임" class="headerlink" title="네이티브 메서드의 주요 쓰임"></a>네이티브 메서드의 주요 쓰임</h1><ul>
<li>Registry 같은 플랫폼 특화기능을 사용한다.<ul>
<li>하지만 자바가 진화해가면서 하부 플랫폼의 기능을 흡수하고 있다.</li>
<li>네이티브 메서드를 사용해야하는 일이 줄어들고 있다.</li>
<li>자바9 부터는 process API를 추가해 OS에 접근하는 길을 열어주었다.</li>
</ul>
</li>
<li>네이티브 코드로 작성된 기존 라이브러리를 사용해야 하는 경우<ul>
<li>레거시 데이터를 사용하는 레거시 라이브러리</li>
<li>Java로 된 라이브러리가 없는 경우 네이티브 라이브러리를 사용한다.</li>
</ul>
</li>
<li>성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.</li>
</ul>
<h1 id="네이티브-메서드를-성능개선의-목적으로-사용하지-말라"><a href="#네이티브-메서드를-성능개선의-목적으로-사용하지-말라" class="headerlink" title="네이티브 메서드를 성능개선의 목적으로 사용하지 말라"></a>네이티브 메서드를 성능개선의 목적으로 사용하지 말라</h1><ul>
<li>자바 초기 시절 (Java 1.3)이전이라면 다른 얘기지만, 그동안 JVM은 빠른 속도로 발전해 왔다.  </li>
<li>대부분의 작업에서 Java는 다른 플랫폼과 견줄만한 성능을 보인다 (자바가 느리다는 것도 옛말)</li>
<li>네이티브 라이브러리 쪽은 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선 작업이 계속돼왔다.<br>고성능의 다중 정밀 연산이 필요한 경우에는 네이티브 메서드를 통해 GMP를 사용하는것을 고려해보자</li>
</ul>
<h1 id="네이티브-메서드의-단점"><a href="#네이티브-메서드의-단점" class="headerlink" title="네이티브 메서드의 단점"></a>네이티브 메서드의 단점</h1><ul>
<li>네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로 부터 안전하지 않다.</li>
<li>네이티브 언어는 플랫폼 종속성이 있으므로 이식성이 좋지 못하다</li>
<li>디버깅도 어렵다</li>
<li>오히려 속도가 더 느릴 수 있다.</li>
<li>JVM의 가비지 컬렉터는 네이티브 메모리는 자동 회수 하지 못하고 추적도 할 수 없다.</li>
<li>자바 코드와 네이티브 코드의 경계를 넘나 들때마다 비용이 발생한다.</li>
<li>자바 코드와 네이티브 코드간의 접착 코드(glue code)를 작성해야 하는데 이 부분도 귀찮고 가독성도 떨어진다.</li>
</ul>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul>
<li><p>네이티브 메서드를 사용하는 경우는 한번 더 생각하라</p>
</li>
<li><p>네이티브 메서드가 그렇게 성능 향상에 도움을 주지는 않는다.</p>
</li>
<li><p>네이티브 메서드를 사용해야 하는 경우에는 최소한으로 사용하고 철저한 테스트를 해야한다.</p>
</li>
<li><p>숨은 버그하나가 애플리케이션 전체에 영향을 줄 수도 있다.</p>
</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 66. 네이티브 메서드는 신중히 사용하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/03/03/effective-java-item65/">Item 65. 리플렉션보다는 인터페이스를 사용하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.<br>Class 객체가 주어지면 클래스 정보를 통해 아래와 같은 인스턴스를 가져올 수 있다.</p>
<ul>
<li>Constructor<ul>
<li>생성자 시그니처를 가져올 수 있다.</li>
<li>생성자 인스턴스를 통해 객체를 생성할 수 있다.</li>
</ul>
</li>
<li>Method<ul>
<li>Method 시그니처를 가져올 수 있다.</li>
<li>Method 인스턴스를 통해 Method를 실행시킬 수 있다. (Method.invoke)</li>
</ul>
</li>
<li>Field<ul>
<li>필드타입, 멤버필드 이름등을 가져올 수 있다.</li>
</ul>
</li>
</ul>
<h1 id="리플렉션의-단점"><a href="#리플렉션의-단점" class="headerlink" title="리플렉션의 단점"></a>리플렉션의 단점</h1><p>리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있다.<br>(예를들면.. 외부 라이브러리의 클래스를 리플렉션으로 인스턴스를 생성한다든지…)  </p>
<h2 id="컴파일타임-타입-검사가-주는-이점을-누릴-수-없다"><a href="#컴파일타임-타입-검사가-주는-이점을-누릴-수-없다" class="headerlink" title="컴파일타임 타입 검사가 주는 이점을 누릴 수 없다."></a>컴파일타임 타입 검사가 주는 이점을 누릴 수 없다.</h2><ul>
<li>예외 검사, 컴파일 타임 에러를 잡아낼 수 없다.  </li>
<li>프로그램이 리플렉션 기능을 써서 존재하지 않는 혹은 접근 불가능한 (private 메서드)를 호출하려 하면 런타임 오류가 발생한다.</li>
</ul>
<h2 id="리플렉션을-이용하면-코드가-지저분하고-장황해진다"><a href="#리플렉션을-이용하면-코드가-지저분하고-장황해진다" class="headerlink" title="리플렉션을 이용하면 코드가 지저분하고 장황해진다."></a>리플렉션을 이용하면 코드가 지저분하고 장황해진다.</h2><ul>
<li>지루한 일이고 읽기도 어렵다.</li>
</ul>
<h2 id="성능이-떨어진다"><a href="#성능이-떨어진다" class="headerlink" title="성능이 떨어진다."></a>성능이 떨어진다.</h2><ul>
<li>리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.</li>
<li>고려해야 하는 요소가 많아 정확한 차이는 이야기하기 어렵다</li>
<li>하지만 분명 느리다.</li>
</ul>
<h2 id="리플렉션은-아주-제한된-형태로만-사용해야-그-단점을-피할-수-있다"><a href="#리플렉션은-아주-제한된-형태로만-사용해야-그-단점을-피할-수-있다" class="headerlink" title="리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피할 수 있다"></a>리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피할 수 있다</h2><ul>
<li>컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을것이다.</li>
<li>리플렉션은 인스턴스 생성에만 쓰고 이렇게 만든 인터페이스나 상위 클래스로 참조해 사용하자</li>
</ul>
<h1 id="리플렉션의-취약한-예"><a href="#리플렉션의-취약한-예" class="headerlink" title="리플렉션의 취약한 예"></a>리플렉션의 취약한 예</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 클래스 이름을 Class 객체로 변환</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;String&gt;&gt; cl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;String&gt;&gt;) Class.forName(args[<span class="number">0</span>]); <span class="comment">//비검사 형변환</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;클래스를 찾을 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성자를 얻는다.</span></span><br><span class="line">    Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;String&gt;&gt; cons = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cons = cl.getDeclaredConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;매개변수 없는 생성자를 찾을 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//집합의 인스턴스를 만든다.</span></span><br><span class="line">    Set&lt;String&gt; s = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s = cons.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;생성자에 접근할 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;클래스를 인스턴스화할 수 없습니다.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;생성자가 예외를 던졌습니다: &quot;</span> + e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        fatalError(<span class="string">&quot;Set을 구현하지 않은 클래스입니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//생성한 집합을 사용한다.</span></span><br><span class="line">    s.addAll(Arrays.asList(args).subList(<span class="number">1</span>, args.length));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fatalError</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.err.println(msg);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 예시는 리플렉션의 단점을 보여준다.</p>
<ul>
<li>런타임에 총 6가지의 예외를 던질 수 있다.</li>
<li>위에서 발생하는 예외는 모두 컴파일타임에 체크할 수 있는 예외들이다.</li>
<li>클래스 이름만으로 인스턴스를 생성해내기 위해 무려 25줄이나 되는 코드를 작성했지만, 그게 아닌 경우에는 생성자 1줄이면 끝난다.</li>
<li>리플렉션 예외를 각각 잡는 대신 상위 클래스인 ReflectiveOperationException을 잡으면 코드량을 줄일 수 있다.<br>(ReflectiveOperationException은 Java 7부터 지원한다.)</li>
</ul>
<h1 id="리플렉션은-무조건-쓰지-말아야-한다"><a href="#리플렉션은-무조건-쓰지-말아야-한다" class="headerlink" title="리플렉션은 무조건 쓰지 말아야 한다?"></a>리플렉션은 무조건 쓰지 말아야 한다?</h1><ul>
<li>Spring MVC, Serialize&#x2F;Deserialize, BeanUtils.copyProperties등 실무에서 사용하는 코드에 리플렉션이 적용된 예는 굉장히 많다.</li>
<li>단점이 많다고는 하지만 공통적인 기능을 설계하거나, 재사용 가능한 코드를 설계할 경우에는 오히려 리플렉션이 적합할 수 있다.</li>
<li>그렇기 때문에 Java 1.3 이후부터 리플렉션에 대한 성능향상을 발전시켜왔다고 한다.</li>
<li>이러한 발전으로 리플렉션은 우려할 만큼 성능이 떨어지지는 않는다고 한다.</li>
<li>리플렉션을 남발하는 것이 아닌 필요한 상황에 적시적소에 사용한다면 오히려 서비스 개발을 더 단순화 시킬수 있다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 65. 리플렉션보다는 인터페이스를 사용하라</li>
<li><a target="_blank" rel="noopener" href="https://kmongcom.wordpress.com/2014/03/15/%EC%9E%90%EB%B0%94-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%A4%ED%95%B4%EC%99%80-%EC%A7%84%EC%8B%A4/">Java 리플렉션의 오해와 진실</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/03/01/effective-java-item64/">Item 64. 객체는 인터페이스를 사용해 참조하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>Item 51에 제네릭 타입으로 클래스가 아니라 인터페이스를 사용하라고 설명 되어있다.<br>이 말의 의미는 <strong>객체는 클래스가 아닌 인터페이스로 참조하라</strong> 라는 의미로 확장할 수 있다.<br>적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언해야 한다.</p>
<h1 id="유연한-프로그램을-생성하는-인터페이스-타입-변수"><a href="#유연한-프로그램을-생성하는-인터페이스-타입-변수" class="headerlink" title="유연한 프로그램을 생성하는 인터페이스 타입 변수"></a>유연한 프로그램을 생성하는 인터페이스 타입 변수</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>좋은 예는 Set 인터페이스 타입으로 변수를 선언하였다.</li>
<li>나쁜 예는 LinkedHashSet 타입으로 변수를 선언하였다.</li>
</ul>
<p>만약 LinkedHashSet을 TreeSet으로 변환해야 한다면 어떨까?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//좋은 예</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//나쁜 예</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(); <span class="comment">//컴파일 에러!</span></span><br></pre></td></tr></table></figure>

<ul>
<li>위의 좋은 예는 Set 인터페이스 타입이기 때문에 컴파일 타임&#x2F;런타임에 전혀 문제가 되지 않는다.</li>
<li>나쁜 예는 LinkedHashSet 타입이기 때문에 TreeSet을 LinkedHashSet로 형변환 할 수 없다고 에러가 발생한다.</li>
</ul>
<h1 id="인터페이스-타입의-장점"><a href="#인터페이스-타입의-장점" class="headerlink" title="인터페이스 타입의 장점"></a>인터페이스 타입의 장점</h1><ul>
<li>인터페이스 타입을 사용하면 클라이언트 코드를 수정하지 않고도 참조 객체를 변경할 수 있다.</li>
<li>다른 타입의 객체를 사용하더라도 컴파일에러&#x2F;런타임에러에 대한 걱정을 하지 않아도 된다.</li>
</ul>
<h1 id="인터페이스-타입의-단점"><a href="#인터페이스-타입의-단점" class="headerlink" title="인터페이스 타입의 단점"></a>인터페이스 타입의 단점</h1><ul>
<li>인터페이스 타입에 선언된 메서드를 구현한 메서드만 사용이 가능하다.</li>
<li>특정 구현체의 내부 메서드를 사용할 수 없다.</li>
</ul>
<h1 id="클래스를-참조해야-하는-경우"><a href="#클래스를-참조해야-하는-경우" class="headerlink" title="클래스를 참조해야 하는 경우"></a>클래스를 참조해야 하는 경우</h1><h2 id="값-타입에는-클래스를-참조하라"><a href="#값-타입에는-클래스를-참조하라" class="headerlink" title="값 타입에는 클래스를 참조하라"></a>값 타입에는 클래스를 참조하라</h2><ul>
<li>String, Integer, Long과 같이 값 타입에 대해서는 인터페이스를 사용할 수 없으니 클래스를 참조해야 한다.</li>
<li>또한 Integer, Long과 같은 타입을 사용할 때는 Number와 같은 상위 타입을 사용하지 말아야 한다.<br><strong>형변환이 발생 할 때 특정 데이터가 절삭되어 다른 결과가 발생 할 수 있기 때문이다.</strong></li>
<li>이런 경우에는 인터페이스나 상위타입 보다는 본래의 클래스로 참조하는 것이 좋다.</li>
</ul>
<h2 id="인터페이스에는-없는-메서드를-사용할-때에는-클래스를-참조해라"><a href="#인터페이스에는-없는-메서드를-사용할-때에는-클래스를-참조해라" class="headerlink" title="인터페이스에는 없는 메서드를 사용할 때에는 클래스를 참조해라"></a>인터페이스에는 없는 메서드를 사용할 때에는 클래스를 참조해라</h2><ul>
<li>PriorityQueue 클래스에는 Queue 인터페이스에는 없는 comparator 메서드를 제공한다.</li>
<li>클래스 타입을 직접 사용하는 경우에는 추가 메서드를 사용해야 하는 경우로 최소화 하는 것이 좋다.</li>
</ul>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul>
<li>인터페이스나 추상클래스를 구현하는 클래스를 사용할 때는 참조 변수를 인터페이스나 추상클래스로 사용하자</li>
<li>인터페이스나 추상클래스 타입으로 참조 변수를 사용하면 참조 객체를 바꿔도 안전하다</li>
<li>값 타입을 사용하는 경우에는 클래스 타입의 참조변수를 사용해야 한다.</li>
<li>인터페이스에는 없는 메서드를 사용할 때는 클래스 타입의 참조변수를 사용해야 한다.</li>
<li>적합한 인터페이스가 없다면 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 상위 타입을 사용해야 한다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 64. 객체는 인터페이스를 사용해 참조하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/03/01/effective-java-item63/">Item 63. 문자열 연결은 느리니 주의하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.<br>그런데 한 줄짜리 출력값(<code>return prefix + str + suffix;</code> 정도?)  혹은 작고 크기가 고정된 객체의 문자열 표현을 만들 때라면 괜찮다.<br>하지만 문자열 여러개를 사용하기 시작하면 성능 저하를 피할 수 없다.  </p>
<p><strong>문자열 연결 연산자로 문자열 n개를 연결하는 시간은 n^2에 비례한다.</strong><br>문자열은 불변이기 때문에 두 문자열을 연결하는 경우에는 양쪽의 내용을 복사하여 연결한 다음 새로운 String 객체를 만들어야 하기 때문이다.</p>
<h1 id="문자열-연결을-잘못-사용한-예-느리다"><a href="#문자열-연결을-잘못-사용한-예-느리다" class="headerlink" title="문자열 연결을 잘못 사용한 예 - 느리다!"></a>문자열 연결을 잘못 사용한 예 - 느리다!</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">statement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">        result += lineForItem(i); <span class="comment">//문자열 연결</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="StringBuilder를-사용하여-문자열을-연결한-예"><a href="#StringBuilder를-사용하여-문자열을-연결한-예" class="headerlink" title="StringBuilder를 사용하여 문자열을 연결한 예"></a>StringBuilder를 사용하여 문자열을 연결한 예</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">statement2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(numItems() * LINE_WIDTH);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numItems(); i++) &#123;</span><br><span class="line">       sb.append(lineForItem(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자바 6이후 문자열 연결 성능을 다방면으로 개선 했지만, 두 메서드의 성능 차이는 여전하다.</p>
<h1 id="String-StringBuffer-StringBuilder의-비교"><a href="#String-StringBuffer-StringBuilder의-비교" class="headerlink" title="String, StringBuffer, StringBuilder의 비교"></a>String, StringBuffer, StringBuilder의 비교</h1><ul>
<li>String과 StringBuffer는 Java 1.0의 등장과 함께 같이 등장하였다.</li>
<li>StringBuilder는 조금 뒤인 Java 1.5부터 등장하였다.</li>
<li>String의 concat연산은 + 기호를 사용하여 concatination을 수행한다.</li>
<li>StringBuffer와 StringBuilder는 append 메서드를 통해 concatination을 수행한다.</li>
<li>정확히 말하면 StringBuffer와 StringBuilder는 AbstractStringBuilder를 상속하고 있으며,<br>결국은 같은 append 메서드를 사용한다.</li>
<li>StringBuffer와 StringBuilder 차이점은 thread-safe에 있다.<ul>
<li>StringBuffer의 append 메서드에는 <code>syncronized</code> 예약어가 붙어있어 thread-safe하다</li>
<li>StringBuilder의 append 메서드는 thread-safe 하지 않다.</li>
<li>따라서 multi-thread 환경에서 문자열 결합을 할 때는 StringBuffer를 사용하는 것이 안전하다.</li>
<li>단일 thread라면 StringBuilder를 사용하는 것이 StringBuffer보다 성능이 더 좋다.<br>(아무래도 동기화 체크를 안해도 되니 말이다.)</li>
</ul>
</li>
</ul>
<h2 id="String-String-연산이-느린-이유"><a href="#String-String-연산이-느린-이유" class="headerlink" title="String + String 연산이 느린 이유"></a>String + String 연산이 느린 이유</h2><ul>
<li>String은 불변 클래스이기 때문에 String + String을 하기 위해서는 </li>
<li>String내의 char[] 혹은 byte[]를 copy한다.</li>
<li>2개의 array의 length를 더한 값으로 새로운 array를 생성한다.</li>
<li>array에 기존의 값을 채워넣는다.</li>
<li>new String(byte[]) 생성자를 통해 새로운 String 객체를 생성한다.</li>
<li>이런식으로 하면 String + String 연산이 일어날 때마다 String 객체가 생성된다.</li>
<li>Heap Memory에 String 객체가 많아지면 GC가 돌면서 String 객체를 제거한다.</li>
<li>GC는 동작 시 stop the world라는 행위를 한다. <strong>(JVM의 작동이 일시적으로 멈춘다.</strong>)</li>
<li>위와 같은 행위가 계속되면 당연히 느려 질 수 밖에 없다.</li>
</ul>
<h2 id="StringBuilder-append-메서드-파헤치기"><a href="#StringBuilder-append-메서드-파헤치기" class="headerlink" title="StringBuilder.append() 메서드 파헤치기"></a>StringBuilder.append() 메서드 파헤치기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified string to this character sequence.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The characters of the &#123;<span class="doctag">@code</span> String&#125; argument are appended, in</span></span><br><span class="line"><span class="comment">     * order, increasing the length of this sequence by the length of the</span></span><br><span class="line"><span class="comment">     * argument. If &#123;<span class="doctag">@code</span> str&#125; is &#123;<span class="doctag">@code</span> null&#125;, then the four</span></span><br><span class="line"><span class="comment">     * characters &#123;<span class="doctag">@code</span> &quot;null&quot;&#125; are appended.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to</span></span><br><span class="line"><span class="comment">     * execution of the &#123;<span class="doctag">@code</span> append&#125; method. Then the character at</span></span><br><span class="line"><span class="comment">     * index &lt;i&gt;k&lt;/i&gt; in the new character sequence is equal to the character</span></span><br><span class="line"><span class="comment">     * at index &lt;i&gt;k&lt;/i&gt; in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less</span></span><br><span class="line"><span class="comment">     * than &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;k-n&lt;/i&gt; in the argument &#123;<span class="doctag">@code</span> str&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   str   a string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a reference to this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    putStringAt(count, str);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>위의 코드는 AbstractStringBuilder의 append 메서드이다.  </li>
<li>새로운 String의 길이 만큼 AbstractStringBuilder의 내의 byte[]의 사이즈를 늘리고 복사한다.</li>
<li>그 다음 String에 대한 byte[]를 AbstractStringBuilder의 내의 byte[]에 추가한다.</li>
<li>String + String 연산과의 차이점은 불필요한 String 객체가 발생하지 않는다는 점이다</li>
</ul>
<h1 id="String-Concatination의-발전"><a href="#String-Concatination의-발전" class="headerlink" title="String Concatination의 발전"></a>String Concatination의 발전</h1><ul>
<li>Java String 연산에 대한 성능최적화를 다방면으로 생각하고 있고, Java 9 부터 String의 내부 배열을<br><strong>char[] -&gt; byte[]로 변경</strong>하여 성능을 더 향상 시켰다.</li>
<li>Java 1.5 버전부터 String + String연산에 대해 <strong>Compile Time에 StringBuilder를 사용하도록 코드를 변경한다.</strong><br>하지만 JDK가 항상 자동으로 바꿔준다는 보장이 없으니 String + String 보다는 StringBuilder를 사용해야 한다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 63. 문자열 연결은 느리니 주의하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/03/01/effective-java-item62/">Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지게 해낸다.<br>그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않는 용도로도 쓰이는 경향이 있다.</p>
<h1 id="문자열의-안티패턴"><a href="#문자열의-안티패턴" class="headerlink" title="문자열의 안티패턴"></a>문자열의 안티패턴</h1><h2 id="문자열은-다른-값-타입을-대신하기에-적합하지-않다"><a href="#문자열은-다른-값-타입을-대신하기에-적합하지-않다" class="headerlink" title="문자열은 다른 값 타입을 대신하기에 적합하지 않다."></a>문자열은 다른 값 타입을 대신하기에 적합하지 않다.</h2><p>많은 사람들이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 이용한다.<br>하지만 <strong>입력받을 데이터가 진짜 문자열인 경우에만 문자열을 사용하는 것이 좋다.</strong><br>데이터가 수치형이면 int, long, double등 수치에 대한 타입으로 사용하는 것이 좋다.<br>질문의 답이 예&#x2F;아니오라면 boolean을 사용하는것이 좋다.  </p>
<p>일반화 하여 얘기하자면,<br><strong>기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고 없다면 새로 하나 타입을 만드는 것이 좋다.</strong></p>
<h2 id="문자열은-열거-타입-대신하기에-적합하지-않다"><a href="#문자열은-열거-타입-대신하기에-적합하지-않다" class="headerlink" title="문자열은 열거 타입 대신하기에 적합하지 않다."></a>문자열은 열거 타입 대신하기에 적합하지 않다.</h2><p>상수를 열거할 경우에는 문자열 열거 패턴 클래스 보다는 열거 타입(enum)이 훨씬 낫다.</p>
<h2 id="문자열은-혼합-타입을-대신하기에-적합하지-않다"><a href="#문자열은-혼합-타입을-대신하기에-적합하지-않다" class="headerlink" title="문자열은 혼합 타입을 대신하기에 적합하지 않다."></a>문자열은 혼합 타입을 대신하기에 적합하지 않다.</h2><p>여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">compoundKey</span> <span class="operator">=</span> className + <span class="string">&quot;#&quot;</span> + i.next();</span><br></pre></td></tr></table></figure>

<p>이 방식은 단점이 많다.<br>예를 들어 문자열에 # 문자열이 있는 경우 혼란스러운 결과가 발생한다.<br>각 요소를 개별적으로 접근하기 위해서는 특정 기준을 통해 문자열을 파싱해야해서 느리고, 귀찮고, 오류 가능성도 크다.</p>
<p>이럴바에는 <strong>차라리 전용 클래스를 새로 만들어서 각 데이터 별로 멤버 변수를 취하는 것이 좋다.</strong></p>
<h2 id="문자열은-권한을-표현하기에-적합하지-않다"><a href="#문자열은-권한을-표현하기에-적합하지-않다" class="headerlink" title="문자열은 권한을 표현하기에 적합하지 않다."></a>문자열은 권한을 표현하기에 적합하지 않다.</h2><p>권한(capacity)를 문자열로 표현하는 경우가 종종 있다.</p>
<h3 id="잘못된-예-문자열을-사용하여-권한을-구분하였다"><a href="#잘못된-예-문자열을-사용하여-권한을-구분하였다" class="headerlink" title="잘못된 예 - 문자열을 사용하여 권한을 구분하였다."></a>잘못된 예 - 문자열을 사용하여 권한을 구분하였다.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocal</span><span class="params">()</span> &#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 현 스레드의 값을 키로 구분해 저장한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (키가 가르키는) 현 스레드의 값을 반환한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 방식의 문제점은 스레드 구분용 문자열 키가 global namespace에서 공유된다는 점이다.<br>이 방식이 의도대로 동작하려면 각 클라이언트가 고유한 키를 제공해야 한다.<br>만약 두 클라이언트가 서로 소통하지 못해 같은 키를 쓰기로 결정한다면, 의도치 않게 같은 변수를 공유하게 된다.<br>따라서 클라이언트는 제대로 작동하지도 않고 보안에도 취약하다.</p>
<p>이런 경우에는 String으로 권한을 구분하는 것이 아니라 별도의 타입을 만들어 해결해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocal</span><span class="params">()</span> &#123;&#125; <span class="comment">//객체 생성 불가</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">        key() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//위조 불가능한 고유 키를 생성한다.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Key</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Key key, Object value)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(Key key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 방법은 앞서의 문자열 기반 API의 문제점을 해결해 주지만 개선할 부분이 있다.<br>set&#x2F;get 메서드는 이제 static 메서드일 이유가 없다. 따라서 Key의 인스턴스 메서드로 변경하는 것이 좋다.<br>그렇게 하면 Key는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라 그 자체가 스레드 지역변수가 된다.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span>;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 API는 get으로 얻은 Object를 실제 타입으로 타입 캐스팅 해야 해서 타입안전하지 않다.<br>하지만 제네릭을 사용한다면 조금 더 타입 안전하게 만들 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Key</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul>
<li>더 적합한 데이터 티입이 있거나 새로 작성할 수 있다면, 문자열을 쓰지 말자</li>
<li>문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고 오류 가능성도 크다.</li>
<li>문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/03/01/effective-jave-item61/">Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.<br><strong>기본 타입 (Primitive type) vs 참조 타입 (Reference Type)</strong> 으로 구분 할 수 있다.  </p>
<h2 id="기본-타입-Primitive-Type"><a href="#기본-타입-Primitive-Type" class="headerlink" title="기본 타입 (Primitive Type)"></a>기본 타입 (Primitive Type)</h2><ul>
<li>int</li>
<li>long</li>
<li>short</li>
<li>double</li>
<li>char</li>
<li>boolean</li>
</ul>
<h2 id="참조-타입-Reference-Type"><a href="#참조-타입-Reference-Type" class="headerlink" title="참조 타입 (Reference Type)"></a>참조 타입 (Reference Type)</h2><ul>
<li>String</li>
<li>Integer</li>
<li>Long</li>
<li>Double</li>
<li>Boolean</li>
</ul>
<p>기본 타입에 대응되는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.</p>
<h1 id="Auto-Boxing-vs-Auto-UnBoxing"><a href="#Auto-Boxing-vs-Auto-UnBoxing" class="headerlink" title="Auto Boxing vs Auto UnBoxing"></a>Auto Boxing vs Auto UnBoxing</h1><p>Java 1.5 부터 기본 타입과 래퍼 타입(Wrapper Type, 참조 타입에 대한 클래스를 래퍼 클래스라고 함)을 자동으로 변환해 주는 기능이 추가되었다.    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">// Auto UnBoxing</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">l</span> <span class="operator">=</span> k; <span class="comment">//Auto Boxing</span></span><br></pre></td></tr></table></figure>

<p>이 기능 때문에 개발자는 별도로 Boxing과 UnBoxing을 수행해 주지 않아도 되지만, 그렇다고 두 개가 같은 것은 아니다.<br>기본 타입과 래퍼 타입에는 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.</p>
<h1 id="기본타입-vs-참조타입"><a href="#기본타입-vs-참조타입" class="headerlink" title="기본타입 vs 참조타입"></a>기본타입 vs 참조타입</h1><p>기본 타입과 참조 타입의 차이점은 크게 3가지이다.</p>
<ul>
<li><p>기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)란 속성을 갖는다.</p>
<ul>
<li><p>기본 타입은 흔히 말하는 리터럴(Literal)이다.</p>
<blockquote>
<p>리터럴(Literal)이란?</p>
<p>소스 코드의 고정된 값을 의미하는 용어이다.<br>상수(Constants) 또는 변수(Variable)에 할당 할 수 있는 값 자체를 일컫는 용어이다.</p>
</blockquote>
</li>
<li><p>기본 타입의 값은 JVM내의 Stack 메모리에 저장된다.</p>
</li>
<li><p>참조 타입의 값은 객체 내의 상수에 저장된다. 따라서 JVM 내의 Heap 메모리에 저장된다.</p>
</li>
<li><p>따라서 박싱된 타입의 객체는 같은 값이라 하더라도 다른 객체일 경우에는 다르다고 식별이 가능하다.</p>
</li>
</ul>
</li>
<li><p>기본 타입의 값은 언제나 유효한 값을 가지고 있으나 박싱된 기본타입은 유효하지 않을 수 있다.</p>
<ul>
<li>기본타입의 값은 Java의 경우 초기화 되지 않으면 0으로 초기화 된다.</li>
<li>박싱된 기본 타입의 경우에는 초기화 되지 않으면 null이 될 수 있다.</li>
</ul>
</li>
<li><p>기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.</p>
<ul>
<li>박싱된 타입은 heap에 객체를 생성하기 때문에 메모리 사용면에서 더 안좋다.</li>
<li>기본타입은 변수에 값이 있는 반면, 박싱된 기본 타입은 변수의 객체참조 정보를 바탕으로 heap에서 찾으므로<br>시간적인 측면에서 기본타입보다 값에 접근하는 시간이 더 들게 된다.</li>
</ul>
</li>
</ul>
<h1 id="잘못-구현된-비교자-예제"><a href="#잘못-구현된-비교자-예제" class="headerlink" title="잘못 구현된 비교자 예제"></a>잘못 구현된 비교자 예제</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; (i &lt; j) ? -<span class="number">1</span> : (i == j ? <span class="number">0</span> : <span class="number">1</span>); </span><br></pre></td></tr></table></figure>

<ul>
<li>위의 코드를 기반으로 Integer비교가 실행되면 같은 값을 비교한다고 해도 1이 나올 수 있다.</li>
<li>첫번째 i &lt; j 에 대한 연산 시, Integer타입인 i와 j는 기본타입 int로 언박싱된다.</li>
<li>첫번째 연산이 false이면 두번째 연산 i &#x3D;&#x3D; j에서도 false가 발생하게 된다.</li>
<li>이유는, (i, j)의 타입이 Integer로 추론되기 때문에 i &#x3D;&#x3D; j 연산이 이루어질 때 객체의 동일성검사가 이루어져 false가 발생하기 때문이다. (i와 j는 내부 값은 같지만 서로 다른 객체이기 때문이다.)</li>
</ul>
<p><strong>이처럼 같은 객체가 아니라면 박싱된 기본타입에 &#x3D;&#x3D; 연산자를 이용하여 비교하면 예상과는 다른 결과가 나올 수 있다.</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">unBoxi</span> <span class="operator">=</span> i;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">unBoxj</span> <span class="operator">=</span> j;</span><br><span class="line">    	<span class="keyword">return</span> (unBoxi &lt; unBoxj) ? -<span class="number">1</span> : (unBoxi == unBoxj ? <span class="number">0</span> : <span class="number">1</span>); </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>위와 같이 수정하면 정상적인 결과를 얻을 수 있다.</p>
<h1 id="갑자기-발생하는-NullPointerException"><a href="#갑자기-발생하는-NullPointerException" class="headerlink" title="갑자기 발생하는 NullPointerException"></a>갑자기 발생하는 NullPointerException</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Unbelievable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Integer i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">42</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;믿을 수 없군&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 프로그램은 “믿을 수 없군”을 출력하지는 않지만, 전혀 예상하지 못한 결과를 보여준다.<br>i &#x3D;&#x3D; 42를 검사하는 과정에서 NullPointerException을 던진다.<br>원인은 i가 literal 값인 42와 비교하는 과정에서 i는 Auto UnBoxing을 수행한다.<br>하지만  i는 null이기 때문에 Auto UnBoxing을 수행하는 과정에서 NullPointerException을 발생시키게 된다.  </p>
<p><strong>기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.</strong><br>하지만 박싱된 기본타입이 null인 경우에는 NullPointerException이 발생하니 주의 해야 한다.</p>
<h1 id="의도하지-않은-Auto-Boxing으로-인한-성능저하"><a href="#의도하지-않은-Auto-Boxing으로-인한-성능저하" class="headerlink" title="의도하지 않은 Auto Boxing으로 인한 성능저하"></a>의도하지 않은 Auto Boxing으로 인한 성능저하</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0L</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        sum += i; <span class="comment">//sum이 UnBoxing되어 i와 연산되고 연산 후에 AutoBoxing되어 Long타입으로 변환된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 sum을 Long으로 선언하였기 때문에 엄청난 성능상 안좋은 코드이다.<br>sum +&#x3D; i;를 수행하는 과정에서 <strong>sum이 long타입으로 UnBoxing되고</strong> sum + i 연산이 이루어진다음 <strong>Long타입으로 AutoBoxing되기 때문이다.</strong></p>
<h1 id="박싱된-기본타입은-언제-사용해야-하는가"><a href="#박싱된-기본타입은-언제-사용해야-하는가" class="headerlink" title="박싱된 기본타입은 언제 사용해야 하는가?"></a>박싱된 기본타입은 언제 사용해야 하는가?</h1><ul>
<li>컬렉션의 원소, 키, 값으로 쓴다.<ul>
<li>컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본타입을 사용해야 한다.</li>
</ul>
</li>
<li>제네릭(Generics) 타입을 이용하는 경우에도 박싱된 기본타입을 사용한다.<ul>
<li>제네릭 타입에서는 int, double과 같은 기본타입을 지원하지 않기 때문이다.</li>
</ul>
</li>
<li>리플렉션(Reflection)을 통해 메서드를 호출할 때에도 박싱된 기본타입을 사용한다.</li>
</ul>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul>
<li>기본 타입과 박싱된 기본 타입을 사용해야 한다면,  가능하면 기본 타입을 사용하는 것이 좋다.</li>
<li>기본타입은 간단하고 빠르다.</li>
<li>박싱된 기본 타입을 사용한다면 주의를 기울이자</li>
<li>AutoBoxing이 기본타입을 변경할 때 번거로움을 줄여주지만 그 위험까지 없애주지는 않는다.<ul>
<li>박싱된 기본 타입을 &#x3D;&#x3D; 연산자로 비교한다면 객체의 동일성 비교가 이뤄지는데<br>개발자가 의도한 결과가 나오지 않을 가능성이 크다.</li>
<li>&#x3D;&#x3D; 연산에서 기본 타입과 박싱된 기본 타입의 연산이 이루어지면, 박싱된 기본 타입이 UnBoxing되는데<br>박싱된 기본 타입이 null인 경우 NullPointerException이 발생한다.</li>
</ul>
</li>
<li>기본 타입을 Boxing하는 것은 필요없는 객체를 생성하는 부작용이 나올 수 있다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/02/28/effective-java-item60/">Item 60. 정확한 답이 필요하다면 Float와 Double은 피하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>float와 double 타입은 과학과 공학 계산용으로 설계되었다.<br>이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 <strong>근사치</strong> 로 계산하도록 세심하게 설계되었다.<br>따라서 정확한 결과가 필요할 때에는 사용해선 안된다<br><strong>float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다.</strong><br>0.1 혹은 10의 거듭 제곱 수를 표현할 수 없기 때문이다.</p>
<h1 id="예시-금융-계산에-부동소수-타입을-사용"><a href="#예시-금융-계산에-부동소수-타입을-사용" class="headerlink" title="예시 - 금융 계산에 부동소수 타입을 사용"></a>예시 - 금융 계산에 부동소수 타입을 사용</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">funds</span> <span class="operator">=</span> <span class="number">1.00</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">itemBought</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0.10</span>; funds &gt;= price; price += <span class="number">0.10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">&quot;개 구입&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;잔돈(달러): &quot;</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>프로그램의 실행결과는 사탕 3개를 구입한 후 잔돈은 0.39999999999999달러가 남는다고 나온다.</li>
<li>잘못된 결과이며, 올바른 결과를 위해서는 <strong>BigDecimal, int, long</strong> 을 사용해야 한다.</li>
</ul>
<h2 id="BigDecimal을-사용한-코드-속도가-느리고-쓰기-불편하다"><a href="#BigDecimal을-사용한-코드-속도가-느리고-쓰기-불편하다" class="headerlink" title="BigDecimal을 사용한 코드 - 속도가 느리고 쓰기 불편하다."></a>BigDecimal을 사용한 코드 - 속도가 느리고 쓰기 불편하다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BigDecimal</span> <span class="variable">TEN_CENTS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;.10&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">itemBought</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">funds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> TEN_CENT; funds.compareTo(price) &gt;= <span class="number">0</span>; price = price.add(TEN_CENTS)) &#123;</span><br><span class="line">        funds = funds.subtract(price);</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">&quot;개 구입&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;잔돈(달러): &quot;</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>이 프로그램의 실행결과는 사탕 4개 구입 후 잔돈이 0달러가 남는다. 올바른 답이다.</li>
<li>BigDecimal에는 2가지 단점이 있다.<ul>
<li>기본 타입보다 쓰기가 훨씬 불편하고, 느리다. 단발성 계산이라면 문제는 아니지만 쓰기 불편하다</li>
<li>BigDecimal의 대안으로 int, long을 사용해도 된다. 하지만 소수점을 직접 관리해야 한다.</li>
</ul>
</li>
</ul>
<h2 id="int를-사용한-코드-Cent로-문제를-해결"><a href="#int를-사용한-코드-Cent로-문제를-해결" class="headerlink" title="int를 사용한 코드 - Cent로 문제를 해결"></a>int를 사용한 코드 - Cent로 문제를 해결</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">itemBought</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">funds</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">10</span>; funds &gt;= price; price += <span class="number">10</span>) &#123;</span><br><span class="line">        funds -= price;</span><br><span class="line">        itemBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(itemBought + <span class="string">&quot;개 구입&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;잔돈(달러): &quot;</span> + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>int로 사용하면 BigDecimal 보다는 깔끔하고 정확한 답을 얻을 수 있다.</li>
</ul>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul>
<li>정확한 답이 필요한 계산에는 float나 double을 피해야한다.</li>
<li>소수점 추적은 시스템에 맡기고 코딩시의 불편함이나 성능저하가 중요하지 않다면 BigDecimal을 사용하라</li>
<li>BigDecimal은 8가지 반올림 모드를 제공하므로 반올림을 거의 완벽하게 제어할 수 있다.</li>
<li>성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int나 long을 사용하라</li>
<li>숫자를 9자리 10진수로 표현한다면 int를 사용하라</li>
<li>숫자를 18자리 10진수로 표현할 수 있다면 long을 사용하라</li>
<li>숫자가 18자리가 넘어가면 BigDecimal을 사용해야 한다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 60. 정확한 답이 필요하다면 float와 double은 피하라</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="../../2019/02/28/effective-java-item59/">Item 59. 라이브러리를 익히고 사용하라</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="../../tags/Effective-Java/">Effective-Java</a></span><div class="content"><h1 id="무작위-정수-만들기"><a href="#무작위-정수-만들기" class="headerlink" title="무작위 정수 만들기"></a>무작위 정수 만들기</h1><p>무작위 정수를 하나 생성한다고 해보자 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">random</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(rnd.nextInt()) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>괜찮아 보이지만 3가지의 문제를 내포하고 있다.</p>
<ul>
<li><p>n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.</p>
</li>
<li><p>n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span> * (Integer.MAX_VALUE / <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(random(n) &lt; n/<span class="number">2</span>) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>random 메서드가 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제로는 666,666에 가까운 값을 얻는다.<br>무작위로 생성된 수 중에서 2&#x2F;3 가량이 중간값보다 낮은 쪽으로 쏠린 것이다.</p>
<ul>
<li>지정한 범위 바깥의 수가 종종 튀어나올 수 있다. rnd.nextInt()가 반환한 값을 Math.abs를 이용해 음수가 아닌 정수로 매핑하기 때문이다.</li>
</ul>
<h1 id="표준-라이브러리를-사용하면-다른-프로그래머들의-경험을-활용할-수-있다"><a href="#표준-라이브러리를-사용하면-다른-프로그래머들의-경험을-활용할-수-있다" class="headerlink" title="표준 라이브러리를 사용하면 다른 프로그래머들의 경험을 활용할 수 있다."></a>표준 라이브러리를 사용하면 다른 프로그래머들의 경험을 활용할 수 있다.</h1><ul>
<li>메서드의 동작 방식은 몰라도 알고리즘에 능통한 개발자나, 여러 분야의 전문가가 설계와 구현에 시간을 들여 개발한 것이다.</li>
<li>버그가 발생되더라도 다음 릴리스에 수정 보완 개선이 될 수 있다.</li>
<li>표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.</li>
<li>핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 되고 어플리케이션 기능 개발에 집중할 수 있다.</li>
<li>따로 노력하지 않아도 릴리즈가 나올 때 마다 성능이 지속해서 개선된다.</li>
<li>기능이 점점 많아진다. 개발자 커뮤니티에서 나온 이야기를 바탕으로 논의 후 다음 릴리즈에 기능이 추가되곤 한다.</li>
<li>라이브러리를 사용하면 많은 사람들에게 낯익은 코드가 된다. 다른 개발자들이 유지보수 하기 쉬워지고 재사용성이 높아진다.</li>
</ul>
<h1 id="메이저-버전-릴리즈-마다-수많은-기능이-추가된다"><a href="#메이저-버전-릴리즈-마다-수많은-기능이-추가된다" class="headerlink" title="메이저 버전 릴리즈 마다 수많은 기능이 추가된다."></a>메이저 버전 릴리즈 마다 수많은 기능이 추가된다.</h1><ul>
<li>자바는 메이저 릴리즈마다 새로운 기능을 설명하는 웹페이지를 공시한다.</li>
<li>한 번쯤은 읽어볼만 하다</li>
<li>너무 많아서 읽기 힘든 경우에는 java.lang, java.util, java.io와 하위 패키지들에는 익숙해져야 한다.</li>
<li>컬렉션 프레임워크나 concurrent 패키지는 알아두면 도움이 도니다.</li>
</ul>
<h2 id="예시-transferTo-메서드를-이용해-URL-내용-가져오기"><a href="#예시-transferTo-메서드를-이용해-URL-내용-가져오기" class="headerlink" title="예시 - transferTo 메서드를 이용해 URL 내용 가져오기"></a>예시 - transferTo 메서드를 이용해 URL 내용 가져오기</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(args[<span class="number">0</span>]).openStream()) &#123;</span><br><span class="line">        in.transferTo(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>java 9 버전 부터 URL정보를 쉽게 출력해 주는 transferTo 메서드를 제공한다.</li>
</ul>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><ul>
<li>라이브러리가 전문적인 기능을 제공해 주지 못할수도 있지만, 라이브러리를 일단 사용해보자</li>
<li>특별한 기능이 아니라면 누군가 라이브러리로 만들어 두었을 가능성이 높다.<br>일단 라이브러리가 있는지 찾아보자</li>
<li>일반적으로 라이브러리의 코드는 개발자가 작성한 것보다 품질이 좋고 개선의 여지가 있다.</li>
<li>라이브러리 코드는 주목을 많이 받고 개발자 커뮤니티에서 문제점이 많이 거론되므로 코드 품질이 점차 좋아진다.</li>
</ul>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li>Effective Java 3rd Edition - Item 59. 라이브러리를 익히고 사용하라</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="../3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../3/">3</a><span class="page-number current">4</span><a class="page-number" href="../5/">5</a><span class="space">&hellip;</span><a class="page-number" href="../12/">12</a><a class="extend next" rel="next" href="../5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Carrey</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="../../js/utils.js?version=1.9.0"></script><script src="../../js/fancybox.js?version=1.9.0"></script><script src="../../js/sidebar.js?version=1.9.0"></script><script src="../../js/copy.js?version=1.9.0"></script><script src="../../js/fireworks.js?version=1.9.0"></script><script src="../../js/transition.js?version=1.9.0"></script><script src="../../js/scroll.js?version=1.9.0"></script><script src="../../js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>